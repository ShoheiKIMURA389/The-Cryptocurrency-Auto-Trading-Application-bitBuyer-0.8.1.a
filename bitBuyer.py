# -*- coding: utf-8 -*-
"""
【VS Code の設定における 135 文字ルーラーの使用ガイドライン】
このファイルでは、VS Code の settings.json の設定「"editor.rulers": [135]」のルーラー表示によって、一行を 135 文字まで使用する記述を行っています。これは
単なるガイドラインではなく、このラインを超える行は必ず適切な箇所で改行、もしくは行末コメントは直前行に移動します。コードを複数行に分ける場合で括弧外の場合は、
option + ¥ キー（Mac）でバックスラッシュを使用します。行末コメントを直前行に移動した場合でも、コードブロックに対するコメントと混同して理解されてしまうリスクは
ありません。これは、全てのコード行に行末コメントを付与しているためです。また「適切な箇所で改行」という表現には、単語単位で改行を行うことも意味として含まれます。
これは単語の途中で改行を行わないことを意味します。このスタイルの目的は、ファイル全体でドキュメントの表現を統一するために後から表現の検索を行う際に、単語単位での
検索を可能にするところにあります。

【ソースコードのメンテナンス継承のためのコメント付与ポリシー】
このアプリケーションでは、開発者が将来のエンジニア、またはサードパーティのエンジニアへメンテナンス作業（保守・点検・アップデート）を継承するため、全てのコードに
説明コメントを付与しています。全てのコメントは、開発者からこのアプリケーションのソースコードを提供された者に、このアプリケーションの機能の維持や管理、または拡張を
容易に行える環境を提供することを目的として記述しています。またここで言う「容易に行える」という表現は､「このアプリケーションのソースコード及びコメントが、全くの
プログラミング初学者に対する教材としての役割も果たす」という意味合いも含みます。そのため同じロジックには必ず同じコメントを付与しており、ソースコードのどこを見ても
プログラミング初学者が内容を理解できるよう、情報を均一に配置しています。これは同じ説明がソースコードのいたるところに存在することを意味し、冗長性を増しますが、この
点については重複する処理の最大限のカプセル化を行うことで対処しています。このアプリケーションのソースコードの継承容易性を担保するため、このコーディングスタイルには
将来のエンジニア、またはサードパーティのエンジニアも従うことが求められます。ただしコメントは専門用語を含み、プログラミング初学者が ChatGPT 4 などの生成 AI を
併用することを前提として記述しているため、コメントが教材として充分にその役割を果たすには、ChatGPT 4 などの生成 AI の支援が必要です。この前提を満たす限り、この
アプリケーションのソースコードを提供された者は、継続的に機能をメンテナンス及びアップデートすることで、利益の追求を行うことができます。

【プラットフォーム互換性を意識した Apple Silicon 向けの Python プログラミング】
このアプリケーションの開発対象環境は Apple Silicon 搭載 Mac です。従って開発はこの対象にフォーカスして行いますが、これは必ずしもプラットフォーム間の互換性を
考慮しないものではありません。このアプリケーションの開発は、将来のエンジニア、またはサードパーティのエンジニアが異なるプラットフォームへの対応または最適化を行い
やすくする環境を提供する前提で行います。開発言語に Python を採用しているのもこの一環であり、また、他のプログラミング言語と比べて以下の点で秀でているためです。
まず、Python のシンプルで直感的な文法はコードの読みやすさと書きやすさを大幅に向上させ、インデントによるブロック構造は視覚的にも分かりやすく、コードのメンテナンス
性を高いレベルで提供しています。また、Python には広範な標準ライブラリが付属しており、ファイル操作、データ解析、ウェブ開発など、多岐に渡るタスクを効率的に行うこと
ができます。さらに、Python は macOS、Linux、Windows などの主要なプラットフォームで動作するため、Apple Silicon 搭載 Mac を対象に開発を行ったとしても、
異なるプラットフォームへの対応が容易に行えます。Python はウェブ開発、データサイエンス、機械学習、自動化スクリプト、ゲーム開発など、さまざまな分野で幅広く使用され
ており、このため、Python のコミュニティは非常に大きく活発で、多くのオープンソースプロジェクトやフォーラム、ドキュメントが利用可能なため、問題解決も容易に行え
ます。Python は他のプログラミング言語やツールと簡単に統合することもでき、C/C++ などのライブラリを使用することでパフォーマンスを向上させることが可能です。
インタープリタ型であるため他の言語と比べて実行速度の面でやや劣るものの、その分、開発速度やデバッグのしやすさが大きな利点となります。これらの要素が相互作用している
ことから、Python は初学者にとって学びやすい言語であると言え、シンプルな文法と豊富なリソースによってプログラミングの基本を理解しやすくなっています。これらの特徴に
より、Python は初学者からプロフェッショナルまで幅広いユーザーに支持されており、開発言語として非常に優れています。これが、このアプリケーションで Python を開発
言語として採用している理由です。

2023 / 10 / 30, PROJECT STARTED.
サポート環境：ニューラルエンジン搭載の Apple Silicon Mac。

ライセンス・著作権表記
bitBuyer 0.8.1.a - AI-driven Crypto Auto Trading System
Copyright ©2023 Shohei KIMURA (bitBuyer.dev)
Licensed under the GNU General Public License v3.0 (GPLv3)
See https://www.gnu.org/licenses/gpl-3.0.html for details.
Official website: https://bitBuyer.dev

クレジット表記（第三者の方へ：可能な場合、この部分は維持してください）
- プロジェクト -
『bitBuyerプロジェクト』におけるオリジナル版『0.8.1.a』。

- 開発者 -
Shohei KIMURA (Founder & Lead Developer)

- 連絡先 -
Mail：bitbuyer.0.8.1.a@icloud.com（件名には "bitBuyer 0.8.1.a" を必ず含めてください）

- スペシャルサンクス -
Ai YAMAMOTO (Stakeholder: Shohei KIMURA)
Saki UMEDA (Stakeholder: Shohei KIMURA)

And others, by memory with figures...

- 契約 -
●本契約では本プロジェクト『bitBuyerプロジェクト』には管理権限が存在すると定める。
●本プロジェクトに関する本契約は、木村翔平または木村翔平から正式にプロジェクト管理権を引き継いだ者とプロジェクト協力者との間でのみ効力を有する（以下「当事者」）。
●本契約では本プロジェクトが開発・公開するソフトウェアの名称を『bitBuyer 0.8.1.a』と定める。
●本プロジェクトのソースコードは、GNU General Public License, version 3（GPLv3）の下で公開され、第三者による派生バージョンの作成・公開を許可する。
●本プロジェクトの管理権は木村翔平または木村翔平から正式にこれを引き継いだ者が有するが、本プロジェクトの理念を変更する権限は本契約の下木村翔平以外有さない。ただし、
既存の理念に基づいた広く社会に資するための変更は認めるものとする。また、木村翔平も本契約の下本プロジェクトの理念を公益に資するものとして拡大することはできるが縮小
することはできない。ただし、当事者以外にこの契約の効力は及ばない。
●プロジェクト協力者は、本プロジェクトの理念及びオープンソースコミュニティへの貢献を継続するため、提供する全てのソースコードについて GPLv3 を遵守する義務を負う。
ただし、GPLv3 の後継ライセンスが発行された場合において、そのライセンスが本プロジェクトの既存の権利管理体制を維持する場合に限り、その後継ライセンスへの移行を認める
ものとする。ここで言う「既存の権利管理体制を維持する」とは、現行のライセンスの下で確立された権利管理の範囲が全て継続され、かつ権利管理の範囲が維持または拡大する
場合のみを指す。なお、本プロジェクトの権利管理体制が後継ライセンスへの移行によって追加的に制限されることは許可されない。ただし、本条文は次の条文に従う。
●PyQt などの本プロジェクトが利用するソフトウェアのライセンス条項が GPLv3 より別のライセンスへ移行し、本プロジェクトの理念の継続性が危ぶまれる場合は、選択可能な
最も広い自由度を有するライセンスへの移行を妨げない。
●本契約の下、本プロジェクトの開発者として、木村翔平の功績は公式に記録され、本プロジェクトのクレジット及び関連文書の先頭に常に明記されるものとする。ただし、当事者
以外にこの契約の効力は及ばない。
●本契約に基づく許可及び本プロジェクトの管理方針は、木村翔平または木村翔平からプロジェクト管理権を正式に引き継いだ者の合意なしに、一方的に変更または取り消されること
はない。この変更不可の原則は、本プロジェクトがオープンソースのまま維持されることを保証するものであり、本プロジェクトの発展及び透明性を確保するために不可侵とする。
このため木村翔平からプロジェクト管理権を正式に引き継いだ者が本プロジェクトの理念を完全に理解しないまま行う変更または取り消しの決定または合意は全て無効とする。
この条文は無効と判断可能な決定の効力が発効した後にも効力を発揮可能と定め、木村翔平からプロジェクト管理権を正式に引き継いだ者はこの決定に従わなければならない。

【クレジット及びスペシャルサンクス表記の原則（当事者間の契約）】
●本プロジェクト（『bitBuyer 0.8.1.a』、その後継バージョン）におけるクレジット及びスペシャルサンクス表記は、以下の原則に従い、厳格に管理される。
●本契約の当事者であるプロジェクト管理権者・プロジェクト協力者以外には、この原則の尊重を希望するものに留め、強制はしないものとする。

1. クレジット及びスペシャルサンクス表記は、プロジェクトの開発・運営において、技術的・運営的貢献を行った者、精神的支援を行った者を記録するものであり、その順序の
変更・削除は一切許可されない。

2. スペシャルサンクスの対象者は、以下の条件を全て満たす者に限定される。
   - クレジットに記載される個人との直接的な関係性が、過去または現在を通じて存在する者。
   - 精神的支援を直接的または間接的に行い、本プロジェクトの開発・継続・普及に特別な影響を与えた者。
   - その支援が一時的ではなく、開発対象期間に渡り持続し、かつさらなる開発の継続を促す者。
   - プロジェクト関係者（開発者・運営メンバーなど）との間に、精神的なサポートを認められる具体的な証明ができる者。
        - 精神科医やカウンセラーによる証言または証明を得ることができる、など。
   - 広く一般に影響を与えた著名人（アイドル・俳優・公的機関など）であっても、個人的かつ直接的な関係性の証明がない場合は対象外とする。

3. 初期スペシャルサンクス
   - 以下の 2 名を、初期のスペシャルサンクスとして公式に記録し、削除・変更されることは一切ない。
    1. 山本愛
    2. 梅田紗希
   - スペシャルサンクスの表記順序は時系列に基づき固定され、変更されることはない。途中挿入も不可とする。
   - 新たな人物が追加される場合も、既存の順序は厳守される。

4. スペシャルサンクスの追加基準
   - 新たにスペシャルサンクスに名前を追加する場合、上記の「対象者」の条件を全て満たし、正式な申し込みの上でのみ承認される。
        - 正式な申し込みは木村翔平または木村翔平からプロジェクト管理権を正式に引き継いだ者が受理するものとする。
   - 追加される場合でも、既存の時系列順序を変更することは許可されず、既存のリストへの途中挿入も許可されない。
   - 本プロジェクトに関わる限り、誰でもスペシャルサンクスの追加申請を行うことができるものとする。ただし記載を保証するものではない。

5. クレジット及びスペシャルサンクス表記の不変性
   - 全てのクレジット表記及びスペシャルサンクスの順序・内容は変更または削除されることはなく、プロジェクトが存続する限り維持される。
   - 本原則は、知的財産権を管理する個人によっても変更・削除することは本契約により許可されない。
   - スペシャルサンクスの基準及び表記方法は、本契約において固定され、変更の余地はない。

6. クレジット表記及びスペシャルサンクス表記
   - プロジェクトの開発者及び貢献者のクレジット表記は、以下の形式で記載される。
    - 開発者 -
    Shohei KIMURA (Founder & Lead Developer)

    - 貢献者 -
    John Doe

   - スペシャルサンクスの表記は、以下の形式で記載される。
    - スペシャルサンクス -
    Ai YAMAMOTO (Stakeholder: Shohei KIMURA)
    Saki UMEDA (Stakeholder: Shohei KIMURA)

   - 追加が必要な場合は、精神的支援の開始時期が早い順に並べる。

【附則】
●本契約締結時点で名称『bitBuyer』の商標登録は未完了であるが、ここにこれが完了した場合としない場合の方針を定めるものとする。
●完了した場合：第三者が『bitBuyer 0.8.1.a』の派生バージョンを『bitBuyer』（以下「本名称」）の名の下に公開することを希望する場合、当該第三者も本契約の当事者と
なるものとする。ただし、当該第三者は木村翔平または木村翔平からプロジェクト管理権を正式に引き継いだ者との連携の義務を負わず、派生バージョン作成時点での本クレジット
表記を維持することのみを求められるものとする。ただし、本名称を使用する限りにおいて、本プロジェクトの理念には追従しなければならない。
●完了しない場合：木村翔平または木村翔平からプロジェクト管理権を正式に引き継いだ者が別途発案する別名（以下「本別名」）によって当事者に本契約の義務を課す。ここで言う
当事者には、本別名の使用を希望する第三者を含む。なお、本別名を必要とするに足る事由が発生する状況下においても、本プロジェクトは『bitBuyer』の名の先使用権を既に
使用している範囲において本プロジェクトでの使用が適法に認められる可能性のある根拠を有し、また商標権が保護する商業的競合の排除に該当する可能性が低く、
『bitBuyerプロジェクト』『bitBuyer Project』『bitBuyer 0.8.1.a』の非営利活動名が『bitBuyer』単体での商標権による保護を受ける可能性も極めて低いことを
確認済みであることをここに明記する。プロジェクト名や数字の羅列は一般的に商標としては認められない。
●本契約は本契約の当事者（プロジェクト管理権者・プロジェクト協力者）以外には効力を及ぼさず、GPLv3 と衝突するものではない。本契約は『bitBuyer 0.8.1.a』に携わる
者にのみ効力を有する。また、本契約は『bitBuyerプロジェクト』の名、または別の商標名が必要になった場合の別名の下で開発される後継バージョンに対して引き継がれる。
"""

"""
以下はプログラミング初学者向けの Python における技術的なガイドラインです。ここに記載しているもの以外の技術的な説明は全て、全てのコード箇所に記載しています。

【クラスのインスタンスとは】
クラスのインスタンスとは、クラス定義を基にして作成される具体的なオブジェクトのことです。クラス定義はインスタンスの設計図であり、遺伝子のように属性（変数）や動作
（関数）を定義しています。遺伝子を基にして具体的な個体が形作られるように、クラス定義からインスタンスが作成されます。インスタンスは自身の属性（変数に代入された具体
的なデータ）を持つことや動作を行う（関数を実行する）ことができ、クラスが定義する機能を具体的に実行します。これにより、同じクラスから複数の異なるインスタンスを作成
し、それぞれが独立した状態や動作を持つことができます。例えば、一つのクラス定義から複数のインスタンスを作成し、それぞれのインスタンスを個別のバックグラウンド
スレッド（バックグラウンドの実行環境）に移動させることで、クラスが定義する異なる機能を同時に実行する、ということが可能です。


【クラス属性、インスタンス属性とは】
「クラス属性」と「インスタンス属性」は、クラスまたはクラスのインスタンスが持つデータを区別するための用語です。

クラス属性は、クラス自体に関連付けられている変数です。クラスの全てのインスタンスで共有されるため、クラス名を通じてアクセスすることができます。クラス属性は、クラス
が定義される際に一度だけ作成され、その後全てのインスタンスがその値を共有します。例えば、全てのクラスのインスタンスに共通する設定や定数などをクラス属性として定義
することができます。

インスタンス属性は、特定のインスタンスに関連付けられている変数です。インスタンスが作成される度に、新しいインスタンス属性がそのインスタンスに対して作成されます。
インスタンス属性は、それぞれのインスタンスが独立して持つデータであり、他のインスタンスとは共有されません。例えば、バックグラウンドスレッド（バックグラウンドの実行
環境）の機能を提供する役割を持つクラスから作成された二つの異なる「クラスのインスタンス」のインスタンス属性に、インスタンス毎に異なるデータを持たせることで、
それぞれのバックグラウンドスレッドに別の役割を持たせるといったことが可能です。

インスタンス属性の定義や参照は「self.変数」のようにします。クラス属性の定義時には「self.」は必要ありません。クラス属性を参照する際は、クラス内からであれば直接
属性名を通じて行えます。クラス外からクラス属性を参照する際は「クラス名.属性名」のようにします。クラス属性はクラス全体に適用される共通のデータを保持し、
インスタンス属性は個々のインスタンス毎に異なるデータを保持することができます。クラス属性とインスタンス属性を適切に使い分けることで、効率的かつ柔軟なデータ管理が
可能となります。


【インスタンス関数とは】
インスタンス関数とは、クラスのインスタンスを通じて呼び出される関数（メソッドとも呼ばれる）のことです。インスタンス関数は、そのクラスのインスタンスに関連付けられて
おり、第一引数として self を取ります。この self は関数が呼び出された際に、関連付けられたインスタンスを自動的に参照することを意味し、インスタンス内の属性や他の
関数にアクセスするために使用されます。

一方、インスタンス関数でない関数とは、関数定義時に self を定義しない関数のことです。これらの関数は、インスタンスやクラスに依存せず、独立して動作します。このため、
インスタンス関数とは異なり、特定のインスタンスに関連付けられることなく、クラス外部やクラス内で通常の関数として扱われます。

Python では、クラス内に直接定義される関数は基本的にインスタンス関数とすることが慣習となっています。ただし、インスタンス関数の内部にさらにインスタンス関数を定義
することは推奨されません。これは、コードの可読性が低下し、デバッグやメンテナンスが困難になるためです。インスタンス関数の内部に補助関数を定義することは構造化された
コードを構築するために有用ですが、インスタンス関数内にさらにインスタンス関数を定義するとスコープが複雑になり、意図しない動作を引き起こす可能性があるため、これは
避けるべきです。

インスタンス関数とインスタンス関数でない関数の違いは、その関数がクラスのインスタンスに関連付けられているかどうかです。インスタンス関数は特定のインスタンスの状態や
動作を操作するために使用され、インスタンスの属性（変数に代入された具体的なデータ）や他の関数にアクセスします。一方、インスタンス関数でない関数は、インスタンスを
介さずに呼び出すことができ、クラスやインスタンスに依存しない動作をします。


【スコープ、クロージャ、キーワードの概念】
● スコープ：
プログラミングにおいて、スコープは変数や関数（メソッドとも呼ばれる）が有効な範囲を指します。スコープはプログラムがどの部分で変数や関数にアクセスできるかを決定
します。スコープには以下の種類があります。

ローカルスコープ：関数内で定義された変数は、その関数内でのみ有効です。関数が終了するとローカルスコープの変数も破棄されます。関数内で定義された変数は、関数外から
はアクセスできません。
エンクロージングスコープ：関数の内側に定義された関数から見て、外側の関数のスコープです。外側の関数で定義された変数は、内側の関数から参照できます。クロージャの理解
において重要な概念です。
グローバルスコープ：プログラム全体で有効なスコープです。通常、モジュールのトップレベルで定義された変数が含まれ、モジュール内のどこからでもアクセス可能です。
ビルトインスコープ：Python に標準で用意されている関数や例外が含まれます。特定のモジュールをインポートせずにアクセス可能です。

これらのスコープの概念は、変数の有効範囲とそのアクセス制御を管理するために重要です。スコープと階層の違いについても理解が必要です。階層はプログラムの構造を示し、
スコープは変数や関数の有効範囲を示します。例えば、関数の内側にさらに関数を定義すると、それは階層構造になりますが、それぞれの関数には独立したローカルスコープが存在
します。

● クロージャ：
クロージャは、関数とその関数が定義された環境（スコープ）をパッケージ化したものです。クロージャは、関数が定義されたスコープの他の変数を保持したまま、関数を新たな
スコープで実行できます。関数が外部の変数を「覚えている」ため、関数外の状態を操作できるという利点があります。クロージャで参照できる属性にはミュータブル（変更可能）
とイミュータブル（変更不可能）があります。ミュータブルな属性（例：リスト、辞書）はそのまま変更できますが、イミュータブルな属性（例：整数値、文字列）は直接変更でき
ません。イミュータブルな属性を変更するには nonlocal キーワードを使用する必要があります。これにより、エンクロージングスコープ内の変数を参照及び変更できます。
しかし、クロージャや nonlocal キーワードの使用は便利ですが、多用すると保守性の低下を招く可能性があります。特に、内部関数を外部関数に格上げする際には、その関数が
依存する外部の変数や状態が多くなるため、移行の際にそれらの依存関係を清算する必要が生じ、保守性が低下することがあります。

● キーワード：
Python には、特定の動作を制御するためのキーワードがいくつかあります。以下はその一部です。

global：グローバルスコープの変数を関数内で参照及び「変更」するために使用します。
nonlocal：エンクロージングスコープの変数を関数内で参照及び変更するために使用します。これにより、ローカルスコープの変数に影響を与えることなく、外側のスコープの
変数を操作できます。ただし、ローカルスコープで既に使用済みの変数名と同名のエンクロージングスコープの属性を nonlocal として宣言しようとするとエラーが発生します。
（関数 ExecuteAPIrequest() > ProcessParamsString() > FlagHandler() で使用していますので、ご参考ください）

これらのキーワードは、変数のスコープや関数の動作を管理するための重要な要素です。特に、nonlocal や global キーワードを理解することで、関数内での変数の扱い方や
スコープの管理がより柔軟になります。

スコープ、クロージャ、そしてキーワードは、Python プログラムの動作を理解し、効果的に管理するために不可欠な概念です。スコープは変数の有効範囲を定義し、クロージャは
関数とその定義環境をパッケージ化します。キーワードはこれらの概念を活用するためのツールとして機能します。これらの概念を理解することで、Python プログラムをより効率
的かつ柔軟に記述することが可能になります。しかし、このアプリケーションでは高い保守性を確保するため、クロージャによる参照や nonlocal キーワードによるエン
クロージングスコープ属性の変更は、それを行う関数が特定のコンテキストでのみ使用される場合に限って行うようにしています。また、そのような操作を行う関数の場合は関数の
docstring 内で明示的にその点について触れています。これらの考慮点を踏まえると、このアプリケーションの保守・点検に際してはスコープ、クロージャ、キーワードの概念は
特別に意識する必要はありません。


【リストのスライス指定の仕組み】
Python におけるリストのスライス指定「start:stop」は、「start:（"start" の部分は任意の数値）」は「以上（指定した数値を含む）」として機能し､「:stop（"stop"
の部分は任意の数値）」は「未満（指定した数値を含まない）」として機能します。


【テキストを行毎に分割（split("\n")）する際の注意点（"\n" は Mac の改行文字）】
最終行に改行が含まれる場合、split("\n") を使って改行で分割してリストを取得すると、作成されるリストの最後の要素として空文字列が格納されます。これはリストの範囲長
（len(list)）が元のテキストの行数 + 1 となることを意味し、これは適切に処理しなければ、場合によっては意図しない結果を引き起こす可能性があります。もしこれが不都合
な場合、「SomeText.split("\n")[:-1]」のように負のスライスを指定することで、作成されるリストの最後の空文字列を無視したリストを取得することができます。改行文字
「\n」は macOS や Linux で使用されるものであるため、Windows では適切な改行文字を使用する必要があります。適切な改行文字は LogManagerClass のインスタンスを
持つクラスであれば self.LF で利用可能です。
"""

# 以下、アルファベット順
# bitbank API ドキュメント：https://github.com/bitbankinc/bitbank-api-docs/blob/master/README_JP.md
# bitFlyer API ドキュメント：https://lightning.bitflyer.com/docs?lang=ja
# BitTrade API ドキュメント：https://api-doc.bittrade.co.jp
# Coincheck API ドキュメント：https://coincheck.com/ja/documents/exchange/api
# GMOコイン API ドキュメント：https://api.coin.z.com/docs/?python

r"""
コード整形スニペット（正規表現）
1、「=」は「(?<! )=(?! )」で検索し「 = 」とする。
2、「半角スペース + 改行」は「[ \t]+\n(?!\n)」で検索し、改行の直前に半角スペースが来ないようにする。
3、「全角文字に挟まれた半角英数」は
「(?<!「)(?<=[^\x00-\x7F])(?!、)[A-Za-z0-9]+(?=[^\x00-\x7F])(?!」)(?<!（)(?!）)(?<!、)(?!、)(?<!。)(?!。)(?<!、)(?!（)(?<!（)(?!､)(?<!　)(?!：)」
で検索し、半角スペースで挟む。

コーディングルール
1、クラス名、関数名、変数名はアッパーキャメルケース（UpperCamelCase）とし、必要に応じて "_"（アンダースコア）を併用する。「Example_ofSomeVariable」のよう
に「_of」という表記を認める。"API" や "URL" のように大文字で表記することが慣例となっている単語をアッパーキャメルケースに含める必要がある場合､「APIkey」や
「APIrequest」のように表記する。以下はこれを確認するための正規表現。
「(?<!Q)(?!OS[a-z])(?!URL[a-z])(?!RL[a-z])(?!HTTP[a-z])(?!TTP[a-z])(?!TP[a-z])(?!API[a-z])(?!PI[a-z])(?!ID[a-z])(?!JSON[a-z])(?!SON[a-z])(?!ON[a-z])(?!OA)(?!GPL[a-z])(?!PL[a-z])(?!Q[ABCDEFGHILMOPQRSTVW])[A-Z]{2,}(?=[A-Za-z])(?![A-Z])」
※日本語で考えた変数名のアッパーキャメルケース化は、ChatGPT 3.5 に「英語のアッパーキャメルケースにしてください」と指示するのが最も簡便。
2、クォーテーションは基本的にダブルクォーテーションを使用する。
3、コード内の各コードブロックには必ずコメントタイトルを付ける。
4、各コード行には必ずインラインコメントを付ける。
※コメントタイトルはコードブロック開始行の行末に置くこととするが、ウィンドウ幅に収まらない場合、開始行の直前行にコードブロックと同じインデントレベルで置く。この
ルールはコメントタイトル以外の他のコメントにも適用する。
"""

"""
以下は正規表現作成のための ChatGPT 4 への指示用コメントです。

VS Code での正規表現作成においては、JavaScript の正規表現構文に準拠することが基本です。特殊文字に対するエスケープ処理は、通常、バックスラッシュを使用して行われ
ますが、引用符や括弧など一部の記号は、特定のコンテキストにおいてエスケープが不要であることが確認されています。特に否定的先読み及び後読みにおいて、固定長のパターン
のみがサポートされていることを念頭に置き、これらの構文を使用する際にはエスケープの必要性を個別に検証することが重要です。正規表現を構築する際には基本的なパターン
から始めて段階的に条件を追加し、各部分を個別にテストしてエラーが発生しないことを確認した上で、最終的なパターンを組み立てるアプローチが効果的です。
"""

"""
以下は ChatGPT 4 へのアプリケーションの説明用コメントです。

現在「bitBuyer」というアプリケーションを Python の PyQt フレームワークをベースに開発しています。この会話においてはこの後、コードを示しながらサポートを求めます
が、その際、以下のコードを前提にサポートを行ってください。なお、アプリケーションは「LogManagerClass、AppClass、DisplayClass、AssistanceClass、
MainThreadFunctionsClass、SubThreadFunctionsClass、TaskMonitoringThreadClass が同順序で同じ階層にあり、AppClass で DisplayClass、
MainThreadFunctionsClass を同順序でインスタンス化して、それらインスタンスに AppClass のインスタンス（引数 AppInstance）を渡している」という構造になって
います。各クラスのインスタンス名は self.Display、self.MainFunctions です。DisplayClass はウィジェットの表示に関する処理を行っています。
MainThreadFunctionsClass は AppClass に必要な機能を全て提供する責務を担い、二つのクラスは共に不可分な関係として設計しています。従って AppClass に必要な
関数は全て MainThreadFunctionsClass に配置されているということになります。この設計により、MainThreadFunctionsClass の関数は全て Qt イベントループ内で
動作することが保証されています。SubThreadFunctionsClass はアプリケーションのデータ処理部分を担う責務を負い、MainThreadFunctionsClass の初期化時に
同コンストラクタ内で初期化されます。このとき、SubThreadFunctionsClass にも AppClass のインスタンス（引数 AppInstance）が渡されますが、同クラスではこの
インスタンスに含まれる GUI コンポーネントへはアクセスしません。同インスタンスは、データ処理時に必要な、アプリケーションの設定変数などにアクセスすることにのみ使用
されます。SubThreadFunctionsClass はアプリケーションのメインスレッド（Qt イベントループ）とは別のバックグラウンドスレッド（サブスレッド）で非同期的に動作し、
この動作は全て MainThreadFunctionsClass の関数によってハンドリングされています。MainThreadFunctionsClass は TaskMonitoringThreadClass の
インスタンスを持ち、ハンドリングにはこのクラスの機能も使用されます。また AssistanceClass は AppClass の機能を補助するものとして、AppClass に依存しない設計
になっています。現在のところ、AssistanceClass には静的関数のみが定義されています。コード例を示すときは、この構造に則ってください。

これらと以下のコードを了解したら「了解しました」とだけ応答してください。
"""

"""
以下は、開発者からこのアプリケーションのソースコードを提供された者へのアドバイスです。

ChatGPT 4 から提供されたコードを適用する場合、必ずインデントの数を実際のコード環境に合わせる作業が必要になります。このとき、VS Code では、インデントを調整
したい範囲を選択後に Tab キーを押すことで選択範囲のインデントをまとめて増やすことができます。減らす場合は Shift + Tab キーです。

コード中で似たような処理を行っている箇所を検索で見つけたい場合、付与しているコメントで検索すると効率的です。コメントはコードが似たような処理を行っている場合
（変数名が異なるなど）、同じものを付与しています。ただし、同じ処理を行うコードは全てカプセル化している前提です。
"""

# 必要なモジュールをインポート・標準ライブラリ（アルファベット順）
import asyncio  # 非同期 I/O
import base64  # Base64 エンコーディング
import copy  # オブジェクトの浅いコピーと深いコピー
import hashlib  # ハッシュ関数
import hmac  # HMAC アルゴリズム
import html  # HTML エスケープとアンエスケープ
import httpx  # HTTP クライアント
import json  # JSON エンコーディングとデコーディング
import logging  # システムログ管理
import os  # OS 機能へのアクセス
import platform  # 実行されている OS の識別
import pytz  # Timezone 操作
import queue  # スレッド間通信用キュー
import re  # 正規表現
import string  # 文字列操作
import subprocess  # サブプロセス管理
import sys  # システムパラメータと関数
import time  # 時間アクセスと変換
import unicodedata  # Unicode データベース
import urllib.parse  # URL の解析
import xml.etree.ElementTree as XMLtools  # XML 解析（慣習としては as ET とすることが多いが、ここでは分かりやすさを重視したインポートを行う）
import xml.sax.saxutils as saxutils  # XML 特殊文字のエスケープとアンエスケープ

from datetime import datetime, timezone  # 日付と時刻、Timezone 操作
from dateutil import parser  # 日付解析
from urllib.parse import urlencode, urljoin  # URL セーフエンコード、URL 操作

# 必要なモジュールをインポート・サードパーティのライブラリ（アルファベット順）
from cryptography.exceptions import InvalidKey  # 暗号化例外
from cryptography.fernet import Fernet, InvalidToken  # 暗号化
from cryptography.hazmat.backends import default_backend  # 暗号化バックエンド
from cryptography.hazmat.primitives import hashes, padding  # ハッシュ、パディング
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes  # 暗号化、アルゴリズム、モード
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC  # キーダイバージョン
from pympler import asizeof  # メモリ使用量測定
from requests import get  # HTTP リクエスト
from requests.auth import HTTPBasicAuth  # HTTP 基本認証
from requests_oauthlib import OAuth2Session  # OAuth 2.0 認証

# 必要なモジュールをインポート・PyQt 関連（アルファベット順）
from PyQt5 import QtCore, QtWidgets  # 基本的な Qt 機能、ウィジェット
from PyQt5.QtChart import QCandlestickSeries, QChart, QChartView, QDateTimeAxis  # キャンドルチャート用のクラス、日時軸クラス
from PyQt5.QtCore import QDate, QDateTime, QMetaMethod, QMetaObject, QObject, QMutex, QMutexLocker, QThread, Qt, \
    QTime, QTimer, pyqtSignal, pyqtSlot  # QMetaMethod、QMetaObject、QObject、QMutex、QMutexLocker、QThread、Qt、その他の Qt コア機能
from PyQt5.QtGui import QFont, QTextCursor  # フォント設定とテキストカーソル操作
from PyQt5.QtWidgets import QApplication, QCheckBox, QComboBox, QDateEdit, QDateTimeEdit, QDialog, QDoubleSpinBox, \
    QFontDialog, QGridLayout, QHBoxLayout, QLabel, QLineEdit, QMainWindow, QMessageBox, QPushButton, QProgressBar, \
    QRadioButton, QScrollArea, QSlider, QSpinBox, QTextEdit, QTimeEdit, QVBoxLayout, QInputDialog, QWidget  # GUI ウィジェット

# 必要なモジュールをインポート・自作のモジュール（アルファベット順）
pass  # 将来追加する場合はここに記述

# ロガーの準備
logging.basicConfig(level = logging.DEBUG)  # ログの基本設定を DEBUG レベルに設定
logger = logging.getLogger(__name__)  # 現在のモジュール名でロガーを取得
logger.debug("Logger: {0}".format(str(logger.isEnabledFor(logging.DEBUG))))  # DEBUG レベルが有効かどうかをログに記録

# ログ管理機能をまとめたクラス
class LogManagerClass(QObject):  # QObject を継承（PyQt フレームワークのシグナルとスロットのメカニズムを使用するため）
    """ この部分を「クラスの docstring」と言います。
    このアプリケーションでは、暗号資産の自動取引を行うというアプリケーションの機能の性質上、バックグラウンド処理を 24 時間 365 日行うことを想定しています。
    そして、アプリケーションの動作が全てバックグラウンドで行われる性質や、取り扱う情報を GUI 上に表示することのウィンドウスペース上の制約、及び表示を更新する
    GUI ウィジェットが多岐に渡ることによるメインスレッドのイベント駆動プログラミングのバッチ処理による対応の限界（応答性の低下によるユーザーエクスペリエンスの
    低下）を鑑み、このアプリケーションでは、自動取引処理中にアプリケーションウィンドウに表示する情報量に一定の制限を設けています。そしてそれに代わるものとして、
    システムログを表示するログテキストエリアを設けています。このアプリケーションでは、このシステムログをアプリケーションが提供する主要なエンターテインメント
    コンテンツと位置付けており、システムログの管理と提供方法には特に注意を払っています。ユーザーは、アプリケーションの運用中にシステムログが高速で更新される状況に
    触れることになり、例えシステムログの内容を認識できなくとも、アプリケーションがバックグラウンドで様々な処理を行っていることを目の当たりにすることにより、満足感
    を得ることができます。システムログは時系列に従って秩序立てて記録するため、一行ずつ確認すればアプリケーションが正しく動作しているか、エラーを起こしていないかを
    確認することができますが、システムログを高速で大量に出力する状況では、これはあまり現実的ではありません。このアプリケーションにおいてシステムログはあくまで
    エンターテインメントコンテンツなので、アプリケーションが正常に動作していることを正確に確認するための情報は、システムログとは別に用意する通常の GUI
    ウィジェットによって正しく提供します。従って、アプリケーションウィンドウに表示する GUI ウィジェットに課す一定の制限とは、アプリケーションが正常に動作している
    かを確認するために必要かどうかという判断基準に従うことです。このクラスは、これらの前提の下、アプリケーションの多様な動作状況を適切に記録するための多彩な機能を
    提供する役割を持ちます。
    """
    SingletonInstance = None  # シングルトンインスタンスを保持する変数を定義
    LF = None  # macOS や Linux、Windows など、OS 毎に適切な改行文字を保存する変数を定義

    # LogManagerClass のシングルトンインスタンスを取得または作成し、シングルトンインスタンスと OS 依存改行文字を返す静的関数
    @staticmethod  # 静的関数であることを示すデコレータ
    def GetInstance():
        """ この部分を「関数の docstring」と言います。
        LogManagerClass のシングルトンインスタンスを取得または作成し、シングルトンインスタンスと OS 依存改行文字を返す静的関数。

        この関数は、アプリケーションにおける LogManagerClass の唯一のインスタンスを返します。インスタンスをまだ作成していない場合には、新しいインスタンスを
        作成し、それを返します。既にインスタンスが存在する場合は、既存のインスタンスを返します。このアプリケーションではマルチスレッドプログラミングを行っている
        ため、バックグラウンドに複数の非同期スレッドが存在します。将来の拡張によってはログテキストエリアの数よりも非同期スレッドの数の方が多くなることも想定され
        るため、アプリケーションはそれらの非同期スレッドが作成するシステムログを適切に管理し、秩序立て、それぞれ対応するログテキストエリアに適切に反映する必要が
        あります。これを実現するためには、システムログを一元的に管理するクラス LogManagerClass が必要であり、一元的に管理するには、クラスのインスタンスが
        アプリケーション内に複数存在してはなりません。そのため、アプリケーションの他のクラスは、全てこの関数を通じて LogManagerClass のシングルトン
        インスタンス、つまりアプリケーションにおける唯一のインスタンスの参照を取得する必要があります。このようなシングルトンインスタンスの実装は、シングルトン
        パターンと呼ばれます。また、この関数はシングルトンインスタンスと共に、OS 依存改行文字も返します。OS 依存改行文字とは、macOS や Linux、Windows で
        採用されている改行文字のことを指します。各 OS 間ではそれぞれ異なる改行文字が採用されているため、このアプリケーションでは LogManagerClass の初期化時に
        適切な改行文字を取得します。アプリケーションの各クラスは、この関数が返すシングルトンインスタンスと OS 依存改行文字を使用して、各 OS に適したシステムログ
        を作成することが可能となります。

        Parameters:
            なし。

        Returns:
            LogManagerClass: LogManagerClass のシングルトンインスタンス。
        """
        if LogManagerClass.SingletonInstance is None:  # シングルトンインスタンスが存在しない場合
            # このクラスのコンストラクタで LogManagerClass.LF を参照するため、先に os.linesep を実行
            LogManagerClass.LF = os.linesep  # macOS や Linux、Windows など、OS 毎に適切な改行文字を取得し、専用の属性に保存
            LogManagerClass.SingletonInstance = LogManagerClass()  # シングルトンインスタンスを新規作成

        return LogManagerClass.SingletonInstance, LogManagerClass.LF  # シングルトンインスタンスと OS 依存改行文字を返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # LogManagerClass を初期化する関数（コンストラクタ）
    def __init__(self):
        """ この部分を「関数の docstring」と言います。
        LogManagerClass を初期化する関数。

        この初期化関数は、LogManagerClass の新しいインスタンスを作成します。インスタンス作成時、LogManagerClass 内で使用される変数を初期化します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        # QObject の初期化
        super(LogManagerClass, self).__init__()  # ログ管理専門クラスなため、parent は省略（デフォルト値：None）

        self.LF = LogManagerClass.LF  # OS 依存改行文字を定義

        # システムログの個数を制御する変数を定義
        self.Total_LogCount = 20000  # システムログの最大保持数（概算）
        self.Max_LogCount_0 = 20000  # 現在のカウントの上限（一度最大保持数に到達したら self.Step_LogCount の値に変更）
        self.Max_LogCount_1 = 20000; self.Max_LogCount_2 = 20000; self.Max_LogCount_3 = 20000
        self.Max_LogCount_4 = 20000; self.Max_LogCount_5 = 20000
        self.Step_LogCount_0 = 10000; self.Step_LogCount_1 = 10000; self.Step_LogCount_2 = 10000; self.Step_LogCount_3 = 10000
        self.Step_LogCount_4 = 10000; self.Step_LogCount_5 = 10000

        for i in range(6):  # 0 から 5 までのイテレーション（ログテキストエリア六つ分、全てクラス（self）属性に設定）
            setattr(self, "LogCount_{0}".format(str(i)), 0)  # システムログの個数をカウントする変数を定義
            # ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数を定義
            setattr(self, "LogSegment_{0}".format(str(i)), "")
            setattr(self, "SeparatorCount_{0}".format(str(i)), 0)  # ログテキストの区切り線の個数を記録する変数を定義
            setattr(self, "SeparatorIndexes_{0}".format(str(i)), [])  # 各区切り線のインデックスを記録する変数（リスト）を定義
            # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに他のログが追加されないように制御するフラグを定義
            # （進捗率表示中に追加を試みられたログは変数 WaitingLog に保持）
            setattr(self, "LogTextIsProgressing_{0}".format(str(i)), False)
            setattr(self, "ProgressPercentage_{0}".format(str(i)), {})  # エンジンのスレッド毎の進捗率を記録する変数（辞書）を定義
            # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログを保持する変数を定義
            setattr(self, "WaitingLog_{0}".format(str(i)), "")
            # ロックメカニズム（QMutex）のインスタンスを定義
            # （将来、エンジン数 = バックグラウンドスレッド数でなくし、エンジンをマルチスレッド化する場合に備える）
            setattr(self, "QMutex_{0}".format(str(i)), QMutex())

        # 0 から 5 までのイテレーション（バックグラウンドスレッド六つ分）
        # （メインスレッドを識別する番号 0 は GUI 応答用のバックグラウンドスレッドを識別する番号でもある）
        for i in range(6):  # エンジンをマルチスレッド化する場合は range の設定値を変更する
            setattr(self, "ProcessLog_{0}".format(str(i)), "")  # 処理待ちのシステムログを記録する変数を定義
            setattr(self, "BackLog_{0}".format(str(i)), "")  # 非同期処理中のシステムログを記録する変数を定義（スレッド間通信用キュー）
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 複数のログ UI インスタンスを LogManagerClass に設定する関数
    def SetLogInstance(self, LogText_0, LogText_1, LogText_2, LogText_3, LogText_4, LogText_5):
        """ この部分を「関数の docstring」と言います。
        複数のログ UI インスタンスを LogManagerClass に設定する関数。

        この関数は、ログを表示するための複数の UI 要素（LogText_0 ～ LogText_5）のインスタンスを受け取り、それらをクラスの属性として設定します。これにより、
        複数のログカテゴリーに対応することが可能になります。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            LogText_0: ログカテゴリー 0 のログを表示するテキストウィジェット。
            LogText_1: ログカテゴリー 1 のログを表示するテキストウィジェット。
            LogText_2: ログカテゴリー 2 のログを表示するテキストウィジェット。
            LogText_3: ログカテゴリー 3 のログを表示するテキストウィジェット。
            LogText_4: ログカテゴリー 4 のログを表示するテキストウィジェット。
            LogText_5: ログカテゴリー 5 のログを表示するテキストウィジェット。

        Returns:
            なし。
        """
        self.LogText_0 = LogText_0; self.LogText_1 = LogText_1; self.LogText_2 = LogText_2  # 対応する番号のクラス（self）属性に代入
        self.LogText_3 = LogText_3; self.LogText_4 = LogText_4; self.LogText_5 = LogText_5
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # システムログの個数のカウントを行い、必要に応じて古いログを削除する関数
    def LogCount(self, CallNum):
        """ この部分を「関数の docstring」と言います。
        システムログの個数のカウントを行い、必要に応じて古いログを削除する関数。

        この関数は、引数 CallNum に応じて、対応するログカウント（self.LogCount_0 ～ self.LogCount_5）を加算して返します。ログカウントにはそれぞれ上限が
        設定されており、上限を超えた場合は CallNum に対応するシステムログを取得し、不要となった古いログを削除します。古いログの削除処理後、ログカウントを
        リセットします。これにより、各システムログの種類に応じたログの総量を適切に制限します。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            CallNum (int): ログの種類を表す整数値（0 ～ 5）。

        Returns:
            int: 指定されたログの現在のカウント値。

        Raises:
            ValueError: ログテキストに特定の区切り線が一つも存在しないにも関わらずログカウントが上限を超えている場合に発生。
        """
        # CallNum に対応する属性名の設定と対応するクラス（self）属性の取得
        LogCount_attr = "LogCount_{0}".format(str(CallNum))  # LogCount の属性名を設定
        Max_LogCount_attr = "Max_LogCount_{0}".format(str(CallNum))  # Max_LogCount の属性名を設定
        """ "attr" は attribute（属性）の略を指し、プログラミングの文脈において一般的に使われます。 """
        CurrentCount = getattr(self, LogCount_attr, None)  # LogCount 属性から LogCount（int）を取得
        Max_LogCount = getattr(self, Max_LogCount_attr, None)  # Max_LogCount 属性から Max_LogCount（int）を取得

        CurrentCount += 1  # 出力用ログカウントの加算

        if CurrentCount > Max_LogCount:  # ログカウントが上限（Max_LogCount）に到達し、現在の値が上限を超えている場合、古いログを削除する
            # ログテキストに特定の区切り線が存在する場合、区切り線のインデックスに増加分インデックスを加算して更新
            LogSeparationEnabled = self.LogSeparator(CallNum, SpecialCall = True)  # この関数用のパラメータ SpecialCall を True に設定
            if LogSeparationEnabled:  # ログテキストに特定の区切り線が存在する場合
                # CallNum に対応する属性名の設定と対応するクラス（self）属性の取得
                SeparatorCount_attr = "SeparatorCount_{0}".format(str(CallNum))  # SeparatorCount の属性名を設定
                SeparatorIndexes_attr = "SeparatorIndexes_{0}".format(str(CallNum))  # SeparatorIndexes の属性名を設定
                SeparatorCount = getattr(self, SeparatorCount_attr, None)  # SeparatorCount 属性から SeparatorCount（int）を取得
                SeparatorIndexes = getattr(self, SeparatorIndexes_attr, None)  # SeparatorIndexes 属性からリストの参照を取得

                # SeparatorCount（特定の区切り線の個数）が 2 以上の場合、その数を 2 で割り、整数を得る（ログテキストの約半分を削除するため）
                SeparatorCount = SeparatorCount // 2 if SeparatorCount >= 2 else SeparatorCount  # 2 未満の場合、何もしない
                setattr(self, SeparatorCount_attr, SeparatorCount)  # 変更された（または変更されていない）値を保存
                """
このアプリケーションでは、ログテキストエリアに直接挿入する区切り線を「特定の区切り線」と呼称します。この特定の区切り線は頻繁に挿入する仕様となっているため、
特定の区切り線の個数が 2 未満の状態でこのコード部分が実行されることは想定していません。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """

            # SeparatorCount（特定の区切り線の個数、以下「区切り線」）が SeparatorIndexes のインデックス範囲内か確認
            # ここでは両者の値が等価な場合もインデックス範囲内として扱う（等価となる条件が「区切り線が一つしか存在しない」しか存在せず、予期できるため）
            # 区切り線が一つも挿入されずにこのブロックが実行されることはこのアプリケーションの仕様上想定されない
            if LogSeparationEnabled and len(SeparatorIndexes) >= SeparatorCount:
                # 「SeparatorCount 個目に対応する区切り線」のログテキスト全体におけるインデックスを取得
                SeparatorIndex = SeparatorIndexes[SeparatorCount] if len(SeparatorIndexes) > 1 \
                    else SeparatorIndexes[SeparatorCount - 1]  # こちらの else 節が適用される場合、指定されるインデックスは必ず 0 となる
                """
このアプリケーションの仕様上、想定されるのは三項演算子の左辺（SeparatorIndexes[SeparatorCount] if len(SeparatorIndexes) > 1）の適用です。左辺では
len(SeparatorIndexes) > 1 によって、区切り線のインデックスのリストの範囲長（要素数）が 2 以上であることを確認した上で SeparatorIndexes[SeparatorCount]
によってログテキスト内の中央付近（先に 2 で除算した SeparatorCount の値）に存在する区切り線のインデックスを取得しています。予期せず左辺の実行条件が満たされず
右辺が実行される場合、ログテキストには区切り線が一つしか存在しないことになり、SeparatorCount は先の 2 で除算するコードブロックで除算されず、元の値
（SeparatorIndexes の要素数と等価）を保持していることになります。この場合、リストのインデックスは 0 からカウントされるという Python のゼロベースインデックス
の規則により、SeparatorIndexes の要素数が 1 である状況（区切り線が一つしか存在しない）、即ち SeparatorCount が 1 である状況では、SeparatorCount をその
まま使用すると SeparatorIndexes リストの範囲外を指定することになってしまいます。この問題を解消するため、右辺では SeparatorIndexes[SeparatorCount - 1]
によって、SeparatorCount から 1 を引いた数、即ち 0 をインデックスとして正しく指定しています。このコードブロックでは「if LogSeparationEnabled and ...」
によって区切り線が少なくとも一つ以上存在することを確認しているため、これ以外の状況を考慮する必要はありません。ログテキストに区切り線が一つも存在しないにも関わら
ず、このコードブロックを内包する親ブロックの実行条件「if CurrentCount > Max_LogCount:」が True と評価される場合、それはアプリケーションが異常な状況に陥って
いることを示唆します。そのような状況のハンドリングはこの関数の責務の範囲を超えるため、この関数内ではそのような状況に遭遇した場合、raise ステートメントによって
例外（エラー）を発生させ、処理を終了及び異常な状況を終了させます。この例外はこの関数の呼び出し元で適切にハンドリングされ、異常な状況の発生元であるプロセスを終了
したことがユーザーに通知されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """

                LogText_attr = "LogText_{0}".format(str(CallNum))  # CallNum に対応するログテキストエリア（QTextEdit）の属性名を設定
                LogText_val = getattr(self, LogText_attr, None).toPlainText()  # クラス（self）属性の対応する属性からログテキストを取得
                LogLines = LogText_val.split(self.LF)  # ログテキストを改行で分割してリストを取得

                # 指定インデックス（SeparatorIndex）「未満」のログを取得（新しいログがログテキストエリアの最上部に挿入されるため）
                New_LogText = self.LF.join(LogLines[:SeparatorIndex + 1])  # SeparatorIndex に対応する区切り線を維持するためのスライス
                # 指定インデックス（SeparatorIndex）「未満」のログをログテキストエリア（QTextEdit）に再挿入
                getattr(self, LogText_attr, None).setPlainText(New_LogText)
                """
このアプリケーションはシステムログの可読性向上のために「新しいログをログテキストエリアの最上部に挿入する」という仕様になっているため、ログテキストにおける
インデックスの若いログが、より新しいログとなります。このため、先に取得した SeparatorIndex の値「未満」をログテキストから抽出し、ログテキストエリア
（QTextEdit）に再挿入することで、古いログの削除を実現しています。このとき、ログテキストの視覚的な分離を再現するために、SeparatorIndex に対応する区切り線を維持
するスライス LogLines[:SeparatorIndex + 1] を使用しています。ログテキストエリア（QTextEdit）に挿入されなかった古いログは、この関数の実行終了時にメモリ上
からパージされます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """

                if len(SeparatorIndexes) > 1:  # 区切り線が二つ以上存在する場合
                    # 削除した（New_LogText に含まれない）ログに含まれている区切り線の情報を SeparatorIndexes から削除
                    del SeparatorIndexes[:SeparatorCount]  # 維持している SeparatorIndex の情報は維持（それ未満を削除）
                else:  # 区切り線が一つしか存在しない場合
                    # 維持している SeparatorIndex の情報は維持するため、削除した（New_LogText に含まれない）ログには区切り線が存在しない
                    # （：削除した区切り線がないため、削除するべき区切り線の情報も存在しないので、ここでは何も行わない）
                    pass

                # 削除した（New_LogText に含まれない）ログに含まれている区切り線の情報を基に SeparatorIndexes のインデックス情報を再計算
                # 本来なら再計算するべきだが、このアプリケーションでは新しいログがテキストの上部に挿入されるため、古いログはテキストの下部にあり、
                # 下部のログを削除しても残ったログ（上部）のインデックスは変わらないため、再計算は不要
            else:  # ログテキストに区切り線が一つも存在しないにも関わらずログカウントが上限を超えている場合、例外を発生させる
                raise ValueError("{0}. ロガー：システムログの異常な増加を検知しました。状況を終了するプロセスに移行します。".format(
                    str(CurrentCount)))

            # ログカウントをリセットし（都度）、上限を変更（初回のみ）
            CurrentCount = 1  # ログカウントをリセット（出力用ログカウント）
            if Max_LogCount == self.Total_LogCount:  # ログカウントの上限が初期値の場合
                # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性から Step_LogCount を取得
                Step_LogCount = getattr(self, "Step_LogCount_{0}".format(str(CallNum)), None)
                Max_LogCount = Step_LogCount  # Step_LogCount を新たな上限として設定
                setattr(self, Max_LogCount_attr, Max_LogCount)  # 変更された上限をクラス（self）属性として保存
            """
古いログを削除するロジックでは、区切り線の個数と位置を基にログテキストの「約半分」を削除します。ここで上限を変更しない場合、古いログを削除しても時間経過と共に
システムログが蓄積され続けることになります（上限の初期値が 20000 で変更しない場合、約半分を削除してから次に上限に到達するとき、システムログの総数は約 30000 個と
なります）。これは、このアプリケーションが 24 時間 365 日稼働し続ける想定であることを考慮すると、メモリのパフォーマンスに影響を及ぼす問題です。この問題を解決する
方法として、ログカウントが最初に上限に到達したときに、上限を適切な値に変更することは有効な解決策の一つです。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

        setattr(self, LogCount_attr, CurrentCount)  # ログカウントをクラス（self）属性として保存
        return CurrentCount  # 最新のログカウントを返す

    # 指定されたログテキストエリアに新しいシステムログを挿入する関数
    def InsertLOG(self, Log, CallNum, Debug = False):
        """ この部分を「関数の docstring」と言います。
        指定されたログテキストエリアに新しいシステムログを挿入する関数。

        この関数は、引数 CallNum に基づいて対応するログテキストエリアを特定し、新しいシステムログを挿入します。ログはログカウント番号と共に最上部に挿入し、
        ログカウントは関数 self.LogCount() によって更新されたものを使用します。この関数は、将来、エンジン数 = バックグラウンドスレッド数でなくし、エンジンを
        マルチスレッド化する場合に備えるため、CallNum に紐づくクラス属性へのアクセスをロックしてから処理を行うよう設計されています。ただし、引数 Debug が
        True で呼び出された場合、呼び出し元（LogManagerClass 内）で何らかの問題が生じ（予期しない形式のログの検出、エラーの発生など）、既にログエントリとして
        整形済みのログまたはエラーメッセージを、呼び出し元で取得されているロックのコンテキストで記録することを目的として呼び出されたと判断し、ロックの取得及び
        ログカウント番号の付与を行わずに（整形済みのログエントリである可能性がある場合、既に付与されているログカウント番号も重要な情報であるため）ログ記録処理を
        実行します。これにより、クラス内の他のログ管理関数内で何らかの問題が生じた場合にも柔軟なログ記録ソリューションを提供します。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Log (str): 挿入するログの内容。
            CallNum (int): ログを挿入するログテキストエリアを識別する整数値（0 ～ 5）。
            Debug (bool, optional):
                LogManagerClass 内の他のログ管理関数で問題が生じたことを示すフラグ。デフォルトは False。
                このフラグを True に設定する場合、呼び出し元で適切なロックの取得処理が行われていることが前提。

        Returns:
            なし。
        """
        # 補助関数：関数 self.InsertLOG() の処理のコア部分
        def Core_ofInsertLOG():
            """ この部分を「関数の docstring」と言います。
            関数 self.InsertLOG() の処理のコア部分を担う関数。

            この関数は、関数 self.InsertLOG() の担うべき処理のコア部分をカプセル化したものです。この関数の呼び出し元では、呼び出し元の引数 Debug の値に
            応じて、適切にロックメカニズムの使用・不使用が行われている必要があります。コア部分なので引数は取らず、エンクロージングスコープの属性はクロージャに
            よって参照します。

            Parameters:
                なし。

            Returns:
                なし。
            """
            AppendLog = False  # 変数を初期化
            # CallNum に対応する属性名を設定及びクラス（self）属性からフラグ属性の値を取得
            LogTextIsProgressing = getattr(self, "LogTextIsProgressing_{0}".format(str(CallNum)), None)
            if not LogTextIsProgressing:  # ログテキストエリアが進捗率表示を行っていない場合、ログエントリをログテキストエリア（QTextEdit）に反映
                # CallNum に対応する属性名を設定及びクラス（self）属性のログテキストエリア（QTextEdit）の属性から参照を取得
                LogText = getattr(self, "LogText_{0}".format(str(CallNum)), None)
                LogText.moveCursor(QTextCursor.Start)  # ログテキストエリア（QTextEdit）の先頭にカーソルを移動
                LogText.insertPlainText(NewLog)  # 新しいログエントリの挿入
                AppendLog = True  # 新しいログエントリをログテキストエリア（QTextEdit）に反映したことを示すフラグを有効化
            else:  # ログテキストエリアが進捗率表示を行っている場合、ログエントリを WaitingLog に追加
                # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログを保持する変数に新しいログエントリを追加
                # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性から WaitingLog を取得
                WaitingLog = getattr(self, "WaitingLog_{0}".format(str(CallNum)), None)
                WaitingLog = NewLog + WaitingLog  # 新しいログエントリの追加（新しいものを先頭に追加）
                setattr(self, "WaitingLog_{0}".format(str(CallNum)), WaitingLog)  # 更新された WaitingLog を元の属性に保存
            """
この関数では、LogText.moveCursor(QTextCursor.Start) と WaitingLog = NewLog + WaitingLog の行で「新しいログをログテキストエリアの最上部に挿入する」
という、このアプリケーションの仕様を具体的に実装しています。また、新しいログはログテキストエリア（QTextEdit）が進捗率表示を行っているか否かに基づいて、ログ
テキストエリア（QTextEdit）に直接反映させるか、または WaitingLog に反映させるかが判断されます。進捗率表示を行っている場合に新しいログを直接ログテキストエリア
（QTextEdit）に反映させないのは、反映させるとシステムログの可読性が低下するためです。このような状況は、進捗率表示を伴う処理を行っているスレッドとは別のスレッドが
同じログテキストエリア（QTextEdit）に新しいログの追加を試みる場合に発生します。この状況はマルチスレッド化されたエンジンなどによりもたらされますが、一つのログ
テキストエリア（QTextEdit）に同時に（リアルタイムに）異なるコンテキストのログを表示することはシステムログの連続性を損なうことに繋がり、これはユーザーの混乱を
招き、システムログの理解を困難にします。WaitingLog はこの問題を解決するために、進捗率表示を伴う処理を行っているスレッドとは別のスレッドが同時に動作している状況
で、そのスレッドのログの連続性を維持しつつ、ログテキストエリア（QTextEdit）が進捗率表示を終えるまでそのスレッドのログを保持します。この対応で制御するのは､「ログ
テキストエリア（QTextEdit）が進捗率表示を行っている場合の、別のスレッドの進捗率表示を伴わないログ出力」です。複数のスレッドが同時に進捗率表示を行う場合について
は、関数 self.InsertBackLOG() が対応します。WaitingLog に蓄積されるログの取り出しは、関数 self.InsertBackLOG() が行います。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

            # ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数に新しいログエントリを追加
            if AppendLog:  # 新しいログエントリがログテキストエリア（QTextEdit）に反映された場合
                self.UpdateLogSegment(NewLog, CallNum)

        """ self.InsertLOG() の記述 """
        if not Debug:  # デバッグモードでない場合
            # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性からロックメカニズムのインスタンスを取得
            QMutex = getattr(self, "QMutex_{0}".format(str(CallNum)), None)
            with QMutexLocker(QMutex):  # ロックを取得（ブロックを抜けるまで CallNum に紐づくクラス（self）属性へのアクセスはロックされる）
                try:  # エラーを検出するブロック
                    NewLog = "{0}. {1}{2}".format(str(self.LogCount(CallNum)), str(Log), self.LF)  # 新しいログエントリの作成
                except ValueError as e:  # ValueError が発生した場合
                    NewLog = str(e)  # エラー内容を新しいログエントリとする

                Core_ofInsertLOG()  # ログエントリを補助関数で処理
        else:  # デバッグモードの場合（この関数の呼び出し元で取得されているロックのコンテキストで動作することが前提）
            NewLog = Log  # 既にログとして整形済みのログエントリを使用
            Core_ofInsertLOG()  # ログエントリを補助関数で処理
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 新しいシステムログを対応する処理待ちのログ（ProcessLog）に記録する関数
    def RecordLOG(self, Log, CallNum, backlog = False):
        """ この部分を「関数の docstring」と言います。
        新しいシステムログを対応する処理待ちのログ（ProcessLog）に記録する関数。

        この関数は、新しいログエントリを作成し、引数 CallNum に基づいて対応する処理待ちのログ（ProcessLog）に記録します。新しいログエントリは、ログカウント
        番号と渡されたログメッセージから構成し、ProcessLog の最上部に挿入します。渡されたログメッセージがバックログ（バックグラウンドスレッドのログ）のもので
        ある場合は、バックログであることを示す「/ 」を行頭に追加します。この関数は、将来、エンジン数 = バックグラウンドスレッド数でなくし、エンジンを
        マルチスレッド化する場合に備えるため、CallNum に紐づくクラス属性へのアクセスをロックしてから処理を行うよう設計されています。そのため、内部で CallNum
        をエンジン番号に変換します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Log (str): 記録するログの内容。
            CallNum (int):
                ログを記録する処理待ちのログ（ProcessLog）を識別する整数値。
                引数名は CallNum（これは 0 〜 5）となっているが、ThreadID（6 以上の整数値を含む）を扱うこともある。
            backlog (bool, optional): バックログ（バックグラウンドスレッドのログ）の場合は True、そうでない場合は False（デフォルト）。

        Returns:
            なし。
        """
        EngineNum = IntegrationOfThreadIDtoEngineNum(CallNum) if CallNum > 5 else CallNum  # 必要に応じて CallNum をエンジン番号に変換
        # EngineNum に対応する属性名を設定及びクラス（self）属性の対応する属性からロックメカニズムのインスタンスを取得
        QMutex = getattr(self, "QMutex_{0}".format(str(EngineNum)), None)
        with QMutexLocker(QMutex):  # ロックを取得（ブロックを抜けるまで CallNum に紐づくクラス（self）属性へのアクセスはロックされる）
            try:  # エラーを検出するブロック
                # 新しいログエントリの作成（EngineNum に基づきログ番号を付与）と ProcessLog への追加
                NewLog = "{0}. {1}{2}".format(str(self.LogCount(EngineNum)), str(Log), self.LF)
                NewLog = "/ " + NewLog if backlog else NewLog  # バックログの場合、新しいログエントリの行頭に "/ " を追加
                # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性から ProcessLog を取得
                ProcessLog = getattr(self, "ProcessLog_{0}".format(str(CallNum)), None)
                ProcessLog = NewLog + ProcessLog  # 新しいログエントリの追加（新しいものを先頭に追加）
                setattr(self, "ProcessLog_{0}".format(str(CallNum)), ProcessLog)  # 更新された ProcessLog を元の属性に保存
                """
この関数では、ProcessLog = NewLog + ProcessLog の行で「新しいログをログテキストエリアの最上部に挿入する」という
このアプリケーションの仕様を具体的に実装しています。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """
            except ValueError as e:  # ValueError が発生した場合
                self.InsertLOG(str(e), EngineNum, Debug = True)  # エラー内容をデバッグモードで GUI に反映または後続の処理で反映

    # 非同期処理中（バックグラウンド処理中）のシステムログを対応するバックログ（バックグラウンドスレッドのログ）属性に記録する関数
    def RecordBackLOG(self, Log, ThreadID):
        """ この部分を「関数の docstring」と言います。
        非同期処理中（バックグラウンド処理中）のシステムログを対応するバックログ（バックグラウンドスレッドのログ）属性に記録する関数。

        この関数は、新しいログエントリを作成し、引数 ThreadID に基づいて対応するバックログ属性に記録します。バックログ属性は、システムログにおけるスレッド間
        通信用キューとして機能します。新しいログエントリは、ログカウント番号と渡されたログメッセージから構成し、バックログ属性の最上部に挿入します。この関数は、
        将来、エンジン数 = バックグラウンドスレッド数でなくし、エンジンをマルチスレッド化する場合に備えるため、ThreadID に紐づくクラス属性へのアクセスをロック
        してから処理を行うよう設計されています。そのため、内部で ThreadID をエンジン番号に変換します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Log (str): 記録するログの内容。
            ThreadID (int): ログを記録するバックログ属性を識別するための、バックグラウンドスレッドを識別する整数値（0 〜 5 に加えて 6 以上も含む）。

        Returns:
            なし。
        """
        EngineNum = IntegrationOfThreadIDtoEngineNum(ThreadID) if ThreadID > 5 else ThreadID  # 必要に応じて ThreadID をエンジン番号に変換
        # EngineNum に対応する属性名を設定及びクラス（self）属性の対応する属性からロックメカニズムのインスタンスを取得
        QMutex = getattr(self, "QMutex_{0}".format(str(EngineNum)), None)
        with QMutexLocker(QMutex):  # ロックを取得（ブロックを抜けるまで ThreadID に紐づくクラス（self）属性へのアクセスはロックされる）
            try:  # エラーを検出するブロック
                # 新しいログエントリの作成（EngineNum に基づきログ番号を付与）と BackLog への追加
                NewLog = "/ {0}. {1}{2}".format(str(self.LogCount(EngineNum)), str(Log), self.LF)
                # ThreadID に対応する属性名を設定及びクラス（self）属性の対応する属性から BackLog を取得
                BackLog = getattr(self, "BackLog_{0}".format(str(ThreadID)), None)
                BackLog = NewLog + BackLog  # 新しいログエントリの追加（新しいものを先頭に追加）
                setattr(self, "BackLog_{0}".format(str(ThreadID)), BackLog)  # 更新された BackLog を元の属性に保存
                """
この関数では、BackLog = NewLog + BackLog の行で「新しいログをログテキストエリアの最上部に挿入する」というこのアプリケーションの仕様を具体的に実装しています。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """
            except ValueError as e:  # ValueError が発生した場合
                self.InsertLOG(str(e), EngineNum, Debug = True)  # エラー内容をデバッグモードで GUI に反映または後続の処理で反映

    # 非同期処理中（バックグラウンド処理中）に蓄積されたバックログ（バックグラウンドスレッドのログ）を対応するログテキストエリアに挿入する関数
    @pyqtSlot(int, bool, bool)  # シグナルに対するスロットであることを示すデコレータ
    def InsertBackLOG(self, ThreadID, LongProcess = False, Completed = False):
        """ この部分を「関数の docstring」と言います。
        非同期処理中（バックグラウンド処理中）に蓄積されたバックログ（バックグラウンドスレッドのログ）を対応するログテキストエリアに挿入する関数。

        この関数は、引数 ThreadID に基づいて対応するバックログ属性とログテキストエリアを特定し、蓄積されたバックログをログテキストエリアに挿入します。挿入後、
        当該バックログ属性をクリアします。バックログ属性は、メインスレッドから切り離されたバックグラウンドスレッドでのシステムログを保持するスレッド間通信用
        キューとして機能します。引数 LongProcess が True の場合、バックグラウンドスレッドで長時間に渡り行われている処理が存在するために呼び出されたと判断し、
        バックログに進捗率ログが存在する前提で、バックログ属性に蓄積されたシステムログをログテキストエリアに挿入します。その際「進捗率の表示中に同じログ
        テキストエリアに他のログが追加されないように制御するためのフラグ」を有効化します。その後、LongProcess が True で呼び出される度にバックログ属性から
        更新された進捗率ログを取り出し、ログテキストエリアに表示中の既存の進捗率ログと置換します。一度 LongProcess が True でこの関数が呼び出されるとこの
        モードになる可能性があるため、引数 LongProcess の取り扱いには注意が必要です。このモード「ログテキストエリアに進捗率を表示中」に「同じログテキストエリア
        に追加を試みられたログ」は「ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログを保持する変数」に保存します。ログの追加先を
        変更するこの挙動は、LogManagerClass の「ログテキストエリアを操作する関数」全てに及びます。このモードは「エンジンの全てのスレッドが進捗率報告を伴う処理
        を行っていないことが確認された場合（この関数内で確認）」に解除し、解除と共に「ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試み
        られたログ」をログテキストエリアに挿入します。進捗率ログの表示と他のログとの整合性を保つためには、引数 LongProcess と Completed を、バックグラウンド
        処理ハンドラが適切に一貫して取り扱うことが重要です。この関数は、将来、エンジン数 = バックグラウンドスレッド数でなくし、エンジンをマルチスレッド化する場合
        に備えるため、ThreadID に紐づくクラス属性へのアクセスをロックしてから処理を行うよう設計されています。そのため、内部で ThreadID をエンジン番号に変換
        します。また、関数の実装はその場合に備えたものになっており、仮にエンジンがマルチスレッド化した場合でも、この関数は呼び出し時の引数 LongProcess と
        Completed の値とは別に、エンジンの全てのスレッドの進捗状態もチェックし、ログテキストエリアが適切な状態に保たれるように動作します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            ThreadID (int):
                ログを挿入するテキストエリアとバックログ属性を識別するための、バックグラウンドスレッドを識別する整数値（0 〜 5 に加えて 6 以上も含む）。
            LongProcess (bool, optional): 非同期で行われている処理が長引いているために呼び出されたことを示すフラグ。デフォルトは False。
            Completed (bool, optional): 非同期で行われていた処理が完了したことを示すフラグ。デフォルトは False。

        Returns:
            なし。
        """
        # 補助関数：改行を含まない単一行のログエントリで既存のログエントリを更新
        def UpdateLogEntry(LogCount):
            """ この部分を「関数の docstring」と言います。
            改行を含まない単一行のログエントリで既存のログエントリを更新する関数。

            この関数は、進捗率ログなどの「同一のログカウント番号で、時間経過と共に変化するログ」を、前回出力された同ログエントリと置換します。置換の際には事前に
            用意されたログカウント番号を用いて既存の（GUI 上の）システムログを検索し、対象行を見つけた場合にその行を新しいログエントリで置換します。この置換は、
            処理後、即座に GUI に反映されます。検索に使用する文字列が明確で、システムログなどのように検索対象のフォーマットも一貫していて、かつ置換したい行が
            単一行の場合に、この関数のアプローチは極めて効率的です。また検索はテキストの上部から開始することと、このアプリケーションの「新しいログエントリが
            最上部に挿入される仕様」の相乗効果により、システムログが膨大な場合でも、検索を迅速に完了することが可能となっています。この結果、システムが作成する
            ログエントリの数が増加しても、GUI への最新情報の反映は遅延することなく、リアルタイム性の維持を実現しています。この効率性は、システムログの管理に
            おいて、リアルタイムでの更新が求められる環境下で特に重要となります。ログエントリを継続的に更新する必要がある場合、それぞれの更新を迅速に処理すること
            で、ユーザーに対して最新の情報を継続的に提供することが可能です。

            Parameters:
                LogCount (str): 置換を行うログエントリのフォーマットされたログカウント番号。

            Returns:
                bool: 動的なログエントリをログテキストエリアに反映したかどうかを示すフラグ。反映した場合、True。そうでなければ False。
            """
            LogDocument = LogText.document()  # ログテキストエリア（QTextEdit）の QTextDocument を取得
            SearchCursor = LogDocument.find(LogCount)  # LogCount で LogDocument を検索し、対応するログエントリを探す
            if not SearchCursor.isNull():  # 対応するログエントリが見つかった場合
                SearchCursor.select(QTextCursor.LineUnderCursor)  # ログエントリの行全体（改行含まず）を選択
                SearchCursor.removeSelectedText()  # 選択したログエントリ（改行含まず）を削除
                SearchCursor.insertText(BackLog)  # 新しいログエントリを挿入
                return True  # 動的なログエントリをログテキストエリア（QTextEdit）に反映したことを示すフラグを返す
            return False  # 動的なログエントリをログテキストエリア（QTextEdit）に反映できなかったことを示すフラグを返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：AccumulatedLogLines の状態に合わせて TargetLog を更新
        def UpdateTargetLog(AccumulatedLogLines, TargetLog):
            """ この部分を「関数の docstring」と言います。
            AccumulatedLogLines の状態に合わせて TargetLog を更新する関数。

            この関数は、進捗報告や異常発生時など、システムの状態変化をログとして記録するために使用されます。特に、引数 AccumulatedLogLines（最新のログ情報）
            を基にして、GUI に表示中のログ（引数 TargetLog）を更新するという重要な責務を担っています。AccumulatedLogLines の最終行に特定の形式で記録され
            た進捗率ログ（例：「/ 125. 20%：>>>>________________」）がある場合、この行は特定の処理の進捗状況を表しています。この関数は、
            AccumulatedLogLines の末尾に改行がない、つまり最新の進捗率ログを保持しているコンテキストで呼び出されることを前提とし、その進捗率ログを用いて引数
            TargetLog を更新します。更新プロセスでは、まず AccumulatedLogLines の最終行から進捗率ログの識別子（ProgressLogCount）を抽出します。次に、
            この識別子を基に TargetLog 内を検索し、同じ識別子を持つ進捗率ログを探します。このとき、一致判定では識別子の一致に加えて、進捗率ログの形式「%：」を
            含むかどうかも評価します。一致する行が見つかった場合、その行を AccumulatedLogLines の内容全体で置換し、進捗の最新の状態を反映します。これにより、
            ユーザーに対して処理の進捗や状態変化をリアルタイムに反映したログ情報を提供することが可能になります。AccumulatedLogLines と TargetLog の扱いに
            おいて、特にログデータの規模が大きい場合や、ログ更新処理が頻繁に発生する環境では、パフォーマンスに懸念が生じる可能性があります。しかし、この
            アプリケーションではログ一行あたりの文字数がごく小規模に制限されていることが、その懸念を緩和します。またこのアプリケーションの「新しいログエントリが
            最上部に挿入される仕様」により、置換対象行の検索に要するイテレート回数が非常に少なく抑えられることも、パフォーマンスへの懸念を大幅に緩和することに
            寄与します。イテレート回数が少なく抑えられるということは、関数の実行に要する時間を短縮することに直結するためです。この設計により、大規模なログデータ
            を扱う場合でも、システムのパフォーマンスを維持しつつ、効率的なログ更新を可能としています。AccumulatedLogLines が複数行に渡る場合、最終行の進捗率
            ログに加えて、それらの新しいログ情報も同時に TargetLog に挿入します。これにより、ユーザーに対して進捗情報以外の関連するイベントや状況の詳細な記録
            も同時に提供し、より包括的な情報共有を可能としています。この関数の機能は、システムの運用中に発生する様々なイベント（進捗報告以外の情報を含む）を、
            時間の経過と共に記録及び提供することを可能とします。

            Parameters:
                AccumulatedLogLines (list): 更新処理の基準となる、蓄積されたログを改行で分割したリスト。進捗率ログまたは通常のシステムログを含む。
                TargetLog (str): 更新する対象となるログの内容。

            Returns:
                tuple of bool, str: 二つの要素からなるタプル。
                    - bool or None: 処理が成功し、TargetLog が更新された場合、True。そうでなければ False。または予期しない状況で None。
                    - str or None: 更新された TargetLog の内容。更新が行われなかった場合、元の TargetLog。または予期しない状況で None。
            """
            if ". " in AccumulatedLogLines[-1]:  # AccumulatedLogLines 最終行の形式確認
                TargetLogLines = TargetLog.split(self.LF)  # TargetLog を改行で分割してリストを取得
                # AccumulatedLogLines 最終行から ProgressLogCount（取り出されなかった進捗率ログのログカウント）を取り出す
                ProgressLogCount = AccumulatedLogLines[-1].split(". ")[0] + ". "  # split() で除去された記号を再付与
                for Index, Line in enumerate(TargetLogLines):  # TargetLogLines 内の各行を検索するイテレーションを開始
                    # ProgressLogCount で始まり、その後に特定のパーセンテージ表記がある TargetLogLines の行（Line）を検索
                    if Line.startswith(ProgressLogCount) and "%：" in Line:
                        AccumulatedLog = self.LF.join(AccumulatedLogLines)  # 該当行を AccumulatedLogLines 全体で置換するため改行で結合
                        TargetLogLines[Index] = AccumulatedLog  # 該当行を AccumulatedLog で置換（代入）
                        # TargetLog を更新したことを示すフラグ、及び更新された TargetLogLines を改行で結合した文字列（str）を返す
                        return True, self.LF.join(TargetLogLines)
                    elif Index >= 5000:  # 対象行が見つからない場合のイテレート回数の上限設定
                        return False, TargetLog  # TargetLog を更新できなかったことを示すフラグ、及び元の TargetLog を返す
                else:  # 対象行が見つからないままイテレート回数の上限に達することなくイテレーションが終了した場合
                    return False, TargetLog  # TargetLog を更新できなかったことを示すフラグ、及び元の TargetLog を返す
            else:  # AccumulatedLogLines 最終行が予期された形式でない場合
                for Log in reversed(AccumulatedLogLines):  # 記録されているログを記録された順に取り出すイテレーションを開始
                    self.InsertLOG(Log, EngineNum, Debug = True)  # 取り出したログを再記録（即座に GUI に反映されるか、後続の処理で反映）
                return None, None  # TargetLog を更新できなかった、かつ予期しない状況が発生したことを示すフラグと値を返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：エラーハンドリング用のログカウントを取得
        def GetLogCountAndHandleErrors(EngineNum):
            """ この部分を「関数の docstring」と言います。
            エラーハンドリング用のログカウントを取得する関数。

            この関数は、呼び出し元のコンテキストでエラーメッセージに添付するログカウントを取得し、文字列型（str）として返します。関数はログカウントの取得時に
            行うべきエラーハンドリングを行います。

            Parameters:
                EngineNum (int): ログを挿入するログテキストエリアを識別する整数値（0 ～ 5）。クラス内の別関数で使用される引数 CallNum と対応。

            Returns:
                str: 取得し、文字列型に変換したログカウント。
            """
            try:  # エラーを検出するブロック
                return str(self.LogCount(EngineNum))  # ログカウントを取得し、文字列型（str）に変換して返す
            except ValueError as e:  # ValueError が発生した場合
                self.InsertLOG(str(e), EngineNum, Debug = True)  # エラー内容をデバッグモードで GUI に反映または後続の処理で反映
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：ログテキストエリアのシステムログを更新
        def ReplaceLogText():
            """ この部分を「関数の docstring」と言います。
            ログテキストエリアのシステムログを更新する関数。

            この関数は、バックログ（バックグラウンドスレッドのログ）の状態を基に、ログテキストエリアの内容を適切に更新する責務を担います。特に GUI における
            リアルタイムの進捗率表示やシステム状態のログ更新において重要な役割を果たします。この関数の機能は呼び出し元の関数 InsertBackLOG() でのみ必要となる
            ため、エンクロージングスコープの属性はクロージャによって参照します。バックログの内容が単一行（一般に進捗率ログを想定）の場合、その行のログカウント
            番号に基づいて、ログテキストエリア内の既存のログエントリを新しいログエントリで更新します。この処理は補助関数 UpdateLogEntry() を通じて実行します。
            一方で、バックログが複数行からなる場合は、補助関数 UpdateTargetLog() を通じてログテキストエリア全体の内容を更新します。この際、最新のログ情報を
            含む複数行のバックログをログテキストエリアの正確な位置に反映します。関数の主な責務は、ログテキストエリアの内容を最新の状態に保つことであり、その過程
            で発生する可能性のある如何なるエラーにも適切に対応します。エラーが発生した場合、詳細なエラーメッセージを作成し、その内容をシステムログに記録するため
            に関数 self.InsertLOG() をデバッグモードで呼び出します。このエラーハンドリングは、アプリケーションの安定性と信頼性を向上させるために不可欠です。

            Parameters:
                なし。

            Returns:
                bool: BackLog をログテキストエリアに反映したかどうかを示すフラグ。反映した場合、True。そうでなければ False。
            """
            BackLogLines = BackLog.split(self.LF)  # BackLog を改行で分割してリストを取得
            if len(BackLogLines) == 1:  # BackLog の内容が一行（進捗率ログ）の場合
                AppendBackLog = UpdateLogEntry(ProgressLogCount)  # ProgressLogCount を用いて補助関数で処理
                if not AppendBackLog:  # BackLog を正しくログテキストエリア（QTextEdit）に反映できなかった場合
                    Log = ("{0}. ロガー：予期せず既存の進捗率ログと新しい進捗率ログのログカウント番号が一致せず、進捗率ログの更新が行えません。"
                        "内部エラーのため、開発者に連絡してください。エンジン番号：{1}、スレッド ID：{2}").format(
                            GetLogCountAndHandleErrors(EngineNum), str(EngineNum), str(ThreadID))
                    self.InsertLOG(Log, EngineNum, Debug = True)  # エラー内容をデバッグモードで GUI に反映または後続の処理で反映
            elif len(BackLogLines) > 1:  # BackLog の内容が複数行の場合
                LogText_val = LogText.toPlainText()  # ログテキストエリア（QTextEdit）からログテキストを取得
                AppendBackLog, LogText_val = UpdateTargetLog(BackLogLines, LogText_val)  # BackLogLines とログテキストを補助関数で処理
                """
ここでは、関数が複数の要素を含むタプルを返すと分かっているため、関数の返り値を代入する先をあらかじめタプルが含む要素の数だけ用意しておきます。このようにすること
で、関数が返す複数の要素を含むタプルを自動的にアンパックすることができ、タプルの要素はそれぞれタプル内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """
                if AppendBackLog and LogText_val:  # 補助関数での処理が正常に完了したことを確認
                    LogText.setPlainText(LogText_val)  # 処理されたログテキストをログテキストエリア（QTextEdit）に再挿入
                elif not AppendBackLog and LogText_val:  # BackLog を正しくログテキストエリア（QTextEdit）に反映できなかった場合
                    Log = ("{0}. ロガー：予期せず既存の進捗率ログと新しい進捗率ログのログカウント番号または形式が一致せず、進捗率ログの更新が行えません。"
                        "内部エラーのため、開発者に連絡してください。エンジン番号：{1}、スレッド ID：{2}").format(
                            GetLogCountAndHandleErrors(EngineNum), str(EngineNum), str(ThreadID))
                    self.InsertLOG(Log, EngineNum, Debug = True)  # エラー内容をデバッグモードで GUI に反映または後続の処理で反映
                elif not AppendBackLog and LogText_val is None:  # BackLog を正しくログテキストエリア（QTextEdit）に反映できなかった場合
                    Log = ("{0}. ロガー：予期されない形式のログが検出されました。予期しないエラーが発生している可能性があります。内部エラーのため、開発者に"
                        "連絡してください。エンジン番号：{1}、スレッド ID：{2}").format(
                            GetLogCountAndHandleErrors(EngineNum), str(EngineNum), str(ThreadID))
                    self.InsertLOG(Log, EngineNum, Debug = True)  # エラー内容をデバッグモードで GUI に反映または後続の処理で反映
            return AppendBackLog  # BackLog をログテキストエリア（QTextEdit）に反映したかどうかを示すフラグを返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        """ self.InsertBackLOG() の記述 """
        EngineNum = IntegrationOfThreadIDtoEngineNum(ThreadID) if ThreadID > 5 else ThreadID  # 必要に応じて ThreadID をエンジン番号に変換
        # EngineNum に対応する属性名を設定及びクラス（self）属性の対応する属性からロックメカニズムのインスタンスを取得
        QMutex = getattr(self, "QMutex_{0}".format(str(EngineNum)), None)
        with QMutexLocker(QMutex):  # ロックを取得（ブロックを抜けるまで ThreadID に紐づくクラス（self）属性へのアクセスはロックされる）
            # 変数を初期化
            AppendBackLog = False  # BackLog をログテキストエリア（QTextEdit）に反映したかどうかを示すフラグ変数
            FirstProgressReport = False  # 関数 self.RecordProgress() が保存した FirstReport の値を保持する変数
            LogTextWasProgressing = False  # エンジンの全てのスレッドの進捗率が 100 に達している場合を示すフラグ変数

            # ThreadID または EngineNum に対応する属性名の設定と対応するクラス（self）属性の取得
            BackLog_attr = "BackLog_{0}".format(str(ThreadID))  # BackLog の属性名を設定
            """ "attr" は attribute（属性）の略を指し、プログラミングの文脈において一般的に使われます。 """
            BackLog = getattr(self, BackLog_attr, None)  # BackLog 属性から BackLog を取得
            # ログテキストエリア（QTextEdit）の属性名を設定及びクラス（self）属性の対応する属性から参照を取得
            # （WaitingLog が使用されるケースでは LogText は不要だが、1 スレッド 1 タスクの原則上 WaitingLog が実際に使用されることは想定していない）
            # （ただし将来的にエンジンがマルチスレッド化する可能性もあるため、WaitingLog のロジックは維持する）
            LogText = getattr(self, "LogText_{0}".format(str(EngineNum)), None)
            LogTextIsProgressing_attr = "LogTextIsProgressing_{0}".format(str(EngineNum))  # 進捗率表示中か否かのフラグの属性名を設定
            LogTextIsProgressing = getattr(self, LogTextIsProgressing_attr, None)  # 進捗率表示中か否かのフラグ属性から値を取得
            # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログを保持する変数の属性名を設定
            WaitingLog_attr = "WaitingLog_{0}".format(str(EngineNum))
            # ログテキストエリアが進捗率表示中か、非同期で行われている処理が長引いているために呼び出された場合
            # またはログテキストエリアが進捗率表示中で処理完了フラグを受け取った場合
            if LogTextIsProgressing or LongProcess or (LogTextIsProgressing and Completed):
                ProgressPercentage_attr = "ProgressPercentage_{0}".format(str(EngineNum))  # エンジンのスレッド毎の進捗率辞書の属性名を設定
                ProgressPercentage = getattr(self, ProgressPercentage_attr, None)  # エンジンのスレッド毎の進捗率辞書の属性から参照を取得
                # 関数 self.RecordProgress() が保存したログカウントと FirstReport の値を取得（以後この関数で管理）
                ProgressLogCount_attr = "ProgressLogCount_{0}".format(str(ThreadID))  # 進捗率ログのログカウントの属性名を設定
                ProgressLogCount = getattr(self, ProgressLogCount_attr, None)  # 進捗率ログのログカウントの属性からログカウントを取得
                FirstProgressReport_attr = "FirstProgressReport_{0}".format(str(ThreadID))  # FirstReport の属性名を設定
                FirstProgressReport = getattr(self, FirstProgressReport_attr, None)  # FirstReport の属性から値を取得

                try:  # エラーを検出するブロック
                    # エンジンの全てのスレッドの進捗率を確認してフラグを最適化するためのイテレーション
                    for ThreadID_ofDict, Percentage in ProgressPercentage.items():
                        Percentage = float(Percentage)  # 予期せず数値（int or float）として比較不能な値になっていないか確認
                        if Percentage < 100:  # 一つでも 100 未満の Percentage が見つかった場合、フラグを設定してイテレーションを終了
                            # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに他のログが追加されないように制御するフラグを有効化
                            LogTextIsProgressing = True
                            setattr(self, LogTextIsProgressing_attr, LogTextIsProgressing)  # 設定した値をクラス（self）属性として保存
                            break
                    else:  # イテレーションが break されずに完了した場合（全ての Percentage が 100 に達している場合）
                        # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに他のログが追加されないように制御するフラグの状態を記録
                        LogTextWasProgressing = LogTextIsProgressing
                        # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに他のログが追加されないように制御するフラグを無効化
                        LogTextIsProgressing = False
                        setattr(self, LogTextIsProgressing_attr, LogTextIsProgressing)  # 設定した値をクラス（self）属性として保存
                except ValueError as e:  # ValueError が発生した場合
                    Log = ("{0}. ロガー：進捗率の評価中に予期せず数値として使用できないデータが検出された可能性があります。内部エラーのため、開発者に連絡"
                        "してください。エンジン番号：{1}、スレッド ID：{2}、エラー内容：{3}").format(
                            GetLogCountAndHandleErrors(EngineNum), str(EngineNum), str(ThreadID), str(e))
                    self.InsertLOG(Log, EngineNum, Debug = True)  # エラー内容をデバッグモードで GUI に反映または後続の処理で反映
                except Exception as e:  # 何らかのエラーが発生した場合
                    Log = ("{0}. ロガー：進捗率の評価中に予期しないエラーが発生しました。内部エラーのため、開発者に連絡してください。エンジン番号：{1}、"
                        "スレッド ID：{2}、エラー内容：{3}").format(
                            GetLogCountAndHandleErrors(EngineNum), str(EngineNum), str(ThreadID), str(e))
                    self.InsertLOG(Log, EngineNum, Debug = True)  # エラー内容をデバッグモードで GUI に反映または後続の処理で反映

            if not LogTextIsProgressing or FirstProgressReport:  # ログテキストエリアが進捗率表示中でない、または初回の進捗率表示の場合
                # BackLog をログテキストエリア（QTextEdit）に挿入（BackLog の状態に応じて最も効率的な方法を選択）
                """
このブロックは「進捗率ログでない通常のログ」の追加を試みられた場合、または「進捗率ログの表示開始」時に該当します。これらはログエントリの末尾の改行の有無で識別され、
「進捗率ログの表示開始」時は通常､「進捗率ログでない通常のログ」と同様に扱われます。これは、その動的なログエントリが最初にログテキストエリアに追加されるとき、ログ
エントリの末尾には改行が含まれている必要があり、この形式は「進捗率ログでない通常のログ」と同じであるためです。しかし、同じ「進捗率ログの表示開始」条件でも、取り
出された「ログテキストエリアに追加されるべきログ」が複数行である場合があります。これは、処理を行っているスレッドが進捗率報告を要さない処理を行った後、連続的に進捗
率報告を要する処理を開始した場合（ケース 1）や、処理を行っているスレッドが最後に進捗率を報告してから一度進捗率が 100% に達し、その後すぐに次の処理セグメントの
進捗率報告を開始した場合に起こり得るケースです。この関数は各スレッドの処理が完了した場合、または処理が長引いている場合（処理開始から一定時間経過）に呼び出される
ため、特に処理が長引いている場合に「前回の進捗率報告の続き（完了）」と「新しい進捗率報告」が一定時間内に蓄積される可能性があります。またはスレッドが一定時間内に
「前回の進捗率報告の続き（完了）」と「その後の処理状況ログ」を記録して処理を完了し、エンジンの他のスレッドが進捗率報告を行っていない場合にも、同じく適切な対応を
行う必要があります。こちらの場合は「進捗率ログの表示開始」には該当しませんが、先に行われるフラグの最適化によって「ログテキストエリアが進捗率表示中でない」に該当
します。しかし実際には「前回の進捗率報告の続き（完了）」を含み、このログエントリの末尾には改行が含まれていません。ここまでに挙げた例の内、ケース 1 以外の例では
いずれも、取り出された「ログテキストエリアに追加されるべきログ」は「前回の進捗率報告の続き（完了）」を含み、かつ複数行であり、末尾に改行を含みません。この状況を
解決するため、このブロックでは他のブロックと同様、取り出されたログの末尾の改行の有無に基づいた、かつログの状態に応じた最も効率的な方法で処理を行います。
                """
                if not BackLog.endswith(self.LF):  # BackLog の末尾に改行がない場合（その行の進捗率ログが取り出されなかった場合）
                    AppendBackLog = ReplaceLogText()  # 補助関数で処理
                else:  # BackLog の末尾に改行がある場合（通常通りのログ追加処理）
                    LogText.moveCursor(QTextCursor.Start)  # ログテキストエリア（QTextEdit）の先頭にカーソルを移動
                    LogText.insertPlainText(BackLog)  # BackLog をログテキストエリア（QTextEdit）に挿入
                    AppendBackLog = True  # BackLog をログテキストエリア（QTextEdit）に反映したことを示すフラグを有効化

                if FirstProgressReport:  # 初回の進捗率表示の場合
                    setattr(self, FirstProgressReport_attr, None)  # 値を無効化して保存
            elif LogTextIsProgressing and not FirstProgressReport:  # ログテキストエリアが進捗率表示中、かつ初回の進捗率表示でない場合
                # BackLog をログテキストエリア（QTextEdit）に挿入（BackLog の状態に応じて最も効率的な方法を選択）
                """
BackLog の末尾に改行がない場合、行う処理は前の条件式内でのものと同じになりますが、条件の評価順序がコンテキストと一致するように明示的に各条件式内で同じ処理を行い
ます。少々冗長な記述になりますが、その点については最大限のカプセル化を行うことで対応しています。
                """
                if not BackLog.endswith(self.LF):  # BackLog の末尾に改行がない場合（該当行は初回以降の進捗率ログ）
                    AppendBackLog = ReplaceLogText()  # 補助関数で処理
                else:  # BackLog の末尾に改行がある場合（通常通りのログ追加処理だが、追加先は WaitingLog）
                    WaitingLog = getattr(self, WaitingLog_attr, None)  # クラス（self）属性の WaitingLog 属性から WaitingLog を取得
                    WaitingLog = BackLog + WaitingLog  # WaitingLog に BackLog を追加（新しいものを先頭に追加）
                    setattr(self, WaitingLog_attr, WaitingLog)  # 更新された WaitingLog を元の属性に保存
            """
この関数では、LogText.moveCursor(QTextCursor.Start) と WaitingLog = BackLog + WaitingLog の行で「新しいログをログテキストエリアの最上部に挿入する」
という、このアプリケーションの仕様を具体的に実装しています。WaitingLog にログを振り分ける必要がある場合が存在することについての解説は、関数 self.InsertLOG()
内のものをご確認ください。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

            if AppendBackLog:  # BackLog がログテキストエリア（QTextEdit）に反映された場合
                # ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数に BackLog を追加
                self.UpdateLogSegment(BackLog, EngineNum)
                setattr(self, BackLog_attr, "")  # クラス（self）属性の BackLog 属性をクリア

            if LogTextWasProgressing:  # エンジンの全てのスレッドの進捗率が 100 に達している場合
                # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログを保持する変数を取得
                WaitingLog = getattr(self, WaitingLog_attr, None)  # クラス（self）属性の WaitingLog 属性から WaitingLog を取得
                if WaitingLog:  # WaitingLog が空文字列（str）でない（ログが格納されている）ことを確認
                    # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログとこれまでのログを視覚的に分離
                    self.LogSeparator(EngineNum, waitinglog = "start")  # 区切り線を挿入
                    # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログをログテキストエリアに挿入
                    LogText.moveCursor(QTextCursor.Start)  # ログテキストエリア（QTextEdit）の先頭にカーソルを移動
                    LogText.insertPlainText(WaitingLog)  # WaitingLog をログテキストエリア（QTextEdit）に挿入
                    # ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数に WaitingLog を追加
                    self.UpdateLogSegment(WaitingLog, EngineNum)
                    setattr(self, WaitingLog_attr, "")  # クラス（self）属性の WaitingLog 属性をクリア
                    # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログとこれ以降のログを視覚的に分離
                    self.LogSeparator(EngineNum, waitinglog = "end")  # 区切り線を挿入
            """
ここまでの、関数 self.UpdateLogSegment() と関数 self.LogSeparator() の呼び出し順序について解説します。まず「if AppendBackLog:」のブロックで､「前の
コード部分で BackLog がログテキストエリア（QTextEdit）に反映された場合」に関数 self.UpdateLogSegment() を呼び出し、BackLog を「ログテキストの特定の
区切り線のインデックス計算用にログセグメントを保持する変数（以下、ログセグメント変数）」に追加しています。このブロックの目的は､「特定の区切り線（ログテキストエリア
（QTextEdit）に直接挿入されるものを指す）」のログテキスト全体における正確なインデックスを計算するために、前回の特定の区切り線の挿入以降のログを保持しているログ
セグメント変数にも BackLog を追加することです（特定の区切り線のログテキスト全体における正確なインデックスは、システムログが一定量に達した際にトリガーされる、後続
の「不要になった古いログの削除」処理で活用されます）。ログセグメント変数は、特定の区切り線を関数 self.LogSeparator() で挿入する際に、特定の区切り線の
インデックス計算時に活用され、計算後に同関数内で自動的にクリアされます。要約すると､「ログテキストエリア（QTextEdit）にログを挿入したら、ログセグメント変数にも
同じものを追加しなければならず、ログセグメント変数は特定の区切り線の挿入時にクリアされる。前回の特定の区切り線から今回の特定の区切り線までのログがログセグメント
変数に正確に反映されていなければ、特定の区切り線のログテキスト全体における正確なインデックスの計算を行うことができない」となります。従って、この関数では「ログ
テキストエリア（QTextEdit）への BackLog の挿入」と「ログテキストエリア（QTextEdit）への WaitingLog の挿入」、及び「特定の区切り線の挿入」という三つの動作を
行っているため、関数 self.UpdateLogSegment() と関数 self.LogSeparator() の呼び出し順序に特に配慮する必要があります。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

    # ログ行のリストを処理し、重複するログを省略する関数
    def ProcessLOG(self, LogLines, backlog = False):
        """ この部分を「関数の docstring」と言います。
        ログ行のリストを処理し、重複するログを省略する関数。

        この関数は、ログ行のリストを受け取り、重複する内容のログを省略し、処理したログ行のリストを返します。このプロセスは、ログ処理の一環として
        LogManagerClass 内の他の関数のコンテキストで行われます。従ってクラス外から直接この関数が呼び出されることはありません。この関数の機能は、同クラス内の
        関数 self.InsertProcessedLOG() と関数 self.ToProcessedBackLOG() が利用しています。この関数が想定している「重複ログの省略シナリオ」は、データを
        イテレート処理し、そのイテレーションブロック内で大量に出力される同じ文言のログを省略する場合や、一連の処理の中で同じ文言が頻出する場合などです。ログに
        エラー（英字）が記録されている場合はそれを検知し、省略しないロジックを持っていますが、カスタマイズされた日本語のエラーについては検知できません。（ただし
        「"「」" で囲まれた部分文字列を含むログ行は省略しない」というロジックを持っているため、日本語のエラーをログに記録する際にエラー内容を "「」" で囲むよう
        にすることで、これを検知することは可能です。これは日本語のエラーを raise ステートメントでスローした後、それをキャッチしたコード部分でキャッチしたエラー
        内容を "「」" 内に配置し、適切なメッセージと共にログ記録関数に渡すことで実現可能です）従って、カスタマイズされた日本語のエラーが発生する可能性のある部分
        ではログの省略ロジックを含むログ記録関数を使用することは推奨されません。しかし、この関数の重複省略ロジックは、あくまで「重複するログを省略する」ので、
        ユニークなエラーはログの記録としてそのまま残ります。ログの省略ロジックを含むログ記録関数がこの関数の重複省略ロジックのみを採用している場合は、エラーの
        情報がログから失われるという問題は発生しません。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            LogLines (list): 処理するログのリスト（最終行の改行を取り除いたもの）。
            backlog (bool, optional): バックログ（バックグラウンドスレッドのログ）のログ処理を行う場合は True、そうでない場合は False（デフォルト）。

        Returns:
            list: 処理後のログ行のリスト（最終行に改行を追加したもの）。
        """
        # 補助関数：ログ行からログ番号を抽出
        def ExtractLogNumber(Line, backlog = False):
            """ この部分を「関数の docstring」と言います。
            ログ行からログ番号を抽出する関数。

            この関数は、指定されたログ行からログ番号を抽出し、それを返します。通常のログの場合とバックログ（バックグラウンドスレッドのログ）の場合とではパターン
            が異なりますので、それぞれに対応するパターンマッチングを行います。

            Parameters:
                Line (str): ログ番号を含むログ行。
                backlog (bool, optional):
                    バックログ（バックグラウンドスレッドのログ）のログ行を処理する場合は True、そうでない場合は False（デフォルト）。

            Returns:
                str or None: マッチした場合はログ番号の文字列、マッチしない場合は None。
            """
            if not backlog:  # バックログでない場合（非同期処理中（バックグラウンド処理中）に出力されたログでない場合）
                Match = re.match(r"(\d+)\. ", Line)  # Line から "n. " のパターンを検索（n は 1 つ以上の数字）
                return Match.group(1) if Match else None  # マッチがあればその数字（n）を返し、なければ None を返す
            elif backlog:  # バックログの場合（非同期処理中（バックグラウンド処理中）に出力されたログの場合）
                Match = re.match(r"(/ \d+)\. ", Line)  # Line から "/ n. " のパターンを検索（n は 1 つ以上の数字）
                return Match.group(1) if Match else None  # マッチがあればその文字列（/ n）を返し、なければ None を返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：特殊なログを判定
        def IsSpecialLog(Line, backlog = False):
            """ この部分を「関数の docstring」と言います。
            特殊なログを判定する関数。

            この関数は、鉤括弧で囲まれた任意の文字列（str）、ログカウントを含む半角英数、または単なる半角英数のみのログを特殊とみなします。通常のログと
            バックログ（バックグラウンドスレッドのログ）の両方の場合に対応しており、特殊とみなされるパターンにマッチする場合に True を返します。

            Parameters:
                Line (str): 判定対象のログ行。
                backlog (bool, optional):
                    バックログ（バックグラウンドスレッドのログ）のログ行を判定する場合は True、そうでない場合は False（デフォルト）。

            Returns:
                bool: ログが特殊な場合、True。そうでなければ False。
            """
            if not backlog:  # バックログでない場合（非同期処理中（バックグラウンド処理中）に出力されたログでない場合）
                return (  # マッチするものがなければ False を返す
                    re.search(r"「.*?」", Line) or  # Line の "「」" で囲まれた任意の文字列（str）にマッチ（True）
                    re.match(r"^\d+\.\s+[a-zA-Z0-9]+$", Line) or  # Line の "数字. 英数字" の形式にマッチ（True）
                    re.match(r"^[a-zA-Z0-9]+$", Line))  # Line が英数字のみの場合にマッチ（True）
            elif backlog:  # バックログの場合（非同期処理中（バックグラウンド処理中）に出力されたログの場合）
                return (  # マッチするものがなければ False を返す
                    re.search(r"「.*?」", Line) or  # Line の "「」" で囲まれた任意の文字列（str）にマッチ（True）
                    re.match(r"^/\s+\d+\.\s+[a-zA-Z0-9]+$", Line) or  # Line の "/ 数字. 英数字" の形式にマッチ（True）
                    re.match(r"^[a-zA-Z0-9]+$", Line))  # Line が英数字のみの場合にマッチ（True）
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：各ログ行を検証し、重複するログを省略
        def FirstProcess_LogDeduplication(LogLines, backlog = False):
            """ この部分を「関数の docstring」と言います。
            各ログ行を検証し、重複するログを省略する関数。

            この関数は、重複する内容のログを見つけた場合、それを省略してその旨の文言を該当箇所に追加します。重複とは、同じ内容のログが複数回登場することを意味
            します。この関数はログ行のリストを受け取り、重複が省略された新しいリストを返します。

            Parameters:
                LogLines (list of str): 処理するログ行のリスト。
                backlog (bool, optional):
                    バックログ（バックグラウンドスレッドのログ）のログ行を処理する場合は True、そうでない場合は False（デフォルト）。

            Returns:
                list of str: 重複が省略されたログ行のリスト。
            """
            # 変数を初期化
            Processed = []  # 処理後のログを格納するリスト
            Seen = set()  # 検証したログ内容を追跡するセット
            LastDupNum = None  # 最後に検証した重複ログの番号
            DupFound = False  # 重複ログが見つかったかどうかのフラグ

            # 各ログ行の処理
            for Line in LogLines:  # 処理するログ行のリストからログ行を一行ずつ取り出すイテレーション
                LogNum = ExtractLogNumber(Line, backlog)  # ログ番号の抽出
                CleanLine = Line[len(LogNum) + 2:] if LogNum else Line  # ログ行からログ番号を分離してログ内容を取得

                # 重複するログの検出と処理
                if CleanLine and not IsSpecialLog(Line = CleanLine, backlog = backlog):  # 通常のログ行の処理
                    if CleanLine not in Seen:  # 重複していない場合
                        Processed.append("{0}. {1}".format(LogNum if LogNum else "", CleanLine))  # ログ番号の再付与
                        Seen.add(CleanLine)  # 検証済みのログ内容を検証したログ内容を追跡するセットに追加
                        DupFound = False  # ログが重複していないことを示すフラグを設定
                    else:  # 重複が見つかった場合
                        if not DupFound:  # 最初の重複の場合
                            LastDupNum = LogNum if LogNum else ""  # 最初の重複のログ番号を記録
                            DupFound = True  # ログが重複していることを示すフラグを設定
                else:  # 特殊またはチェック対象外のログ行の処理
                    Processed.append(Line)  # 処理後のログを格納するリストにログ行を追加

            if LastDupNum:  # 「最初の重複のログ番号」が記録されている場合
                # 処理後のログを格納するリストに重複ログの省略文言を追加
                Processed.append("{0}# {1}. ロガー：重複するログを省略{0}".format(self.LF, LastDupNum))

            return Processed  # 重複が省略されたログ行のリストを返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        """ self.ProcessLOG() の記述 """
        # ログ行リストの処理
        LogLines = FirstProcess_LogDeduplication(LogLines, backlog)  # ログ行リストを補助関数で処理
        # 今後処理を追加する場合
        # 例: LogLines = SecondProcess_SomeProcess(LogLines, backlog)
        LogLines[-1] = str(LogLines[-1]) + self.LF  # 最終行に改行を追加
        return LogLines  # 処理後のログ行のリストを返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 処理待ちのシステムログを処理し、対応するログテキストエリアに挿入する関数
    def InsertProcessedLOG(self, CallNum):
        """ この部分を「関数の docstring」と言います。
        処理待ちのシステムログを処理し、対応するログテキストエリアに挿入する関数。

        この関数は、引数 CallNum に基づいて処理待ちのログ（ProcessLog）を取得し、行毎に分割して関数 self.ProcessLOG() を通じて処理します。処理したログは
        新しいログエントリとして、CallNum に対応するログテキストエリアの最上部に挿入します。ProcessLog 属性はログの取得後にクリアします。注意事項として、
        ProcessLog 属性はバックログ（バックグラウンドスレッドのログ）を一時的に保持することもありますが、この関数はバックログの処理のために設計されたものでは
        なく、ProcessLog 属性に「処理すべき通常のシステムログ」が蓄積された後に即座に呼び出し、処理するために設計されています。ProcessLog 属性がバックログを
        含むことが想定されるコンテキストでは、この関数は使用できません。そのようなコンテキストでは、同じ機能を持つ関数 self.ToProcessedBackLOG() を使用する
        ことが適切です。これは、アプリケーションのメインスレッド以外のバックグラウンドスレッドから GUI を操作することが禁じられているためです。この関数は、将来、
        エンジン数 = バックグラウンドスレッド数でなくし、エンジンをマルチスレッド化する場合に備えるため、CallNum に紐づくクラス属性へのアクセスをロックしてから
        処理を行うよう設計されています。そのため、内部で CallNum をエンジン番号に変換します。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            CallNum (int): 処理する処理待ちのログ（ProcessLog）を識別する整数値（0 ～ 5）。

        Returns:
            なし。
        """
        EngineNum = IntegrationOfThreadIDtoEngineNum(CallNum) if CallNum > 5 else CallNum  # 必要に応じて CallNum をエンジン番号に変換
        # EngineNum に対応する属性名を設定及びクラス（self）属性の対応する属性からロックメカニズムのインスタンスを取得
        QMutex = getattr(self, "QMutex_{0}".format(str(EngineNum)), None)
        with QMutexLocker(QMutex):  # ロックを取得（ブロックを抜けるまで CallNum に紐づくクラス（self）属性へのアクセスはロックされる）
            AppendProcessLog = False  # 変数を初期化

            # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性から ProcessLog を取得
            ProcessLog = getattr(self, "ProcessLog_{0}".format(str(CallNum)), None)
            setattr(self, "ProcessLog_{0}".format(str(CallNum)), "")  # ProcessLog 属性をクリア

            LogLines = ProcessLog.split(self.LF)[:-1] if ProcessLog else []  # ProcessLog を改行で分割してリストを取得（最後の空行を除く）
            LogLines = self.ProcessLOG(LogLines) if len(LogLines) > 0 else []  # リストがログ情報を含む場合、補助関数で処理

            ProcessLog = self.LF.join(LogLines)  # 更新されたログリストを改行で連結して ProcessLog に代入

            # EngineNum に対応する属性名を設定及びクラス（self）属性からフラグ属性の値を取得
            LogTextIsProgressing = getattr(self, "LogTextIsProgressing_{0}".format(str(EngineNum)), None)
            if not LogTextIsProgressing:  # ログテキストエリアが進捗率表示を行っていない場合
                # EngineNum に対応する属性名を設定及びクラス（self）属性の対応する属性からログテキストエリア（QTextEdit）の参照を取得
                LogText = getattr(self, "LogText_{0}".format(str(EngineNum)), None)
                LogText.moveCursor(QTextCursor.Start)  # ログテキストエリア（QTextEdit）の先頭にカーソルを移動
                LogText.insertPlainText(ProcessLog)  # ProcessLog をログテキストエリア（QTextEdit）に挿入
                AppendProcessLog = True  # ProcessLog をログテキストエリア（QTextEdit）に反映したことを示すフラグを有効化
            else:  # ログテキストエリアが進捗率表示を行っている場合
                # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログを保持する変数に ProcessLog を追加
                # EngineNum に対応する属性名を設定及びクラス（self）属性の対応する属性から WaitingLog を取得
                WaitingLog = getattr(self, "WaitingLog_{0}".format(str(EngineNum)), None)
                WaitingLog = ProcessLog + WaitingLog  # ProcessLog を WaitingLog に追加（新しいものを先頭に追加）
                setattr(self, "WaitingLog_{0}".format(str(EngineNum)), WaitingLog)  # 更新された WaitingLog を元の属性に保存
            """
この関数では、LogText.moveCursor(QTextCursor.Start) と WaitingLog = ProcessLog + WaitingLog の行で「新しいログをログテキストエリアの最上部に挿入
する」という、このアプリケーションの仕様を具体的に実装しています。WaitingLog にログを振り分ける必要がある場合が存在することについての解説は、関数
self.InsertLOG() 内のものをご確認ください。WaitingLog に蓄積されるログの取り出しは、関数 self.InsertBackLOG() が行います。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

            # ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数に ProcessLog を追加
            if AppendProcessLog:  # ProcessLog がログテキストエリア（QTextEdit）に反映された場合
                self.UpdateLogSegment(ProcessLog, EngineNum)

    # 非同期処理中（バックグラウンド処理中）に蓄積された処理待ちのログ（ProcessLog）またはバックログ（バックグラウンドスレッドのログ）を処理し、
    # 非同期処理中のバックログとして保存または再保存する関数
    def ToProcessedBackLOG(self, ThreadID, backlog = False):
        """ この部分を「関数の docstring」と言います。
        非同期処理中（バックグラウンド処理中）に蓄積された処理待ちのログ（ProcessLog）またはバックログ（バックグラウンドスレッドのログ）を処理し、
        非同期処理中のバックログとして保存または再保存する関数。

        この関数は、引数 ThreadID に基づいて処理待ちのログ（ProcessLog）またはバックログを取得し、行毎に分割して関数 self.ProcessLOG() を通じて処理しま
        す。引数 backlog を指定しない場合に ProcessLog、True の場合にバックログを処理します。処理したログは新しいログエントリとして、新たにバックログ属性に
        保存（または元のバックログ属性に再保存）します。ProcessLog を処理する場合、ProcessLog 属性はログの取得後にクリアします。この関数は非同期処理中に蓄積
        される ProcessLog またはバックログを非同期イベントループ（バックグラウンドスレッド）内で処理するために設計されており、これを行うことで非同期処理
        ハンドラがバックログを取り出す際の処理の簡素化を図ります。この関数は、将来、エンジン数 = バックグラウンドスレッド数でなくし、エンジンをマルチスレッド化
        する場合に備えるため、ThreadID に紐づくクラス属性へのアクセスをロックしてから処理を行うよう設計されています。そのため、内部で ThreadID をエンジン番号
        に変換します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            ThreadID (int):
                処理する処理待ちのログ（ProcessLog）またはバックログ属性を識別するための、
                バックグラウンドスレッドを識別する整数値（0 〜 5 に加えて 6 以上も含む）。
            backlog (bool, optional): バックログを処理する場合は True、処理待ちのログ（ProcessLog）を処理する場合は False（デフォルト）。

        Returns:
            なし。
        """
        EngineNum = IntegrationOfThreadIDtoEngineNum(ThreadID) if ThreadID > 5 else ThreadID  # 必要に応じて ThreadID をエンジン番号に変換
        # EngineNum に対応する属性名を設定及びクラス（self）属性の対応する属性からロックメカニズムのインスタンスを取得
        QMutex = getattr(self, "QMutex_{0}".format(str(EngineNum)), None)
        with QMutexLocker(QMutex):  # ロックを取得（ブロックを抜けるまで ThreadID に紐づくクラス（self）属性へのアクセスはロックされる）
            # ThreadID に対応する属性名を設定及びクラス（self）属性の対応する属性から ProcessLog または BackLog を取得
            AccumulatedLog = getattr(self, "ProcessLog_{0}".format(str(ThreadID)), None) if not backlog else \
                getattr(self, "BackLog_{0}".format(str(ThreadID)), None)  # 引数 backlog に基づいて処理する属性を選択

            if not backlog:  # ProcessLog を処理する場合
                setattr(self, "ProcessLog_{0}".format(str(ThreadID)), "")  # ThreadID に対応する ProcessLog 属性をクリア

            # AccumulatedLog を改行で分割してリストを取得（最後の空行を除く）
            LogLines = AccumulatedLog.split(self.LF)[:-1] if AccumulatedLog else []
            # リストがログ情報を含む場合、補助関数で処理
            LogLines = self.ProcessLOG(LogLines, backlog = True) if len(LogLines) > 0 else []

            # 更新されたログを AccumulatedLog に代入して新たに BackLog 属性に保存（または元の BackLog 属性に再保存）
            AccumulatedLog = self.LF.join(LogLines)  # 更新されたログリストを改行で連結して AccumulatedLog に代入
            # 引数 backlog が False の場合、ThreadID に対応する属性名を設定及びクラス（self）属性の対応する属性から BackLog を取得
            BackLog = getattr(self, "BackLog_{0}".format(str(ThreadID)), None) if not backlog else ""
            BackLog = AccumulatedLog + BackLog  # AccumulatedLog を BackLog に追加（新しいものを先頭に追加）
            setattr(self, "BackLog_{0}".format(str(ThreadID)), BackLog)  # 更新された BackLog をクラス（self）属性として保存（または再保存）
            """
この関数では、BackLog = AccumulatedLog + BackLog の行で「新しいログをログテキストエリアの最上部に挿入する」という
このアプリケーションの仕様を具体的に実装しています。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

    # システムログに進捗率を追加する、関数 ReportProgress() 専用関数
    def RecordProgress(self, FirstReport, Log, Percentage, EngineNum, ThreadID):
        """ この部分を「関数の docstring」と言います。
        システムログに進捗率を追加する、関数 ReportProgress() 専用関数。

        この関数は、渡された FirstReport とバックログ（バックグラウンドスレッドのログ）属性の状態に応じて、バックログに進捗率ログを追加、またはバックログの
        既存の進捗率ログを更新、またはバックログ属性が空になっている場合はログテキストエリアの進捗率ログを更新するための進捗率ログをバックログ属性に保存します。
        最初の進捗率報告である場合、新しい進捗率ログをバックログに追加し、それ以降の進捗率報告である場合、バックログの既存の進捗率ログを更新します。このとき、
        バックログ属性が空になっている場合（処理に時間がかかっていることをユーザーに知らせるためにバックログがログテキストエリアに反映された場合。以後、ケース
        1）、ログテキストエリアの進捗率ログを更新するために最適化された進捗率ログをバックログ属性に保存します。また、進捗率ログ用のログカウントを管理し、進捗率
        ログの更新毎にカウントが不適切に更新されないよう、バックログの内容を適切に更新します。ログカウントと FirstReport の値はクラス属性に動的に保存（この
        関数で初期化）し、ケース 1 の場合に関数 self.InsertBackLOG() が利用します。これらの属性は同関数で利用された後に同関数が削除します。また引数
        Percentage の値も同じ目的でクラス属性に保存しますが、こちらは動的に作成される属性ではありません（クラスのコンストラクタで初期化）。この関数は、将来、
        エンジン数 = バックグラウンドスレッド数でなくし、エンジンをマルチスレッド化する場合に備えるため、ThreadID に紐づくクラス属性へのアクセスをロックして
        から処理を行うよう設計されています。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            FirstReport (bool): 最初の進捗率報告であるかどうかを示すフラグ。
            Log (str): 進捗率を表現する文字列。
            Percentage (int): 現在の進捗率（0 ～ 100 の整数、5 の倍数）。整数値。
            EngineNum (int): ログを挿入するログテキストエリアを識別する整数値（0 ～ 5）。クラス内の別関数で使用される引数 CallNum と対応。
            ThreadID (int): バックグラウンドスレッドを識別する整数値（0 〜 5 に加えて 6 以上も含む）。

        Returns:
            なし。
        """
        # EngineNum に対応する属性名を設定及びクラス（self）属性の対応する属性からロックメカニズムのインスタンスを取得
        QMutex = getattr(self, "QMutex_{0}".format(str(EngineNum)), None)
        with QMutexLocker(QMutex):  # ロックを取得（ブロックを抜けるまで ThreadID に紐づくクラス（self）属性へのアクセスはロックされる）
            # ThreadID に対応する属性名を設定
            ProgressLogCount_attr = "ProgressLogCount_{0}".format(str(ThreadID))  # 動的に作成される属性（この関数で初期化）
            BackLog_attr = "BackLog_{0}".format(str(ThreadID))
            """ "attr" は attribute（属性）の略を指し、プログラミングの文脈において一般的に使われます。 """

            if FirstReport:  # 進捗率の追加（新規ログ）指示を受けた場合
                # 進捗率ログ用のログカウントを取得及びクラス（self）属性として保存し、関数 self.InsertBackLOG() に削除の管理を委譲
                try:  # エラーを検出するブロック
                    # ログカウントの取得（進捗率ログの追加先は BackLog 属性なので、"/ " を付ける）
                    ProgressLogCount = "/ {0}. ".format(str(self.LogCount(EngineNum)))
                except ValueError as e:  # ValueError が発生した場合
                    self.InsertLOG(str(e), EngineNum, Debug = True)  # エラー内容をデバッグモードで GUI に反映または後続の処理で反映

                setattr(self, ProgressLogCount_attr, ProgressLogCount)  # 動的に作成される属性を設定（この関数で初期化）
                # FirstReport の値をクラス（self）属性として保存し、関数 self.InsertBackLOG() に削除の管理を委譲
                setattr(self, "FirstProgressReport_{0}".format(str(ThreadID)), FirstReport)  # 動的に作成される属性を設定（この関数で初期化）

            # クラス（self）属性の ProgressLogCount 属性から ProgressLogCount を取得
            ProgressLogCount = getattr(self, ProgressLogCount_attr, None)
            Log = ProgressLogCount + Log  # 取得したログカウントと進捗率ログを結合
            BackLog = getattr(self, BackLog_attr, None)  # クラス（self）属性の BackLog 属性から BackLog を取得

            # 進捗率ログの最適化
            if FirstReport:  # 進捗率ログの初回処理の場合
                Log = Log + self.LF  # 進捗率ログに改行を追加

            # BackLog の更新
            if FirstReport:  # 進捗率ログの初回処理
                BackLog = Log + BackLog  # 進捗率ログの追加
            elif BackLog:  # 進捗率ログの初回以降の処理（BackLog が空でない場合）
                BackLogLines = BackLog.split(self.LF)  # BackLog を改行で分割してリストを取得
                # リストをログカウントで検索して更新するべき進捗率ログのインデックスを取得
                ProgressLogList = ExtractMatchingIndexesAndLines(BackLogLines, ProgressLogCount)
                Index_ofProgressLog = ProgressLogList[0][0] if ProgressLogList else None  # 検索結果からインデックスを取り出す
                if Index_ofProgressLog >= 0:  # インデックスが取り出されたことを確認
                    BackLogLines[Index_ofProgressLog] = Log  # リストのインデックス箇所に新しい進捗率ログを代入（改行なし）
                BackLog = self.LF.join(BackLogLines)  # 更新されたログを BackLog に代入
            elif not BackLog:  # 進捗率ログの初回以降の処理（BackLog が空の場合）
                BackLog = Log  # 進捗率ログの追加（改行なし）
            """
この関数では、BackLog = Log + BackLog の行で「新しいログをログテキストエリアの最上部に挿入する」というこのアプリケーションの仕様を具体的に実装しています。

このアプリケーションでは、継続的に更新される性質を持つログエントリ（この関数では進捗率ログなので、以下進捗率ログ）をログテキスト内で古いものから新しいものに置換
する際、新しい進捗率ログが格納されている属性に「新しい進捗率ログが格納されている」ことを検知するロジックとして、ログエントリの末尾の改行の有無で判断するロジックを
採用しています。従って、この関数では、BackLog の状態に応じて進捗率ログの末尾に改行を追加するかどうかを適切に判断する必要があります。進捗率ログの初回処理の場合、
進捗率ログは通常のログエントリと同様に末尾に改行を持つ形である必要があるため、BackLog の更新処理の前に改行追加処理を行っています。初回以降の処理である場合、
BackLog に新しい進捗率ログが格納されていることを関数 self.InsertBackLOG() が検知することを可能とするため、進捗率ログは末尾に改行を持たない形となっている必要
があります。ここで、BackLog が空でない場合、進捗率ログが末尾に改行を持たない形であることと、末尾に改行を持つ他の通常のログエントリが存在することとの整合性を認識
しておく必要があります。継続的に更新される性質を持つログエントリのうち、初回以降の進捗率ログの場合、BackLog が空でない条件を満たす背景として考えられるのは「初回
の進捗率ログがまだ BackLog から取り出されていない場合（ケース 1）」または「初回以降の進捗率ログがまだ BackLog から取り出されていない場合（ケース 2）」または
「スレッドの別の進捗率報告が 100% に達した後、そのスレッドのログが取り出されずに、所定の処理を経て今回の進捗率報告が始まった場合（ケース 3）」の三つのケースです。
この三つのケースの背景には、いずれも「極短時間の間に複数の処理が完了または開始されている」があります（ミリ秒単位の所定の時間経過毎にログの取り出しが行われるため）。
まずケース 1 についてですが､「初回の進捗率ログが取り出されていない」ということは BackLog のログテキストは初回の進捗率ログが持つ末尾の改行に伴って他の通常のログ
エントリとの整合性が保証されている状況であることを意味します。従って、初回以降の進捗率ログの BackLog への追加処理時に、新しい進捗率ログが末尾に改行を持たない形と
なっていることは適切であり、逆に改行があると、古い進捗率ログを新しい進捗率ログに置換して BackLog = self.LF.join(BackLogLines) を行う（各行を改行で連結）と
余計な改行がログテキストに出現してしまいます。次にケース 2 についてですが、この場合はケース 1 の処理が終わった後、まだ BackLog のログテキストが取り出されて
いない場合と、前回の処理で置換用に用意された古い進捗率ログのみが BackLog に格納されたままになっている（取り出されていない）場合が考えられます。前者の場合、ケース
1 で解説した内容が踏襲されますので、新しい進捗率ログが末尾に改行を持たない形となっていることは引き続き適切です。後者の場合、前回の処理で置換用に用意された古い
進捗率ログは元々末尾の改行を持たないものであるため、これを末尾の改行を持たない新しい進捗率ログで置換するのには何らの問題もありません。ケース 2 について補足すると、
初回でない途中の進捗率ログと通常のログが混在することは、BackLog 属性が一つのスレッドに対して一つずつ専用のものとして割り振られていて、一つのスレッドは一度に一つ
のタスクしか実行することができないことを考慮すると、そのような状況は発生しないことが分かります。次にケース 3 についてですが、これはケース 1 または 2 もしくはその
両方を経てケース 3 の状況になることが考えられます。従ってこれまでの解説でケース 3 を理解することが可能です。そしてこれまでの解説で、この関数では適切に整合性を維持
して処理を行っていることが理解できます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

            setattr(self, BackLog_attr, BackLog)  # 更新された BackLog を元の属性に保存

            # ThreadID の現在の進捗率をクラス（self）属性として保存
            ProgressPercentage_attr = "ProgressPercentage_{0}".format(str(EngineNum))  # EngineNum に対応する属性名を設定
            # ProgressPercentage 属性（辞書）に ThreadID をキーとして現在の進捗率を保存（値が存在しなければ新規保存、存在すれば上書き保存）
            getattr(self, ProgressPercentage_attr, None)[ThreadID] = Percentage

    # ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数を更新する関数
    def UpdateLogSegment(self, Log, CallNum):
        """ この部分を「関数の docstring」と言います。
        ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数を更新する関数。

        この関数は、ログテキストエリアに反映されたログを「ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数（以下、ログセグメント
        変数）」にも反映させ、更新します。これは、特定の区切り線（ログテキストエリアに直接挿入されるものを指す）のログテキスト全体における正確なインデックスを
        計算するために必要な処理です。ログセグメント変数は前回の特定の区切り線の挿入以降のログを保持し、特定の区切り線を関数 self.LogSeparator() で挿入する際
        に、特定の区切り線のインデックス計算時に活用され、計算後に同関数内で自動的にクリアされます（特定の区切り線のログテキスト全体における正確なインデックスは、
        システムログが一定量に達した際にトリガーされる、後続の「不要になった古いログの削除」処理で活用されます）。つまり、ログテキストエリアにログを挿入したら、
        ログセグメント変数にも同じものを追加しなければならず、特定の区切り線の挿入時にログセグメント変数に前回の特定の区切り線から今回の特定の区切り線までのログ
        が正確に反映されていなければ、特定の区切り線のログテキスト全体における正確なインデックスの計算を行うことができません。この関数は、このための処理を
        カプセル化したものです。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Log (str): ログテキストエリアに追加された新しいログエントリ。
            CallNum (int): 更新する「ログセグメントを保持する変数」を識別する整数値（0 ～ 5）。

        Returns:
            なし。
        """
        # ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数に Log を追加
        # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性から LogSegment を取得
        LogSegment = getattr(self, "LogSegment_{0}".format(str(CallNum)), None)
        LogSegment = Log + LogSegment  # LogSegment に Log を追加（新しいものを先頭に追加）
        setattr(self, "LogSegment_{0}".format(str(CallNum)), LogSegment)  # 更新された LogSegment を元の属性に保存
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # ログテキストエリア、処理待ちのログ（ProcessLog）、またはバックログ（バックグラウンドスレッドのログ）に区切り線を挿入する関数
    def LogSeparator(self, CallNum, processlog = False, backlog = False, waitinglog = None, SpecialCall = False):
        """ この部分を「関数の docstring」と言います。
        ログテキストエリア、処理待ちのログ（ProcessLog）、またはバックログ（バックグラウンドスレッドのログ）に区切り線を挿入する関数。

        この関数は、引数 CallNum に基づいて、ログテキストエリア、処理待ちのログ（ProcessLog）、またはバックログの最初の行に区切り線を挿入します。引数
        processlog が True の場合、ProcessLog に区切り線を挿入します。引数 backlog が True の場合はバックログに挿入し、どちらも False の場合は通常の
        ログテキストエリアに挿入します（特定の区切り線）。これにより、ログのセクションを視覚的に分離します。また区切り線の挿入は、最初の行が既に区切り線でない
        ことを確認した上で行います。さらに、通常のログテキストエリアに区切り線を挿入する際には、後続の「不要になった古いログの削除」処理用の､「ログテキストの
        区切り線のインデックス計算用にログセグメントを保持する変数（LogSegment）」にも区切り線を追加し、その後で区切り線の総数（ProcessLog、バックログに挿入
        されたものは除く）とログテキスト全体における新しい区切り線の正確なインデックスを計算します。引数 waitinglog を指定された場合、その値に基づいて「ログ
        テキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログ」をログテキストエリアに反映した際に挿入する特別な区切り線（これも「特定の
        区切り線」です）をログテキストエリアに挿入します。この関数は、将来、エンジン数 = バックグラウンドスレッド数でなくし、エンジンをマルチスレッド化する場合
        に備えるため、CallNum に紐づくクラス属性へのアクセスをロックしてから処理を行うよう設計されています。そのため、内部で CallNum をエンジン番号に変換
        します。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            CallNum (int):
                区切り線を挿入するログテキストエリアまたは処理待ちのログ（ProcessLog）またはバックログ（バックグラウンドスレッドのログ）属性を識別する整数値。
                引数名は CallNum（これは 0 〜 5）となっているが、ThreadID（6 以上の整数値を含む）を扱うこともある。
            processlog (bool, optional): 処理待ちのログ（ProcessLog）に区切り線を挿入する場合は True、そうでない場合は False（デフォルト）。
            backlog (bool, optional): バックログ（バックグラウンドスレッドのログ）に区切り線を挿入する場合は True、そうでない場合は False（デフォルト）。
            waitinglog (str, optional):
                関数 self.InsertBackLOG() で「ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログ」をログテキストエリアに
                反映した際に挿入する特定の区切り線の種類を指定する文字列。"start" または "end"。
            SpecialCall (bool, optional):
                関数 self.LogSeparator() がどこから呼び出されたのかを示すフラグ。デフォルトは False。通常は関数 self.LogCount() が特定の状況で True
                での呼び出しを行う。

        Returns:
            bool or なし:
                SpecialCall が True のとき、増加分インデックスの加算が行われた場合、True。そうでなければ False。同引数が False の場合、なし。
        """
        # 補助関数：ログテキストに挿入された特定の区切り線の、ログテキスト全体におけるインデックスを更新
        def UpdateSeparatorIndexes(CallNum, LogSegment, SpecialCall = False):
            """ この部分を「関数の docstring」と言います。
            ログテキストに挿入された特定の区切り線の、ログテキスト全体におけるインデックスを更新する関数。

            この関数は、ログテキストエリアに直接区切り線が挿入された際に呼び出され、前回の区切り線の挿入からのログテキストの増加を考慮した、前回以前の区切り線に
            対する増加分インデックスの加算を行います。これはこのアプリケーションのシステムログの仕様が「新しいログをログテキストエリアの最上部に挿入する」ように
            なっているために必要となる「前回以前の区切り線のインデックスの更新処理」です。この処理により、ログテキスト全体における特定の区切り線の正確な
            インデックスを追跡可能にし、後続のログ削除処理がこのインデックスを参照して「不要になった古いログの削除」を効率的に行うことを可能にします。

            Args:
                CallNum (int): 区切り線を挿入するログテキストエリアを識別する整数値（0 ～ 5）。
                LogSegment (str): ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数の識別されたコピー。
                SpecialCall (bool, optional):
                    関数 self.LogSeparator() がどこから呼び出されたのかを示すフラグ。デフォルトは False。通常は関数 self.LogCount() が特定の状況で
                    True での呼び出しを行う。

            Returns:
                bool: SpecialCall が True のときに増加分インデックスの加算が行われた場合、True。そうでなければ False。
            """
            Updated = False  # 変数を初期化

            # CallNum に対応する属性名の設定と対応するクラス（self）属性の取得
            SeparatorIndexes_attr = "SeparatorIndexes_{0}".format(str(CallNum))  # SeparatorIndexes の属性名を設定
            """ "attr" は attribute（属性）の略を指し、プログラミングの文脈において一般的に使われます。 """
            SeparatorIndexes = getattr(self, SeparatorIndexes_attr, None)  # SeparatorIndexes 属性からリストの参照を取得

            if SeparatorIndexes:  # 特定の区切り線（のインデックス）が一つ以上存在することを確認
                # LogSegment を改行で分割してリストにし、範囲長を取得して「前回以前の区切り線」の増加分インデックスを取得
                # ログテキストの各行末は必ず改行で終わるため、有効な行数を得るために「改行で分割したリストの最後の空文字列」を除外する
                # 取得した行数は「インデックスは 0 から始まる」原則上「前回の区切り線の現在のインデックス」に相当するため、増加分インデックスと解釈可能
                IncrementalIndex = int(len(LogSegment.split(self.LF)[:-1]))  # "[:-1]" で、最終行の改行による最後の空文字列を除外

                for i, PreviousIndex in enumerate(SeparatorIndexes):  # 前回以前の特定の区切り線のインデックスを再計算するイテレーション
                    SeparatorIndexes[i] = PreviousIndex + IncrementalIndex  # 前回以前の特定の区切り線のインデックスに増加分インデックスを加算
                    # （このとき､「前回の特定の区切り線のインデックス」は 0 が取り出されるため、増加分インデックスを加算することができる）

                Updated = True  # インデックスの更新が行われたことを示すフラグを有効化
            """
増加分インデックスの計算方法について解説します。まず前提として、このアプリケーションではシステムログの記録方法として「新しいログをログテキストエリアの最上部に挿入
する」仕様を採用しています。また全てのログエントリは末尾に改行を伴っているため、この改行でログテキストを分割 split(self.LF) することで、一つの要素が一つのログ
エントリに相当する､「ログエントリのリスト」を取得することができます（このとき、コメントで述べている通り、有効な行数を得るために「改行で分割したリストの最後の
空文字列」を除外するリストのスライスを使用する必要があります）。そして重要なのが、後続の「不要になった古いログの削除」処理でも、この関数と同様に改行でログテキスト
を分割してリストを取得している点です。同じ方法でログエントリのリストを取得しているということは、この関数内で計算される特定の区切り線のインデックスが、後続の「不要
になった古いログの削除」処理でも有効であるということを意味します。従って、区切り線がログテキストエリアに挿入される（：特定の区切り線）度に、この関数内でその
区切り線の正確なインデックスをあらかじめ計算しておくことで、後続の「不要になった古いログの削除」処理はその正確なインデックスを参照するだけで古いログの削除ポイント
を決定することが可能になります。一見すると、区切り線をログテキストエリアに挿入する（：特定の区切り線）度にインデックスの再計算を行うことはオーバーヘッド（余計な
処理）であると感じられるかもしれません。しかし、これを行わずに後続の「不要になった古いログの削除」処理が発生すると、その処理自体の「必要性の予期不能性
（不確実性）」に加えて、膨大なシステムログから適切な削除ポイントをゼロから計算するコスト（負荷）を考慮しなければならなくなります。一方で特定の区切り線の挿入時に
その正確なインデックスを都度計算する方法は、コストとして予期可能なものであると言え、計算に必要なリソース（LogSegment）をあらかじめ最適化しておくことでコストを
抑えることが可能であり、予期不能性を持つ後続の「不要になった古いログの削除」処理の計算コストを最低限度まで抑えることができます。従ってこの方法はオーバーヘッドと
みなされるものではありません。この関数では、ログエントリのリストの範囲長 int(len(LogSegment.split(self.LF)[:-1]))（要素数 = ログエントリの数）をそのまま
前回以前の特定の区切り線の増加分インデックスとして利用しています（「増加分」という表現は､「新しいログをログテキストエリアの最上部に挿入する」仕様のため、新しい
（最新の）ログのログテキストにおけるインデックスは常に 0 となることから、システムログが蓄積される毎に特定の区切り線のインデックスをログの蓄積分だけ加算しなければ
ならないことを表しています）。リストの範囲長を増加分インデックスとしてそのまま利用できるのには、リストの範囲長が要素数（ログエントリが 1 つならば 1）を返すのに
対し、リストのインデックスは 0 から始まる（リストの要素が 1 つのみであれば、その要素のインデックスは 0）ため、同じリストでも範囲長とインデックスでは範囲長の方が
インデックスよりも 1 多く、この数は前回以前の特定の区切り線のインデックスと一致するという原理が働いています（理解のための具体例は、この解説文を ChatGPT 4 に示す
ことで取得可能です）。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

            if not SpecialCall:  # 通常の呼び出しの場合、ログテキスト全体における新しい特定の区切り線のインデックスを設定
                SeparatorIndex = 0  # 「新しいログをログテキストエリアの最上部に挿入する」仕様のため、最新のものは常に 0 となる
                SeparatorIndexes.append(SeparatorIndex)  # 特定の区切り線のインデックスリストに今回のものを追加

            if Updated or not SpecialCall:  # 増加分インデックスの加算を行ったか、通常の呼び出しの場合
                LogSegment = ""  # ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数をクリア
                setattr(self, "LogSegment_{0}".format(str(CallNum)), LogSegment)  # クリアされた変数をクラス（self）属性として保存

                if SpecialCall:  # 特定の状況で呼び出され、増加分インデックスの加算が行われた場合、True を返す
                    return True
            elif SpecialCall:  # 特定の状況で呼び出されたが、増加分インデックスの加算が行われなかった場合、False を返す
                return False

        # 補助関数：ログテキストエリアに特定の区切り線を挿入
        def InsertSpecificSeparator(CallNum, waitinglog = None):
            """ この部分を「関数の docstring」と言います。
            ログテキストエリアに特定の区切り線を挿入する関数。

            この関数は、この関数の呼び出し元の親関数内で取得されているロックのコンテキスト、または親関数の呼び出し元で取得されているロックのコンテキストで動作
            することを前提としています。それぞれのコンテキストでは挿入する区切り線の種類が異なる場合があり、これは引数 waitinglog によって、どの区切り線を挿入
            するべきかを判断します。この関数はログテキストエリアに特定の区切り線を挿入する際に必要となる全ての処理を内包しています。

            Args:
                CallNum (int): 区切り線を挿入するログテキストエリアを識別する整数値（0 ～ 5）。
                waitinglog (str, optional):
                    関数 self.InsertBackLOG() で「ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログ」をログテキストエリア
                    に反映した際に挿入する特定の区切り線の種類を指定する文字列。"start" または "end"。

            Returns:
                なし。
            """
            # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性からログテキストエリア（QTextEdit）の参照を取得
            LogText = getattr(self, "LogText_{0}".format(str(CallNum)), None)
            if not LogText.toPlainText().split(self.LF, 1)[0] == "────────":  # ログの最初の行が区切り線でない場合、区切り線を挿入
                Separator = "────────" + self.LF  # 通常の区切り線を定義
                if waitinglog is not None:  # 引数 waitinglog が指定されている場合、区切り線を最適化
                    # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログをログテキストエリアに反映する際の区切り線
                    Separator = "──────── ↑ 進捗率表示中のログ" + self.LF if waitinglog == "start" else Separator
                    # ログテキストエリアに進捗率を表示中に、同じログテキストエリアに追加を試みられたログをログテキストエリアに反映した際の区切り線
                    Separator = "──────── ↓ 進捗率表示中のログ" + self.LF if waitinglog == "end" else Separator

                LogText.moveCursor(QTextCursor.Start)  # ログテキストエリア（QTextEdit）の先頭にカーソルを移動
                LogText.insertPlainText(Separator)  # 区切り線をログテキストエリア（QTextEdit）に挿入

                # ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数に区切り線を追加
                # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性から LogSegment を取得
                LogSegment = getattr(self, "LogSegment_{0}".format(str(CallNum)), None)
                LogSegment = Separator + LogSegment  # 区切り線を LogSegment に追加（新しいものを先頭に追加）

                # 区切り線の個数の加算（後続のログ削除処理のため）
                # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性から SeparatorCount を取得
                SeparatorCount = getattr(self, "SeparatorCount_{0}".format(str(CallNum)), None)
                SeparatorCount += 1  # 区切り線の個数の加算
                setattr(self, "SeparatorCount_{0}".format(str(CallNum)), SeparatorCount)  # 更新された SeparatorCount を元の属性に保存

                # 今回の区切り線が前回に続くものである場合、前回以前の区切り線のインデックスに増加分インデックスを加算して更新
                # 及び区切り線のインデックスリストに今回のものを追加
                # 及びログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数をクリア
                UpdateSeparatorIndexes(CallNum, LogSegment)  # 補助関数で処理
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        """ self.LogSeparator() の記述 """
        if SpecialCall:  # 関数 self.LogCount() からのログ削除処理のための呼び出しの場合
            # ログテキストの特定の区切り線のインデックス計算用にログセグメントを保持する変数を取得
            # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性から LogSegment を取得
            LogSegment = getattr(self, "LogSegment_{0}".format(str(CallNum)), None)
            # ログテキストに特定の区切り線が存在する場合、区切り線のインデックスに増加分インデックスを加算して更新
            return UpdateSeparatorIndexes(CallNum, LogSegment, SpecialCall)  # 処理結果を示す bool 値を返す

        if waitinglog is not None:  # 通常のログテキストエリアに区切り線を挿入する場合（特定の区切り線）で、引数 waitinglog が指定されている場合
            InsertSpecificSeparator(CallNum, waitinglog)  # 補助関数で処理（関数呼び出し元のロックのコンテキスト）
            return  # 処理を終了

        EngineNum = IntegrationOfThreadIDtoEngineNum(CallNum) if CallNum > 5 else CallNum  # 必要に応じて CallNum をエンジン番号に変換
        # EngineNum に対応する属性名を設定及びクラス（self）属性の対応する属性からロックメカニズムのインスタンスを取得
        QMutex = getattr(self, "QMutex_{0}".format(str(EngineNum)), None)
        with QMutexLocker(QMutex):  # ロックを取得（ブロックを抜けるまで CallNum に紐づくクラス（self）属性へのアクセスはロックされる）
            if not processlog and not backlog:  # 通常のログテキストエリアに区切り線を挿入する場合（特定の区切り線）
                InsertSpecificSeparator(CallNum)  # 補助関数で処理（この関数のロックのコンテキスト）
            elif processlog:  # 処理待ちログに区切り線を挿入する場合
                # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性から ProcessLog を取得
                ProcessLog = getattr(self, "ProcessLog_{0}".format(str(CallNum)), None)
                if not ProcessLog.split(self.LF, 1)[0] == "────────":  # ログの最初の行が区切り線でない場合、区切り線を挿入
                    ProcessLog = "────────" + self.LF + ProcessLog  # 区切り線を ProcessLog に追加（新しいものを先頭に追加）
                    setattr(self, "ProcessLog_{0}".format(str(CallNum)), ProcessLog)  # 更新された ProcessLog を元の属性に保存
            elif backlog:  # バックログに区切り線を挿入する場合
                # CallNum に対応する属性名を設定及びクラス（self）属性の対応する属性から BackLog を取得
                BackLog = getattr(self, "BackLog_{0}".format(str(CallNum)), None)
                if not BackLog.split(self.LF, 1)[0] == "────────":  # ログの最初の行が区切り線でない場合、区切り線を挿入
                    BackLog = "────────" + self.LF + BackLog  # 区切り線を BackLog に追加（新しいものを先頭に追加）
                    setattr(self, "BackLog_{0}".format(str(CallNum)), BackLog)  # 更新された BackLog を元の属性に保存
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

# メインのアプリケーションクラス
class AppClass(QtWidgets.QMainWindow):  # QMainWindow を継承
    """ この部分を「クラスの docstring」と言います。
    このクラスは、アプリケーションのウィンドウとその機能を管理する役割を持つ、アプリケーションの根源的なクラスです。このクラスでは他のクラスで使用される様々な変数
    を定義しており、これによってアプリケーションの設定をこのクラスで集中管理することを可能としています。設定値を記録する変数は定数と呼ばれますが、このクラス内では
    便宜的に全て変数という呼称で統一しています。このクラスではアプリケーションの動作に必要な他のクラスのインスタンスの作成及び設定を行い、インスタンス作成時にこの
    クラスのインスタンス self を渡しています。他の全てのクラスでは、初期化時にこの self を self.App として自身の属性に定義し、これを通じて
    self.App.SomeVariable のようにしてこのクラスで定義する設定値にアクセスすることができます（self.App は任意の名前に変更可能ですが、このアプリケーション
    では App で統一しています）。またこのクラスはアプリケーションの根源的なクラスであることから、アプリケーションウィンドウに表示する GUI ウィジェットの定義も
    行います。これらの GUI ウィジェットにはメインスレッド（Qt イベントループ）からのみアクセス可能で、ユーザーインタラクションに対するレスポンスは全て
    メインスレッドを通じて行います。このアプリケーションでは、メインスレッドの機能管理は全て、クラス MainThreadFunctionsClass に一任しています。一方で、
    メインスレッドでは GUI 操作以外のデータ処理などは行わないことが推奨されています。これは、仮にメインスレッドが大規模なデータセットに対して処理を開始した場合、
    メインスレッドはその処理に専念し、ユーザーインタラクションに対するレスポンスを行えなくなってしまい、結果的に表面上「応答なし（フリーズ）」状態になってしまう
    ためです。このアプリケーションではログテキストエリアにシステムログを限りなくリアルタイムに近い形で表示するため、ユーザーはアプリケーションが「応答なし
    （フリーズ）」状態になっているわけではないと認識することができますが、この状態はデータセットに対する処理が完了するまで続き、それまではアプリケーションは応答
    しなくなるため、ユーザーエクスペリエンスを著しく損ないます。このため、このアプリケーションはデータ処理などの GUI 操作を伴わない処理は、全てバックグラウンド
    スレッド（非同期スレッド）で行うように設計されています。そしてメインスレッドと同じく、バックグラウンドスレッドの機能管理は全て、クラス
    SubThreadFunctionsClass に一任しています。このクラスの初期化は、メインスレッド、即ち MainThreadFunctionsClass のコンストラクタ内で行われます。従って
    この AppClass 内では直接的にはバックグラウンドスレッドの初期化は行いませんが、初期化の順序はシーケンシャルなため、階層を辿ればこのクラスに行き着きます
    （しかし、これは実際のクラス間の構造が初期化順序に従うことを意味するものではありません）。また、MainThreadFunctionsClass は SubThreadFunctionsClass
    の初期化時に self.App を渡すため、SubThreadFunctionsClass も AppClass の変数（属性）を使用可能です。SubThreadFunctionsClass の初期化は
    MainThreadFunctionsClass が行いますが、AppClass の変数（属性）には他のクラスと同様に self.App.SomeVariable のようにしてアクセスすることができます。
    これは、同クラスが初期化時に self.App を受け取っているためです。このアプリケーションには他にもクラスが存在しますが、それらの初期化も同じ手順で
    MainThreadFunctionsClass が行います（ただし、DisplayClass は AppClass が初期化します）。
    """
    # AppClass を初期化する関数（コンストラクタ）
    def __init__(self):
        """ この部分を「関数の docstring」と言います。
        AppClass を初期化する関数。

        この初期化関数は、AppClass の新しいインスタンスを作成します。インスタンス作成時、アプリケーションに必要な全てのコンポーネントを初期化します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        # QMainWindow の初期化
        super(AppClass, self).__init__()  # AppClass は最上位クラスなため、parent は省略（デフォルト値：None）

        self.setWindowTitle("bitBuyer 0.8.1.a")  # ウィンドウタイトルの設定
        self.setFixedSize(1100, 810)  # ウィンドウサイズの設定

        WindowSize = self.geometry()  # ウィンドウサイズとディスプレイの解像度を取得
        # デスクトップの現在のスクリーンの矩形から中心の X 座標を取得
        ScreenCenter_X = QtWidgets.QApplication.desktop().screen().rect().center().x()
        # デスクトップの現在のスクリーンの矩形から中心の Y 座標を取得
        ScreenCenter_Y = QtWidgets.QApplication.desktop().screen().rect().center().y()
        self.move(ScreenCenter_X - WindowSize.width() // 2, ScreenCenter_Y - WindowSize.height() // 2)  # ウィンドウを画面中央に配置

        self.Init_NAMES()  # 変数を初期化
        self.Init_GUI()  # GUI を初期化

        # DisplayClass のインスタンスを作成
        try:  # エラーを検出するブロック
            self.LogManager.InsertLOG("Display クラス：インスタンス作成開始", self.一般)
            self.Display = DisplayClass(AppInstance = self)  # AppClass のインスタンス self を渡す
            self.LogManager.InsertLOG("Display クラス：インスタンス作成完了", self.一般)
        except Exception as e:  # 何らかのエラーが発生した場合
            self.Display = None  # DisplayClass のインスタンスを格納する予定だった属性に None を代入
            self.LogManager.InsertLOG("Display クラス：インスタンス作成失敗「{0}」".format(str(e)), self.一般)

        # MainThreadFunctionsClass のインスタンスを作成
        try:  # エラーを検出するブロック
            self.LogManager.InsertLOG("Functions クラス：インスタンス作成開始", self.一般)
            self.MainFunctions = MainThreadFunctionsClass(AppInstance = self)  # AppClass のインスタンス self を渡す
            self.LogManager.InsertLOG("Functions クラス：インスタンス作成完了", self.一般)
        except Exception as e:  # 何らかのエラーが発生した場合
            self.MainFunctions = None  # MainThreadFunctionsClass のインスタンスを格納する予定だった属性に None を代入
            self.LogManager.InsertLOG("Functions クラス：インスタンス作成失敗「{0}」".format(str(e)), self.一般)

        # DisplayClass または MainThreadFunctionsClass のインスタンス作成に失敗している場合
        if self.Display is None or self.MainFunctions is None:
            self.ShowMessage_ofAppInitializingError(str(e))  # エラー内容を表示するメッセージボックスを表示
            raise  # アプリケーションを正常に起動できないため、再度例外を発生させてアプリケーションの起動を停止

        # MainThreadFunctionsClass のシグナルを SubThreadFunctionsClass のスロットに接続
        # （ユーザーの GUI 操作によってテストエンジン SubFunctions[0] をトリガーするための接続）
        self.MainFunctions.PathTestSignal.connect(self.MainFunctions.SubFunctions[0].ExtractAndFormatData)
        # MainThreadFunctionsClass のシグナルを TaskMonitoringThreadClass のスロットに接続
        # （ユーザーの GUI 操作によってタスクが開始または終了したことを TaskMonitoringThreadClass に通知するための接続）
        self.MainFunctions.AddTaskSignal.connect(self.MainFunctions.TaskMonitoring.AddTask)
        self.MainFunctions.TaskCompletedSignal.connect(self.MainFunctions.TaskMonitoring.TaskCompleted)
        # 0 から 5 までのイテレーション（バックグラウンドスレッド六つ分）
        for ThreadID in range(6):  # エンジンをマルチスレッド化する場合は range の設定値を変更する
            # SubThreadFunctionsClass のシグナルを TaskMonitoringThreadClass のスロットに接続
            # （エンジンが自動的にタスクを開始または終了したことを TaskMonitoringThreadClass に通知するための接続）
            self.MainFunctions.SubFunctions[ThreadID].TaskStartedSignal.connect(self.MainFunctions.TaskMonitoring.AddTask)
            self.MainFunctions.SubFunctions[ThreadID].TaskCompletedSignal_2.connect(self.MainFunctions.TaskMonitoring.TaskCompleted)

        self.Init_FUNCTIONS()  # GUI に関数を設定

        self.MainFunctions.LoadProcessor()  # メインフレーム「設定」タブの設定を読み込み

        self.AppInitialized = True  # 初期化完了のフラグを設定
        self.LogManager.InsertLOG("アプリケーション初期化：完了", self.一般)
        self.LogManager.LogSeparator(self.一般)

        # メインフレーム「設定」タブの読み込まれた設定に基づいて、同タブの各「接続先」タブの状態を最適化
        self.LogManager.InsertLOG("読み込まれた設定値に基づく最適化：開始", self.一般)
        self.LogManager.LogSeparator(self.一般)
        for TabNum in range(1, self.Settings_TabCount + 1):  # メインフレーム「設定」タブの各「接続先」タブのためのイテレーション
            # TabNum に対応する属性名を設定及びクラス（self）属性の対応する属性から Exchange_Pull を取得
            self.Exchange_Pull = getattr(self, "Exchange_Pull_{0}".format(str(TabNum)), None)
            # self.Exchange_Pull の状態に基づいてアプリケーションを最適化
            self.MainFunctions.Trace_ExchangePull(self.Exchange_Pull, Trace = True, TabNum = TabNum)
        self.LogManager.InsertLOG("読み込まれた設定値に基づく最適化：完了", self.一般)
        self.LogManager.LogSeparator(self.一般)

        self.show()  # 最終的なウィンドウ設定
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # アプリケーションの動作に必要な、根幹的な各種変数を初期化する関数
    def Init_NAMES(self):
        """ この部分を「関数の docstring」と言います。
        アプリケーションの動作に必要な、根幹的な各種変数を初期化する関数。

        この関数は、アプリケーションの基本的な振る舞いを決定する各種変数を初期化します。この関数にはアプリケーションの設定とも言える各種変数の定義が集約されて
        おり、その値を調整することで、アプリケーションの振る舞いを調整することが可能です。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        ###############################################################
        # ### AppClass と MainThreadFunctionsClass で使用する変数を定義 ###
        ###############################################################

        # 接続先編集フォームの内部名と表示名、及び接続先データのキャッシュファイルにおけるデータパスを配列化するための配列を定義
        # （格納されている値は self.Connections の DisplayName に相当）
        self.ConnectionsPreset = [
            (0, "接続先名", "接続先名", ""), (1, "接続先URL", "接続先 URL", "domain"),
            "約定履歴取得", "Ticker 取得", "板情報取得", "板の状態取得", "アカウント情報取得", "資産残高取得", "証拠金の状態取得", "新規注文",
            "注文取消", "全注文取消", "注文一覧取得", "建玉一覧取得", "取引手数料取得",]

        # 接続先編集フォームの内部名と表示名、及び接続先データのキャッシュファイルにおけるデータパスを配列化
        self.Connections = []  # リストとして定義
        self.Connections = self.ConnectionsPreset[:2]  # self.ConnectionsPreset の一つ目と二つ目の要素をそのままリストに追加
        # self.ConnectionsPreset の三つ目以降の要素を取り出すイテレーション
        for i, DisplayName in enumerate(self.ConnectionsPreset[2:], start = 2):
            InternalName = DisplayName.replace(" ", "")  # DisplayName に半角空白が含まれている場合、除去
            # 接続先 API のエンドポイントのパスの内部名と表示名、及び接続先データのキャッシュファイルにおけるデータパスを定義
            self.Connections.append((i, "{0}_path".format(str(InternalName)), "{0}のパス".format(str(DisplayName)),
                "endpoints.{0}.path".format(str(InternalName))))
            # 接続先 API のエンドポイントのメソッドの内部名と表示名、及び接続先データのキャッシュファイルにおけるデータパスを定義
            self.Connections.append((i, "{0}_method".format(str(InternalName)), "同メソッド：",
                "endpoints.{0}.method".format(str(InternalName))))
            # 接続先 API のエンドポイントのパラメータの内部名と表示名、及び接続先データのキャッシュファイルにおけるデータパスを定義
            self.Connections.append((i, "{0}_params".format(str(InternalName)), "同パラメータ：",
                "endpoints.{0}.params".format(str(InternalName))))
            # 接続先 API のエンドポイントのデータパスの内部名と表示名、及び接続先データのキャッシュファイルにおけるデータパスを定義
            self.Connections.append((i, "{0}_DataPaths".format(str(InternalName)), "同データパス：",
                "endpoints.{0}.DataPaths".format(str(InternalName))))
            # 接続先 API のエンドポイントの JSON サンプルの内部名と表示名、及び接続先データのキャッシュファイルにおけるデータパスを定義
            self.Connections.append((i, "{0}_sample".format(str(InternalName)), "JSON サンプル：",
                "endpoints.{0}.sample".format(str(InternalName))))
            # 接続先 API のエンドポイントの "データパスをテスト" ボタンの内部名と表示名、及び接続先データのキャッシュファイルにおけるデータパスを定義
            self.Connections.append((i, "{0}_pathtest".format(str(InternalName)), "データパスをテスト", ""))

        self.Settings_TabCount = 5  # メインフレーム「設定」タブ内のタブの数を設定する変数を定義

        ####################################
        # ### AppClass で使用する変数を定義 ###
        ####################################

        # カスタムスタイルの設定
        self.CharClr = "#FFFFFF"  # スタイル定義における文字色
        self.BgClr = "#20282F"  # スタイル定義における背景色
        self.HeadBg = "#14181D"  # ヘッダーのスタイル定義における背景色
        self.TextBg = "#32363D"  # テキストエリア（QTextEdit）のスタイル定義における背景色
        self.LabelSpacing = 10  # ラベル（QLabel）のレイアウト定義内のメソッド "setSpacing()" の定数
        self.LabelMrgn = "0px 0px 0px 0px"  # ラベル（QLabel）のスタイル定義内のプロパティ "margin" の定数
        self.LabelPadd = "0px 0px 0px 0px"  # ラベル（QLabel）のスタイル定義内のプロパティ "padding" の定数
        self.EntryMrgn = "0px 0px 0px 0px"  # テキスト入力欄（QLineEdit）のスタイル定義内のプロパティ "margin" の定数
        self.EntryPadd = "2px 0px 2px 0px"  # テキスト入力欄（QLineEdit）のスタイル定義内のプロパティ "padding" の定数
        self.BrdrClr = self.HeadBg  # 各種ウィジェットのスタイル定義における境界（ボーダー）色
        self.BrdrWidth = "0"  # 各種ウィジェットのスタイル定義における境界（ボーダー）の幅
        self.BrdrRadius = "5"  # 各種ウィジェットのスタイル定義における境界（ボーダー）の角の丸みの半径
        self.BtnClr = "#14181D"  # 通常のボタン（QPushButton）のスタイル定義における背景色
        self.BtnClr_on = "#303845"  # 通常のボタン（QPushButton）のスタイル定義におけるマウスホバー時の背景色
        self.BtnClr_prss = "#282F3A"  # 通常のボタン（QPushButton）のスタイル定義におけるクリック時の背景色
        self.BuyBtnClr = "#FFC336"  # ポジティブボタン（QPushButton､「買い」等）のスタイル定義における背景色
        self.BuyBtnClr_on = "#FFB300"  # ポジティブボタン（QPushButton､「買い」等）のスタイル定義におけるマウスホバー時の背景色
        self.BuyBtnClr_prss = "#F4C75D"  # ポジティブボタン（QPushButton､「買い」等）のスタイル定義におけるクリック時の背景色
        self.SellBtnClr = "#EF664C"  # ネガティブボタン（QPushButton､「売り」等）のスタイル定義における背景色
        self.SellBtnClr_on = "#EC5232"  # ネガティブボタン（QPushButton､「売り」等）のスタイル定義におけるマウスホバー時の背景色
        self.SellBtnClr_prss = "#EA7B65"  # ネガティブボタン（QPushButton､「売り」等）のスタイル定義におけるクリック時の背景色
        self.BtnMrgn = "0px 0px 0px 0px"  # 各種ボタン（QPushButton）のスタイル定義内のプロパティ "margin" の定数
        self.BtnPadd = "8px 0px 8px 0px"  # 各種ボタン（QPushButton）のスタイル定義内のプロパティ "padding" の定数
        self.PullHover = self.BgClr  # プルダウンメニュー（QComboBox）のスタイル定義におけるマウスホバー時の背景色
        self.PullMrgn = "0px 0px 0px 0px"  # プルダウンメニュー（QComboBox）のスタイル定義内のプロパティ "margin" の定数
        self.PullPadd = "8px 0px 8px 8px"  # プルダウンメニュー（QComboBox）のスタイル定義内のプロパティ "padding" の定数

        # リサイズ処理の設定・一般（初期化時の初期値、ウィンドウサイズにより動的に更新）
        self.ScrllBarWdth = 35  # スクロールエリア（QScrollArea）のスクロールバーの幅（px、設定値ではなく検証に基づく参考値）
        # リサイズ処理の設定・サブフレーム（初期化時の初期値、ウィンドウサイズにより動的に更新）
        self.LogText_TextWdth = 0  # ログテキストエリア（QTextEdit）のテキスト折り返しまでの幅（px）
        # リサイズ処理の設定・メインフレーム（初期化時の初期値、ウィンドウサイズにより動的に更新）
        self.Manual_TextWdth = 0  # 「使い方」タブのテキストエリア（QTextEdit）のテキスト折り返しまでの幅（px）
        self.EditAccess_EditRow_LblWdth = 0  # 「接続先編集」タブの編集用の各テキスト入力欄またはテキストエリアのラベル（QLabel）の幅（px）
        self.EditAccess_EditRow_EntWdth = 0  # 「接続先編集」タブの編集用の各テキスト入力欄（QLineEdit）の幅（px）
        self.EditAccess_EditRow_TxtWdth = 0  # 「接続先編集」タブの編集用の各テキストエリア（QTextEdit）のテキスト折り返しまでの幅（px）
        self.EditAccess_TextWdth = 0  # 「接続先編集」タブの説明用のテキストエリア（QTextEdit）のテキスト折り返しまでの幅（px）
        self.SetAccess_TextWdth = 0  # 「設定」タブの説明用のテキストエリア（QTextEdit）のテキスト折り返しまでの幅（px）

        # リサイズ処理の設定・サブフレーム（ウィンドウサイズに対する割合）
        self.LogText_TextWght = 0.22  # ログテキストエリア（QTextEdit）のテキスト折り返しまでの幅の割合
        # リサイズ処理の設定・メインフレーム（ウィンドウサイズに対する割合）
        self.Manual_TextWght = 0.72  # 「使い方」タブのテキストエリア（QTextEdit）のテキスト折り返しまでの幅の割合
        self.EditAccess_EditRow_LblWght = 0.13  # 「接続先編集」タブの編集用の各テキスト入力欄またはテキストエリアのラベル（QLabel）の幅の割合
        self.EditAccess_EditRow_EntWght = 0.24  # 「接続先編集」タブの編集用のテキスト入力欄（QLineEdit）の幅の割合
        self.EditAccess_EditRow_TxtWght = 0.22  # 「接続先編集」タブの編集用のテキストエリア（QTextEdit）のテキスト折り返しまでの幅の割合
        self.EditAccess_TextWght = 0.28  # 「接続先編集」タブの説明用のテキストエリア（QTextEdit）のテキスト折り返しまでの幅の割合
        self.SetAccess_TextWght = 0.31  # 「設定」タブの説明用のテキストエリア（QTextEdit）のテキスト折り返しまでの幅の割合

        # スタイルシートの設定
        """
margin など四つの数値を指定する際、スタイルシートでは「上、右、下、左」の順序で指定しますが、PyQt フレームワークの setContentsMargins などのメソッドでは
「左、上、右、下」の順序で指定します。
        """
        # QWidget 用のスタイル定義
        self.WidgetStyle = """
            QWidget {{
                color: {0}; background-color: {1}; border-color: {2};
                border-style: solid; border-width: {3}px; border-radius: {4}px;
            }}
        """.format(str(self.CharClr), str(self.BgClr), str(self.BrdrClr), str(self.BrdrWidth), str(self.BrdrRadius))
        # QFrame 用のスタイル定義
        self.FrameStyle = """
            QFrame {{
                color: {0}; background-color: {1}; border-color: {2};
                border-style: solid; border-width: {3}px; border-radius: {4}px;
            }}
        """.format(str(self.CharClr), str(self.BgClr), str(self.BrdrClr), str(self.BrdrWidth), str(self.BrdrRadius))
        # スクロールエリア（QScrollArea）用のスタイル定義
        self.ScrollStyle = """
            QScrollArea {{
                color: {0}; background-color: {1}; border-color: {2};
                border-style: solid; border-width: {3}px; border-radius: {4}px;
            }}
        """.format(str(self.CharClr), str(self.BgClr), str(self.BrdrClr), str(self.BrdrWidth), str(self.BrdrRadius))
        # テキストエリア（QTextEdit）用のスタイル定義
        self.TextStyle = """
            QTextEdit {{
                color: {0}; background-color: {1}; border-color: {2};
                border-style: solid; border-width: {3}px; border-radius: {4}px;
            }}
        """.format(str(self.CharClr), str(self.TextBg), str(self.BrdrClr), str(self.BrdrWidth), str(self.BrdrRadius))
        # 通常のボタン（QPushButton）用のスタイル定義
        self.BtnStyle = """
            QPushButton {{
                color: {0}; background-color: {1}; border-color: {2};
                border-style: solid; border-width: {3}px; border-radius: {4}px;
                margin: {5}; padding: {6};
            }}
            QPushButton:hover {{
                background-color: {7};
            }}
            QPushButton:pressed {{
                background-color: {8};
            }}
        """.format(str(self.CharClr), str(self.BtnClr), str(self.BrdrClr), str(self.BrdrWidth), str(self.BrdrRadius),
            str(self.BtnMrgn), str(self.BtnPadd), str(self.BtnClr_on), str(self.BtnClr_prss))
        # ポジティブボタン（QPushButton､「買い」等）用のスタイル定義
        self.BuyBtnStyle = """
            QPushButton {{
                color: {0}; background-color: {1}; border-color: {2};
                border-style: solid; border-width: {3}px; border-radius: {4}px;
                margin: {5}; padding: {6};
            }}
            QPushButton:hover {{
                background-color: {7};
            }}
            QPushButton:pressed {{
                background-color: {8};
            }}
        """.format(str(self.CharClr), str(self.BuyBtnClr), str(self.BrdrClr), str(self.BrdrWidth), str(self.BrdrRadius),
            str(self.BtnMrgn), str(self.BtnPadd), str(self.BuyBtnClr_on), str(self.BuyBtnClr_prss))
        # ネガティブボタン（QPushButton､「売り」等）用のスタイル定義
        self.SellBtnStyle = """
            QPushButton {{
                color: {0}; background-color: {1}; border-color: {2};
                border-style: solid; border-width: {3}px; border-radius: {4}px;
                margin: {5}; padding: {6};
            }}
            QPushButton:hover {{
                background-color: {7};
            }}
            QPushButton:pressed {{
                background-color: {8};
            }}
        """.format(str(self.CharClr), str(self.SellBtnClr), str(self.BrdrClr), str(self.BrdrWidth), str(self.BrdrRadius),
            str(self.BtnMrgn), str(self.BtnPadd), str(self.SellBtnClr_on), str(self.SellBtnClr_prss))
        # プルダウンメニュー（QComboBox）用のスタイル定義
        self.PullStyle = """
            QComboBox {{
                color: {0}; background-color: {1}; border-color: {2};
                border-style: solid; border-width: {3}px; border-radius: {4}px;
                margin: {5}; padding: {6};
            }}
            QComboBox QAbstractItemView {{
                background-color: ;
            }}
            QComboBox QAbstractItemView::item:hover {{
                background-color: ;
            }}
        """.format(str(self.CharClr), str(self.BtnClr), str(self.BrdrClr), str(self.BrdrWidth), str(self.BrdrRadius),
            str(self.PullMrgn), str(self.PullPadd))
        # ラベル（QLabel）用のスタイル定義
        self.LabelStyle = """
            QLabel {{
                color: {0}; background-color: {1}; border-color: {2};
                border-style: solid; border-width: {3}px; border-radius: {4}px;
                margin: {5}; padding: {6};
            }}
        """.format(str(self.CharClr), str(self.BgClr), str(self.BrdrClr), str(self.BrdrWidth), str(self.BrdrRadius),
            str(self.LabelMrgn), str(self.LabelPadd))
        # テキスト入力欄（QLineEdit）用のスタイル定義
        self.EntryStyle = """
            QLineEdit {{
                color: {0}; background-color: {1}; border-color: {2};
                border-style: solid; border-width: {3}px; border-radius: {4}px;
                margin: {5}; padding: {6};
            }}
        """.format(str(self.CharClr), str(self.TextBg), str(self.BrdrClr), str(self.BrdrWidth), str(self.BrdrRadius),
            str(self.EntryMrgn), str(self.EntryPadd))

        # サブフレームのタブウィジェット（QTabWidget）の番号と内部名と表示名を配列化
        self.SubFrame_TabNames = [
            ("0", "SubFrameTab_0", "G"), ("1", "SubFrameTab_1", "1"), ("2", "SubFrameTab_2", "2"), ("3", "SubFrameTab_3", "3"),
            ("4", "SubFrameTab_4", "4"), ("5", "SubFrameTab_5", "5"),]

        # メインフレームのタブウィジェット（QTabWidget）の内部名と表示名を配列化
        self.MainFrame_TabNames = [
            ("Tab_1", "使い方"), ("Tab_2", "接続先編集"), ("Tab_3", "設定"), ("Tab_4", "Engine"), ("Tab_5", "利益試算"),]

        # 接続先編集メニューの各種ボタン（QPushButton）の内部名、表示名、スタイルを配列化
        self.EditAccess_Menu_BtnsLabels = [
            ("SaveConnections_btn", "保存", "BuyBtnStyle"), ("DeleteConnections_btn", "この接続先を削除", "SellBtnStyle"),
            ("DeleteAllConnections_btn", "全ての接続先を消去及び復元", "SellBtnStyle"),]

        self.ConnectionLabels = {}  # 接続先編集フォームの全ての QLabel ウィジェットを格納する辞書型配列を定義

        self.ConnectionEntries = {}  # 接続先編集フォームの全ての QLineEdit と QTextEdit ウィジェットを格納する辞書型配列を定義

        self.ConnectionBtns = {}  # 接続先編集フォームの全ての QPushButton ウィジェットを格納する辞書型配列を定義

        # API キー設定関連ボタンの内部名、表示名、スタイルを配列化
        self.APIkey_BtnLabels = [
            ("ShowKeysBtn", "キーを表示", "BtnStyle"), ("ManageKeysBtn", "キーを登録", "BuyBtnStyle"),
            ("TestAccessBtn", "接続テスト", "BtnStyle"), ("ClearKeysBtn", "キーを削除", "SellBtnStyle"),]

        ####################################################
        # ### MainThreadFunctionsClass で使用する変数を定義 ###
        ####################################################

        self.AppInitialized = False  # アプリケーションの初期化が完了しているかを示すフラグ変数を定義

        self.BtnCmd = ""  # ボタン操作時の各種処理を制御するフラグ変数を定義

        self.SaveProhibited = False  # 特定の状況で関数 self.MainFunctions.SaveProcessor() の処理を不許可にするフラグ変数を定義

        # デフォルトの接続先データを定義
        self.DefConnections = {
            "bitbank": {
                "domain": "null",
                "endpoints": {
                    "約定履歴取得": {
                        "path": "https://public.bitbank.cc/[商品]/transactions/[年月日]", "method": "GET",
                        "params": "商品 年月日", "DataPaths": (
                            "買い/data.transactions.[index].side:buy 売り/data.transactions.[index].side:sell "
                            "価格/data.transactions.[index].price 数量/data.transactions.[index].amount "
                            "日時/data.transactions.[index].executed_at:UnixTime"),
                        "sample": {"success": 1, "data": {"transactions": [
                            {"transaction_id": 0, "side": "buy", "price": 1000000, "amount": 1.0, "executed_at": 1643803200},
                            {"transaction_id": 1, "side": "sell", "price": 2000000, "amount": 2.0, "executed_at": 1643889600},
                            {"transaction_id": 2, "side": "buy", "price": 3000000, "amount": 3.0, "executed_at": 1643976000},
                            {"transaction_id": 3, "side": "sell", "price": 4000000, "amount": 4.0, "executed_at": 1644062400}]}},
                    }, "Ticker取得": {
                        "path": "https://public.bitbank.cc/[商品]/ticker", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "商品/null 日時/data.timestamp:UnixTime TickID/null 買高値/data.buy 売安値/data.sell "
                            "買高値数量/null 売安値数量/null 買深度/null 売深度/null "
                            "買付可能注文量/null 売付可能注文量/null 最終取引価格/data.last 一日取引量/data.vol"),
                        "sample": {"success": 1, "data": {"sell": 1000000, "buy": 2000000, "high": 2000000, "low": 1000000,
                            "open": 1000001, "last": 1999999, "vol": 500, "timestamp": 1643803200}},
                    }, "板情報取得": {
                        "path": "https://public.bitbank.cc/[商品]/depth", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "仲値/null "
                            "買い価格/data.bids.[index].0 買い数量/data.bids.[index].1 "
                            "売り価格/data.asks.[index].0 売り数量/data.asks.[index].1"),
                        "sample": {"success": 1, "data": {"asks": [[6300000, 0.8], [6350000, 1.2]],
                            "bids": [[6200000, 1.5], [6250000, 2.0]], "asks_over": 6400000, "bids_under": 6100000,
                            "asks_under": 6200000, "bids_over": 6300000, "timestamp": 1609459200, "sequenceId": 12345}},
                    }, "板の状態取得": {
                        "path": "https://api.bitbank.cc/v1/spot/status", "method": "GET",
                        "params": "なし", "DataPaths": (
                            "商品/data.statuses.[index].pair "
                            "取引所稼働/data.statuses.[index].status:NORMAL,BUSY 取引所高負荷/data.statuses.[index].status:VERY_BUSY "
                            "取引所非稼働/data.statuses.[index].status:HALT 板稼働/null 板非稼働/null "
                            "最小注文数量/data.statuses.[index].min_amount"),
                        "sample": {"success": 1, "data": {"statuses": [{"pair": "btc_usd", "status": "NORMAL", "min_amount": 0.001},
                            {"pair": "eth_usd", "status": "BUSY", "min_amount": 0.01},
                            {"pair": "ltc_usd", "status": "VERY_BUSY", "min_amount": 0.1},
                            {"pair": "xrp_usd", "status": "HALT", "min_amount": 1.0}]}},
                    }, "アカウント情報取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": ("アカウントID/null"),
                        "sample": "null",
                    }, "資産残高取得": {
                        "path": "https://api.bitbank.cc/v1/user/assets", "method": "GET",
                        "params": "なし", "DataPaths": (
                            "通貨/data.assets.[index].asset 数量/data.assets.[index].onhand_amount "
                            "可処分/data.assets.[index].free_amount"),
                        "sample": {"success": 1, "data": {"assets": [{
                            "asset": "btc", "free_amount": 0.5, "amount_precision": 8, "onhand_amount": 1.5, "locked_amount": 1.0,
                            "withdrawal_fee": {
                                "min": 0.0005, "max": 0.001}, "stop_deposit": "false", "stop_withdrawal": "false", "network_list": [
                                {"asset": "btc", "network": "bitcoin", "stop_deposit": "false", "stop_withdrawal": "false",
                                "withdrawal_fee": 0.0005},
                                {"asset": "btc", "network": "lightning", "stop_deposit": "true", "stop_withdrawal": "false",
                                "withdrawal_fee": 0.0001}]},
                                {"asset": "eth", "free_amount": 10, "amount_precision": 18, "onhand_amount": 20, "locked_amount": 10,
                                "withdrawal_fee": {
                                    "under": 0.01, "over": 0.02, "threshold": 1}, "stop_deposit": "false", "stop_withdrawal": "true"},
                                {"asset": "jpy", "free_amount": 100000, "amount_precision": 0, "onhand_amount": 200000,
                                "locked_amount": 100000, "withdrawal_fee": {
                                    "under": 100, "over": 200, "threshold": 50000}, "stop_deposit": "true",
                                    "stop_withdrawal": "false"}]}},
                    }, "証拠金の状態取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": (
                            "預入証拠金/null 建玉評価損益/null 必要証拠金/null 維持率/null "
                            "追証なし/null 追証中/null 強制追証/null 追証額/null 追証期限/null"),
                        "sample": "null",
                    }, "新規注文": {
                        "path": "https://api.bitbank.cc/v1/user/spot/order", "method": "POST",
                        "params": "商品 数量 価格 方向 種別 他省略", "DataPaths": (
                            "成功/success:1 失敗/success!:1 注文ID/data.order_id"),
                        "sample": {"success": 1, "data": {"order_id": 123456, "pair": "btc_usd", "side": "buy", "type": "limit",
                            "start_amount": 0.5, "remaining_amount": 0.5, "executed_amount": 0.0, "price": 6000000,
                            "post_only": "false", "average_price": 0.0, "ordered_at": 1609459200000, "expire_at": "null",
                            "triggered_at": "null", "trigger_price": "null", "status": "UNFILLED"}},
                    }, "注文取消": {
                        "path": "https://api.bitbank.cc/v1/user/spot/cancel_order", "method": "POST",
                        "params": "商品 注文ID", "DataPaths": ("成功/success:1 失敗/success!:1"),
                        "sample": {"success": 1, "data": {"order_id": 0, "pair": "btc_usd", "side": "buy", "type": "limit",
                            "start_amount": 1.0, "remaining_amount": 0.5, "executed_amount": 0.5, "price": 6000000,
                            "post_only": "false", "average_price": 6050000, "ordered_at": 1609459200000, "expire_at": 1612137600000,
                            "canceled_at": 0, "triggered_at": 0, "trigger_price": 6100000, "status": "PARTIALLY_FILLED"}},
                    }, "全注文取消": {
                        "path": "https://api.bitbank.cc/v1/user/spot/cancel_orders", "method": "POST",
                        "params": "商品 注文IDリスト", "DataPaths": ("成功/success:1 失敗/success!:1 取消注文ID/null"),
                        "sample": {"success": 1, "data": {"orders": [
                            {"order_id": 0, "pair": "btc_usd", "side": "buy", "type": "limit", "start_amount": 1.0,
                            "remaining_amount": 0.5, "executed_amount": 0.5, "price": 6000000, "post_only": "false",
                            "average_price": 6050000, "ordered_at": 1609459200000, "expire_at": 1612137600000, "canceled_at": 0,
                            "triggered_at": 0, "trigger_price": 6100000, "status": "PARTIALLY_FILLED"},
                            {"order_id": 1, "pair": "eth_usd", "side": "sell", "type": "market", "start_amount": 2.0,
                            "remaining_amount": 1.0, "executed_amount": 1.0, "price": 400000, "post_only": "false",
                            "average_price": 405000,"ordered_at": 1609562800000, "expire_at": 1612241200000, "canceled_at": 0,
                            "triggered_at": 0, "trigger_price": "null", "status": "UNFILLED"}]}},
                    }, "注文一覧取得": {
                        "path": "https://api.bitbank.cc/v1/user/spot/active_orders", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "注文ID/data.orders.[index].order_id 商品/data.orders.[index].pair "
                            "買い/data.orders.[index].side:buy 売り/data.orders.[index].side:sell "
                            "指値/data.orders.[index].type:limit 成行/data.orders.[index].type:market "
                            "逆指値/data.orders.[index].type:stop_limit 逆成行/data.orders.[index].type:stop "
                            "価格/data.orders.[index].price 平均価格/data.orders.[index].average_price "
                            "数量/data.orders.[index].start_amount 有効注文/data.orders.[index].status:UNFILLED,PARTIALLY_FILLED "
                            "完了注文/data.orders.[index].status:FULLY_FILLED "
                            "取消注文/data.orders.[index].status:CANCELED_UNFILLED,CANCELED_PARTIALLY_FILLED 期限切れ注文/null "
                            "失敗注文/null 有効期限/data.orders.[index].expire_at 注文日時/data.orders.[index].ordered_at:UnixTime "
                            "注文受付ID/null 未決済数量/data.orders.[index].remaining_amount 決済数量/data.orders.[index].executed_amount "
                            "取消数量/null 手数料/null"),
                        "sample": {"success": 1, "data": {"orders": [
                            {"order_id": 0, "pair": "btc_usd", "side": "buy", "type": "limit", "start_amount": 1.0,
                            "remaining_amount": 0.5, "executed_amount": 0.5, "price": 6000000, "post_only": "false",
                            "average_price": 6050000, "ordered_at": 1643803200, "expire_at": 1612137600000, "executed_at": "undefined",
                            "canceled_at": 0, "triggered_at": "undefined", "trigger_price": "undefined", "status": "PARTIALLY_FILLED"},
                            {"order_id": 1, "pair": "eth_usd", "side": "sell", "type": "market", "start_amount": 2.0,
                            "remaining_amount": 1.0, "executed_amount": 1.0, "price": "undefined", "post_only": "undefined",
                            "average_price": 405000, "ordered_at": 1643889600, "expire_at": 1612241200000, "executed_at": 1609566400000,
                            "canceled_at": "undefined", "triggered_at": "undefined", "trigger_price": "undefined",
                            "status": "UNFILLED"}]}},
                    }, "建玉一覧取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": (
                            "商品/null 買い/null 売り/null 価格/null 数量/null 手数料/null スワップポイント/null "
                            "必要証拠金/null 注文日時/null 約定日時/null レバレッジ/null 評価損益/null SFD比率/null"),
                        "sample": "null",
                    }, "取引手数料取得": {
                        "path": "https://api.bitbank.cc/v1/spot/pairs", "method": "GET",
                        "params": "なし", "DataPaths": (
                            "商品/data.pairs.[index].name 手数料率TakerBase/data.pairs.[index].taker_fee_rate_base "
                            "手数料率TakerQuote/data.pairs.[index].taker_fee_rate_quote "
                            "手数料率MakerBase/data.pairs.[index].maker_fee_rate_base "
                            "手数料率MakerQuote/data.pairs.[index].maker_fee_rate_quote"),
                        "sample": {"success": 1, "data": {"pairs": [{"name": "btc_usd", "base_asset": "btc",
                            "maker_fee_rate_base": 0.001, "taker_fee_rate_base": 0.002, "maker_fee_rate_quote": 0.0015,
                            "taker_fee_rate_quote": 0.0025, "unit_amount": 0.0001, "limit_max_amount": 100, "market_max_amount": 50,
                            "market_allowance_rate": 0.1, "price_digits": 2, "amount_digits": 4, "is_enabled": "true",
                            "stop_order": "false", "stop_order_and_cancel": "true", "stop_market_order": "false",
                            "stop_stop_order": "true", "stop_stop_limit_order": "false", "stop_buy_order": "false",
                            "stop_sell_order": "true"}]}},
                    },
                },
            },
            "bitFlyer": {
                "domain": "https://api.bitflyer.com",
                "endpoints": {
                    "約定履歴取得": {
                        "path": "/v1/getexecutions", "method": "GET",
                        "params": "商品 ページ", "DataPaths": (
                            "買い/[index].side:BUY 売り/[index].side:SELL 価格/[index].price "
                            "数量/[index].size 日時/[index].exec_date:LocalTime"),
                        "sample": [
                            {"id": 39287, "side": "BUY", "price": 31690, "size": 27.04, "exec_date": "2015-07-08T02:43:34.823",
                            "buy_child_order_acceptance_id": "JRF20150707-200203-452209",
                            "sell_child_order_acceptance_id": "JRF20150708-024334-060234"},
                            {"id": 39286, "side": "SELL", "price": 33170, "size": 0.36, "exec_date": "2015-07-08T02:43:34.72",
                            "buy_child_order_acceptance_id": "JRF20150708-010230-400876",
                            "sell_child_order_acceptance_id": "JRF20150708-024334-197755"},
                            {"id": "39285", "side": "BUY", "price": "32000", "size": "5.5", "exec_date": "2015-07-08T02:45:00.123",
                            "buy_child_order_acceptance_id": "JRF20150708-024500-123456",
                            "sell_child_order_acceptance_id": "JRF20150708-024500-654321"},
                            {"id": "39284", "side": "SELL", "price": "33500", "size": "1.2", "exec_date": "2015-07-08T02:46:10.456",
                            "buy_child_order_acceptance_id": "JRF20150708-020000-987654",
                            "sell_child_order_acceptance_id": "JRF20150708-024610-456789"}],
                    }, "Ticker取得": {
                        "path": "/v1/getticker", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "商品/product_code 日時/timestamp:TimeZoneUTC TickID/tick_id 買高値/best_bid 売安値/best_ask "
                            "買高値数量/best_bid_size 売安値数量/best_ask_size 買深度/total_bid_depth 売深度/total_ask_depth "
                            "買付可能注文量/market_bid_size 売付可能注文量/market_ask_size 最終取引価格/ltp 一日取引量/volume_by_product"),
                        "sample": {"product_code": "BTC_JPY", "state": "RUNNING", "timestamp": "2015-07-08T02:50:59.97",
                            "tick_id": 3579, "best_bid": 30000, "best_ask": 36640, "best_bid_size": 0.1, "best_ask_size": 5,
                            "total_bid_depth": 15.13, "total_ask_depth": 20, "market_bid_size": 0, "market_ask_size": 0, "ltp": 31690,
                            "volume": 16819.26, "volume_by_product": 6819.26},
                    }, "板情報取得": {
                        "path": "/v1/getboard", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "仲値/mid_price "
                            "買い価格/bids.[index].price 買い数量/bids.[index].size 売り価格/asks.[index].price 売り数量/asks.[index].size"),
                        "sample": {"mid_price": 33320,
                            "bids": [{"price": 30000, "size": 0.1},{"price": 25570, "size": 3},{"price": 25000, "size": 2},
                                {"price": 24500, "size": 4.5}],
                            "asks": [{"price": 36640, "size": 5},{"price": 36700, "size": 1.2},{"price": 36800, "size": 2.5},
                                {"price": 36900,"size": 1.8}]},
                    }, "板の状態取得": {
                        "path": "/v1/getboardstate", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "商品/null 取引所稼働/health:NORMAL,BUSY,VERY_BUSY 取引所高負荷/health:SUPER_BUSY "
                            "取引所非稼働/health:NO_ORDER,STOP 板稼働/state:RUNNING "
                            "板非稼働/state:CLOSED,STARTING,PREOPEN,CIRCUIT_BREAK,AWAITING_SQ,MATURED 最小注文数量/null"),
                        "sample": {"health": "NORMAL", "state": "RUNNING",},
                    }, "アカウント情報取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": ("アカウントID/null"),
                        "sample": "null",
                    }, "資産残高取得": {
                        "path": "/v1/me/getbalance", "method": "GET",
                        "params": "なし", "DataPaths": ("通貨/[index].currency_code 数量/[index].amount 可処分/[index].available"),
                        "sample": [{"currency_code": "JPY", "amount": 1024078, "available": 508000},
                            {"currency_code": "BTC", "amount": 10.24, "available": 4.12},
                            {"currency_code": "ETH", "amount": 20.48, "available": 16.38}],
                    }, "証拠金の状態取得": {
                        "path": "/v1/me/getcollateral", "method": "GET",
                        "params": "なし", "DataPaths": (
                            "預入証拠金/collateral 建玉評価損益/open_position_pnl 必要証拠金/require_collateral 維持率/keep_rate "
                            "追証なし/null 追証中/null 強制追証/null 追証額/margin_call_amount 追証期限/margin_call_due_date:LocalTime"),
                        "sample": {"collateral": 100000, "open_position_pnl": -715, "require_collateral": 19857, "keep_rate": 5.000,
                            "margin_call_amount": 1000000, "margin_call_due_date": "2021-09-01T08:00:00"},
                    }, "新規注文": {
                        "path": "/v1/me/sendchildorder", "method": "POST",
                        "params": "商品 種別 方向 価格 数量 他省略", "DataPaths": (
                            "成否/StatusCode 成功/null 失敗/null 注文ID/child_order_acceptance_id"),
                        "sample": {"child_order_acceptance_id": "JRF20150707-050237-639234"},
                    }, "注文取消": {
                        "path": "/v1/me/cancelchildorder", "method": "POST",
                        "params": "商品 注文ID_or_受付ID", "DataPaths": ("成否/StatusCode 成功/null 失敗/null"),
                        "sample": "null",
                    }, "全注文取消": {
                        "path": "/v1/me/cancelallchildorders", "method": "POST",
                        "params": "商品", "DataPaths": ("成否/StatusCode 成功/null 失敗/null 取消注文ID/null"),
                        "sample": "null",
                    }, "注文一覧取得": {
                        "path": "/v1/me/getchildorders", "method": "GET",
                        "params": "商品 ページ 注文状態", "DataPaths": (
                            "注文ID/[index].child_order_id 商品/[index].product_code "
                            "買い/[index].side:BUY 売り/[index].side:SELL 指値/[index].child_order_type:LIMIT "
                            "成行/[index].child_order_type:MARKET 逆指値/null 逆成行/null 価格/[index].price 平均価格/[index].average_price "
                            "数量/[index].size 有効注文/[index].child_order_state:ACTIVE 完了注文/[index].child_order_state:COMPLETED "
                            "取消注文/[index].child_order_state:CANCELED 期限切れ注文/[index].child_order_state:EXPIRED "
                            "失敗注文/[index].child_order_state:REJECTED 有効期限/[index].expire_date "
                            "注文日時/[index].child_order_date:LocalTime 注文受付ID/[index].child_order_acceptance_id "
                            "未決済数量/[index].outstanding_size 決済数量/[index].executed_size 取消数量/[index].cancel_size "
                            "手数料/[index].total_commission"),
                        "sample": [
                            {"id": 138398, "child_order_id": "JOR20150707-084555-022523", "product_code": "BTC_JPY", "side": "BUY",
                            "child_order_type": "LIMIT", "price": 30000, "average_price": 30000, "size": 0.1,
                            "child_order_state": "COMPLETED", "expire_date": "2015-07-14T07:25:52",
                            "child_order_date": "2015-07-07T08:45:53", "child_order_acceptance_id": "JRF20150707-084552-031927",
                            "outstanding_size": 0, "cancel_size": 0, "executed_size": 0.1, "total_commission": 0,
                            "time_in_force": "GTC"},
                            {"id": 138397, "child_order_id": "JOR20150707-084549-022519", "product_code": "BTC_JPY", "side": "SELL",
                            "child_order_type": "LIMIT", "price": 30000, "average_price": 0, "size": 0.1,
                            "child_order_state": "CANCELED", "expire_date": "2015-07-14T07:25:47",
                            "child_order_date": "2015-07-07T08:45:47", "child_order_acceptance_id": "JRF20150707-084547-396699",
                            "outstanding_size": 0, "cancel_size": 0.1, "executed_size": 0, "total_commission": 0,
                            "time_in_force": "GTC"}],
                    }, "建玉一覧取得": {
                        "path": "/v1/me/getpositions", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "商品/[index].product_code 買い/[index].side:BUY 売り/[index].side:SELL 価格/[index].price "
                            "数量/[index].size 手数料/[index].commission スワップポイント/[index].swap_point_accumulate "
                            "必要証拠金/[index].require_collateral 注文日時/[index].open_date:LocalTime 約定日時/null "
                            "レバレッジ/[index].leverage 評価損益/[index].pnl SFD比率/[index].sfd"),
                        "sample": [
                            {"product_code": "FX_BTC_JPY", "side": "BUY", "price": 36000, "size": 10, "commission": 0,
                            "swap_point_accumulate": -35, "require_collateral": 120000, "open_date": "2015-11-03T10:04:45.011",
                            "leverage": 3, "pnl": 965, "sfd": -0.5},
                            {"product_code": "FX_ETH_JPY", "side": "SELL", "price": 25000, "size": 5, "commission": 0,
                            "swap_point_accumulate": -20, "require_collateral": 75000, "open_date": "2015-11-03T11:16:20.123",
                            "leverage": 2, "pnl": -200, "sfd": 0.3},
                            {"product_code": "FX_LTC_JPY", "side": "BUY", "price": 14000, "size": 8, "commission": 0,
                            "swap_point_accumulate": -15, "require_collateral": 56000, "open_date": "2015-11-04T09:30:00.456",
                            "leverage": 4, "pnl": 350, "sfd": -0.2}],
                    }, "取引手数料取得": {
                        "path": "/v1/me/gettradingcommission", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "商品/null 手数料率TakerBase/commission_rate 手数料率TakerQuote/null 手数料率MakerBase/commission_rate "
                            "手数料率MakerQuote/null"),
                        "sample": {"commission_rate": 0.001},
                    },
                },
            },
            "BitTrade": {
                "domain": "https://api-cloud.bittrade.co.jp",
                "endpoints": {
                    "約定履歴取得": {
                        "path": "/market/trade", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "買い/tick.data.[index].direction:buy 売り/tick.data.[index].direction:sell 価格/tick.data.[index].price "
                            "数量/tick.data.[index].amount 日時/tick.data.[index].ts:MilliUnixTime"),
                        "sample": {"ch": "market.ethjpy.trade.detail", "status": "ok", "ts": 1632988377900, "tick": {"id": 100510257146,
                            "ts": 1632988350412, "data": [
                                {"id": 100510257146375980000000000, "ts": 1632988350412, "trade-id": 100030516567, "amount": 0.0016,
                                "price": 335385, "direction": "buy"},
                                {"id": 100510257146375980000000000, "ts": 1632988350412, "trade-id": 100030516566, "amount": 0.0018,
                                "price": 335331, "direction": "sell"},
                                {"id": 100510257146375980000000000, "ts": 1632988350412, "trade-id": 100030516565, "amount": 0.0015,
                                "price": 335307, "direction": "buy"},
                                {"id": 100510257146375980000000000, "ts": 1632988350412, "trade-id": 100030516564, "amount": 0.0014,
                                "price": 335256, "direction": "buy"},
                                {"id": 100510257146375980000000000, "ts": 1632988350412, "trade-id": 100030516563, "amount": 0.0041,
                                "price": 335221, "direction": "sell"}]}},
                    }, "Ticker取得": {
                        "path": "/market/detail/merged", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "商品/ch 日時/ts:UnixTime TickID/tick.id 買高値/tick.bid.0 売安値/tick.ask.0 "
                            "買高値数量/tick.bid.1 売安値数量/tick.ask.1 "
                            "買深度/null 売深度/null 買付可能注文量/null 売付可能注文量/null "
                            "最終取引価格/tick.close 一日取引量/tick.vol"),
                        "sample": {"ch": "market.ethjpy.detail.merged", "status": "ok", "ts": 1643803200, "tick": {
                            "id": 201018141213, "version": 201018141213, "open": 323786, "close": 339349, "low": 312053, "high": 340294,
                            "amount": 9.738126685212897, "vol": 3175875.8505999995, "count": 2424, "bid": [339002, 0.0031],
                            "ask": [339023, 0.0026]}},
                    }, "板情報取得": {
                        "path": "/market/depth", "method": "GET",
                        "params": "商品 グループ", "DataPaths": (
                            "仲値/null "
                            "買い価格/tick.bids.[index].0 買い数量/tick.bids.[index].1 "
                            "売り価格/tick.asks.[index].0 売り数量/tick.asks.[index].1"),
                        "sample": {"ch": "market.btcjpy.depth.step1", "status": "ok", "ts": 1632987521285, "tick": {
                            "bids": [[4860380, 0.0001], [4860100, 0.0001], [4859870, 0.0001], [4859760, 0.0001], [4849550, 1.0044],
                                [4800000, 0.001], [4780000, 0.001], [4771000, 0.5933], [4765400, 1.6756], [4759810, 0.8849],
                                [4754220, 5], [4748620, 0.9396], [4700000, 0.005], [4600000, 0.0043], [4580000, 0.002],
                                [4570000, 0.002], [4550000, 0.002], [4540000, 0.002], [4530000, 0.002], [4520000, 0.002]],
                            "asks": [[4860850, 0.0002], [4861190, 0.0001], [4861380, 0.0001], [4861670, 0.0001], [4861900, 0.0001],
                                [4866190, 0.3783], [4879440, 0.0006], [4900000, 0.1112], [4905000, 0.002], [4910000, 0.01],
                                [4920000, 0.002], [4935000, 0.002], [4950000, 0.0122], [4960000, 0.01], [4970000, 0.01],
                                [4978380, 0.001], [4980000, 0.0001], [4986990, 0.0001], [4988450, 0.0001], [5000000, 0.1042]],
                            "version": 100883718161, "ts": 1632987521070}},
                    }, "板の状態取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": (
                            "商品/null 取引所稼働/null 取引所高負荷/null 取引所非稼働/null 板稼働/null 板非稼働/null 最小注文数量/null"),
                        "sample": "null",
                    }, "アカウント情報取得": {
                        "path": "/v1/account/accounts", "method": "GET",
                        "params": "なし", "DataPaths": ("アカウントID/data.[index].id"),
                        "sample": {"status": "ok", "data": [{"id": 100009, "type": "spot", "state": "working", "user-id": 1000}]},
                    }, "資産残高取得": {
                        "path": "/v1/account/accounts/[アカウントID]/balance", "method": "GET",
                        "params": "なし", "DataPaths": ("通貨/data.list.[index].currency 数量/data.list.[index].balance 可処分/null"),
                        "sample": {"status": "ok", "data": {"id": 100009, "type": "spot", "state": "working", "list": [
                            {"currency": "jpy", "type": "trade", "balance": "500009195917.4362872650"},
                            {"currency": "jpy", "type": "frozen", "balance": "328048.1199920000"},
                            {"currency": "etc", "type": "trade", "balance": "499999894616.1302471000"},
                            {"currency": "etc", "type": "frozen", "balance": "9786.6783000000"},
                            {"currency": "eth", "type": "trade", "balance": "499999894616.1302471000"},
                            {"currency": "eth", "type": "frozen", "balance": "9786.6783000000"}], "user-id": 1000}},
                    }, "証拠金の状態取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": (
                            "預入証拠金/null 建玉評価損益/null 必要証拠金/null 維持率/null "
                            "追証なし/null 追証中/null 強制追証/null 追証額/null 追証期限/null"),
                        "sample": "null",
                    }, "新規注文": {
                        "path": "/v1/order/orders/place", "method": "POST",
                        "params": "アカウントID 数量 価格 商品 方向と種別 注文番号64", "DataPaths": (
                            "成功/status:ok 失敗/status!:ok 注文ID/data"),
                        "sample": {"status": "ok", "data": "59378"},
                    }, "注文取消": {
                        "path": "/v1/order/orders/[注文ID]/submitcancel", "method": "POST",
                        "params": "注文ID", "DataPaths": ("成功/status:ok 失敗/status!:ok"),
                        "sample": {"status": "ok", "data": 59378},
                    }, "全注文取消": {
                        "path": "/v1/order/orders/batchcancel", "method": "POST",
                        "params": "注文IDリスト", "DataPaths": ("成功/status:ok 失敗/status!:ok 取消注文ID/null"),
                        "sample": {"status": "ok", "data": {"success": ["1", "2", "3"]}},
                    }, "注文一覧取得": {
                        "path": "/v1/order/openOrders", "method": "GET",
                        "params": "アカウントID 商品", "DataPaths": (
                            "注文ID/data.[index].id 商品/data.[index].symbol "
                            "買い/data.[index].type:buy_limit,buy_market 売り/data.[index].type:sell_limit,sell_market "
                            "指値/data.[index].type:buy_limit,sell_limit 成行/data.[index].type:buy_market,sell_market "
                            "逆指値/null 逆成行/null 価格/data.[index].price 平均価格/null 数量/data.[index].amount "
                            "有効注文/null 完了注文/data.[index].state:submitted 取消注文/data.[index].state:cancelling "
                            "期限切れ注文/null 失敗注文/null 有効期限/null 注文日時/data.[index].created-at:UnixTime "
                            "注文受付ID/data.[index].id 未決済数量/null 決済数量/data.[index].filled-amount 取消数量/null 手数料/null"),
                        "sample": {"data": [
                            {"account-id": 12698099, "amount": 2.000000000000000000, "client-order-id": "", "created-at": 1643803200,
                            "filled-amount": 0.0, "filled-cash-amount": 0.0, "filled-fees": 0.0, "id": 375977156321165,
                            "price": 1.000000000000000000, "source": "api", "state": "submitted", "symbol": "xrpjpy",
                            "type": "buy-limit"},
                            {"account-id": 12698090, "amount": 1.500000000000000000, "client-order-id": "CO1234567890",
                            "created-at": 1643889600, "filled-amount": 0.0, "filled-cash-amount": 0.0, "filled-fees": 0.0,
                            "id": 375977156321166, "price": 1.200000000000000000, "source": "web", "state": "processing",
                            "symbol": "ethjpy", "type": "sell-limit"},
                            {"account-id": 12698100, "amount": 3.000000000000000000, "client-order-id": "CO0987654321",
                            "created-at": 1643976000, "filled-amount": 0.0, "filled-cash-amount": 0.0, "filled-fees": 0.0,
                            "id": 375977156321167, "price": 0.800000000000000000, "source": "mobile", "state": "canceled",
                            "symbol": "btcjpy", "type": "buy-market"}], "status": "ok"},
                    }, "建玉一覧取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": (
                            "商品/null 買い/null 売り/null 価格/null 数量/null 手数料/null スワップポイント/null "
                            "必要証拠金/null 注文日時/null 約定日時/null レバレッジ/null 評価損益/null SFD比率/null"),
                        "sample": "null",
                    }, "取引手数料取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": ("商品/null 手数料率TakerBase/null 手数料率TakerQuote/null 手数料率MakerBase/null "
                            "手数料率MakerQuote/null"),
                        "sample": "null",
                    },
                },
            },
            "Coincheck": {
                "domain": "https://coincheck.com",
                "endpoints": {
                    "約定履歴取得": {
                        "path": "/api/trades", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "買い/data.[index].order_type:buy 売り/data.[index].order_type:sell "
                            "価格/data.[index].rate 数量/data.[index].amount 日時/data.[index].created_at:TimeZoneUTC"),
                        "sample": {"success": "true", "pagination": {"limit": 1, "order": "desc", "starting_after": "null",
                            "ending_before": "null"},
                            "data": [
                                {"id": 82, "amount": 0.28391, "rate": 35400.0, "pair": "btc_jpy", "order_type": "sell",
                                "created_at": "2015-01-10T05:55:38.000Z"},
                                {"id": 81, "amount": 0.1, "rate": 36120.0, "pair": "btc_jpy", "order_type": "buy",
                                "created_at": "2015-01-09T15:25:13.000Z"}]},
                    }, "Ticker取得": {
                        "path": "/api/ticker", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "商品/null 日時/timestamp:UnixTime TickID/null "
                            "買高値/bid 売安値/ask 買高値数量/null 売安値数量/null 買深度/null 売深度/null 買付可能注文量/null 売付可能注文量/null "
                            "最終取引価格/last 一日取引量/volume"),
                        "sample": {"last": 27390, "bid": 26900, "ask": 27390, "high": 27659, "low": 26400, "volume": 50.29627103,
                            "timestamp": 1643803200},
                    }, "板情報取得": {
                        "path": "/api/order_books", "method": "GET",
                        "params": "なし", "DataPaths": (
                            "仲値/null "
                            "買い価格/bids.[index].0 買い数量/bids.[index].1 "
                            "売り価格/asks.[index].0 売り数量/asks.[index].1"),
                        "sample": {"asks": [[27330, 2.25], [27340, 0.45], [27350, 1.75], [27360, 0.60]],
                            "bids": [[27240, 1.1543], [26800, 1.2226], [26750, 0.9532], [26700, 2.1624]]},
                    }, "板の状態取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": (
                            "商品/null 取引所稼働/null 取引所高負荷/null 取引所非稼働/null 板稼働/null 板非稼働/null 最小注文数量/null"),
                        "sample": "null",
                    }, "アカウント情報取得": {
                        "path": "/api/accounts", "method": "GET",
                        "params": "なし", "DataPaths": ("アカウントID/id"),
                        "sample": {"success": "true", "id": 10000, "email": "test@gmail.com", "identity_status": "identity_pending",
                            "bitcoin_address": "1v6zFvyNPgdRvhUufkRoTtgyiw1xigncc", "taker_fee": 0.15, "maker_fee": 0.0,
                            "exchange_fees": {
                                "btc_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0},
                                "etc_jpy": {"maker_fee_rate": 0.05, "taker_fee_rate": 0.1},
                                "lsk_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0},
                                "mona_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0},
                                "plt_jpy": {"maker_fee_rate": 0.05, "taker_fee_rate": 0.1},
                                "fnct_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0},
                                "dai_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0},
                                "wbtc_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0}}},
                    }, "資産残高取得": {
                        "path": "/api/accounts/balance", "method": "GET",
                        "params": "なし", "DataPaths": (
                            "[list]通貨/[listup]jpy [list]通貨/[listup]btc [list]数量/jpy [list]数量/btc "
                            "[list]可処分/jpy_reserved [list]可処分/btc_reserved"),
                        "sample": {"success": "true", "jpy": 108401, "btc": 7.75052654, "jpy_reserved": 3000.0, "btc_reserved": 3.5002,
                            "jpy_lend_in_use": 0, "btc_lend_in_use": 0.3, "jpy_lent": 0, "btc_lent": 1.2, "jpy_debt": 0, "btc_debt": 0,
                            "jpy_tsumitate": 10000.0, "btc_tsumitate": 0.4034},
                    }, "証拠金の状態取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": (
                            "預入証拠金/null 建玉評価損益/null 必要証拠金/null 維持率/null "
                            "追証なし/null 追証中/null 強制追証/null 追証額/null 追証期限/null"),
                        "sample": "null",
                    }, "新規注文": {
                        "path": "/api/exchange/orders", "method": "POST",
                        "params": "商品 方向 価格 数量 省略 逆価格 省略", "DataPaths": (
                            "成否/StatusCode 成功/null 失敗/null 注文ID/id"),
                        "sample": {"success": "true", "id": 12345, "rate": 30010.0, "amount": 1.3, "order_type": "sell",
                            "time_in_force": "good_til_cancelled", "stop_loss_rate": "null", "pair": "btc_jpy",
                            "created_at": "2015-01-10T05:55:38.000Z"},
                    }, "注文取消": {
                        "path": "/api/exchange/orders/[注文ID]", "method": "DELETE",
                        "params": "注文ID", "DataPaths": ("成功/success:true 失敗/success:false"),
                        "sample": {"success": "true", "id": 12345},
                    }, "全注文取消": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": ("成功/null 失敗/null 取消注文ID/null"),
                        "sample": "null",
                    }, "注文一覧取得": {
                        "path": "/api/exchange/orders/opens", "method": "GET",
                        "params": "なし", "DataPaths": (
                            "注文ID/orders.[index].id 商品/orders.[index].pair 買い/orders.[index].order_type:buy "
                            "売り/orders.[index].order_type:sell 指値/null 成行/null 逆指値/null 逆成行/null 価格/orders.[index].rate "
                            "平均価格/null 数量/orders.[index].pending_amount 有効注文/null 完了注文/null 取消注文/null 期限切れ注文/null "
                            "失敗注文/null 有効期限/null 注文日時/orders.[index].created_at:TimeZoneUTC 注文受付ID/null 未決済数量/null "
                            "決済数量/null 取消数量/null 手数料/null"),
                        "sample": {"success": "true", "orders": [
                            {"id": 202835, "order_type": "buy", "rate": 26890, "pair": "btc_jpy", "pending_amount": 0.5527,
                            "pending_market_buy_amount": "null", "stop_loss_rate": "null", "created_at": "2015-01-11T05:55:38.000Z"},
                            {"id": 202836, "order_type": "sell", "rate": 26990, "pair": "btc_jpy", "pending_amount": 0.77,
                            "pending_market_buy_amount": "null", "stop_loss_rate": "null", "created_at": "2015-01-10T05:55:38.000Z"},
                            {"id": 38632107, "order_type": "buy", "rate": "null", "pair": "btc_jpy", "pending_amount": "null",
                            "pending_market_buy_amount": 10000.0, "stop_loss_rate": 50000.0, "created_at": "2016-02-23T12:14:50.000Z"}]},
                    }, "建玉一覧取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": (
                            "商品/null 買い/null 売り/null 価格/null 数量/null 手数料/null スワップポイント/null "
                            "必要証拠金/null 注文日時/null 約定日時/null レバレッジ/null 評価損益/null SFD比率/null"),
                        "sample": "null",
                    }, "取引手数料取得": {
                        "path": "/api/accounts", "method": "GET",
                        "params": "なし", "DataPaths": ("商品/null 手数料率TakerBase/taker_fee 手数料率TakerQuote/null "
                            "手数料率MakerBase/maker_fee 手数料率MakerQuote/null"),
                        "sample": {"success": "true", "id": 10000, "email": "test@gmail.com", "identity_status": "identity_pending",
                            "bitcoin_address": "1v6zFvyNPgdRvhUufkRoTtgyiw1xigncc", "taker_fee": 0.15, "maker_fee": 0.0,
                            "exchange_fees": {
                                "btc_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0},
                                "etc_jpy": {"maker_fee_rate": 0.05, "taker_fee_rate": 0.1},
                                "lsk_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0},
                                "mona_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0},
                                "plt_jpy": {"maker_fee_rate": 0.05, "taker_fee_rate": 0.1},
                                "fnct_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0},
                                "dai_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0},
                                "wbtc_jpy": {"maker_fee_rate": 0.0, "taker_fee_rate": 0.0}}},
                    },
                },
            },
            "GMOコイン": {
                "domain": "https://api.coin.z.com",
                "endpoints": {
                    "約定履歴取得": {
                        "path": "/public/v1/trades", "method": "GET",
                        "params": "商品 ページ", "DataPaths": (
                            "買い/data.list.[index].side:BUY 売り/data.list.[index].side:SELL 価格/data.list.[index].price "
                            "数量/data.list.[index].size 日時/data.list.[index].timestamp:TimeZoneUTC"),
                        "sample": {"status": 0, "data": {"pagination": {"currentPage": 1, "count": 30}, "list": [
                            {"price": 750760, "side": "BUY", "size": 0.1, "timestamp": "2018-03-30T12:34:56.789Z"},
                            {"price": 751000, "side": "SELL", "size": 0.2, "timestamp": "2018-03-30T12:35:10.123Z"},
                            {"price": 750500, "side": "BUY", "size": 0.15, "timestamp": "2018-03-30T12:36:24.456Z"}]},
                            "responsetime": "2019-03-28T09:28:07.980Z"},
                    }, "Ticker取得": {
                        "path": "/public/v1/ticker", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "商品/data.[index].symbol 日時/data.[index].timestamp:TimeZoneUTC "
                            "TickID/null 買高値/data.[index].bid 売安値/data.[index].ask "
                            "買高値数量/null 売安値数量/null 買深度/null 売深度/null "
                            "買付可能注文量/null 売付可能注文量/null "
                            "最終取引価格/data.[index].last 一日取引量/data.[index].volume"),
                        "sample": {"status": 0, "data": [{"ask": 750760, "bid": 750600, "high": 762302, "last": 756662, "low": 704874,
                            "symbol": "BTC", "timestamp": "2018-03-30T12:34:56.789Z", "volume": 194785.8484}],
                            "responsetime": "2019-03-19T02:15:06.014Z"},
                    }, "板情報取得": {
                        "path": "/public/v1/orderbooks", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "仲値/null "
                            "買い価格/data.bids.[index].price 買い数量/data.bids.[index].size "
                            "売り価格/data.asks.[index].price 売り数量/data.asks.[index].size"),
                        "sample": {"status": 0, "data": {
                            "asks": [{"price": 455659, "size": 0.1},{"price": 455700, "size": 0.2},{"price": 455750, "size": 0.15}],
                            "bids": [{"price": 455659, "size": 0.1},{"price": 455600, "size": 0.25},{"price": 455550,"size": 0.3}],
                            "symbol": "BTC"}, "responsetime": "2019-03-19T02:15:06.026Z"},
                    }, "板の状態取得": {
                        "path": "/public/v1/status", "method": "GET",
                        "params": "なし", "DataPaths": (
                            "商品/null 取引所稼働/data.status:OPEN 取引所高負荷/null 取引所非稼働/data.status:MAINTENANCE,PREOPEN "
                            "板稼働/null 板非稼働/null 最小注文数量/null"),
                        "sample": {"status": 0, "data": {"status": "OPEN"}, "responsetime": "2019-03-19T02:15:06.001Z"},
                    }, "アカウント情報取得": {
                        "path": "null", "method": "null",
                        "params": "null", "DataPaths": ("アカウントID/null"),
                        "sample": "null",
                    }, "資産残高取得": {
                        "path": "/private/v1/account/assets", "method": "GET",
                        "params": "なし", "DataPaths": (
                            "通貨/data.[index].symbol 数量/data.[index].amount 可処分/data.[index].available"),
                        "sample": {"status": 0, "data": [
                            {"amount": 993982448, "available": 993982448, "conversionRate": 1, "symbol": "JPY"},
                            {"amount": 4.0002, "available": 4.0002, "conversionRate": 859614, "symbol": "BTC"}],
                            "responsetime": "2019-03-19T02:15:06.055Z"},
                    }, "証拠金の状態取得": {
                        "path": "/private/v1/account/margin", "method": "GET",
                        "params": "なし", "DataPaths": (
                            "預入証拠金/data.margin 建玉評価損益/data.profitLoss 必要証拠金/null 維持率/data.marginRatio "
                            "追証なし/data.marginCallStatus:NORMAL 追証中/data.marginCallStatus:MARGIN_CALL "
                            "強制追証/data.marginCallStatus:LOSSCUT 追証額/null 追証期限/null"),
                        "sample": {"status": 0, "data": {"actualProfitLoss": 68286188, "availableAmount": 57262506, "margin": 1021682,
                            "marginCallStatus": "NORMAL", "marginRatio": 6683.6, "profitLoss": 0, "transferableAmount": 57262506},
                            "responsetime": "2019-03-19T02:15:06.051Z"},
                    }, "新規注文": {
                        "path": "/private/v1/order", "method": "POST",
                        "params": "商品 方向 種別 価格 数量 他省略", "DataPaths": (
                            "成功/status:0 失敗/status!:0 注文ID/data"),
                        "sample": {"status": 0, "data": 637000, "responsetime": "2019-03-19T02:15:06.108Z"},
                    }, "注文取消": {
                        "path": "/private/v1/cancelOrder", "method": "POST",
                        "params": "注文ID", "DataPaths": ("成功/status:0 失敗/status!:0"),
                        "sample": {"status": 0, "responsetime": "2019-03-19T01:07:24.557Z"},
                    }, "全注文取消": {
                        "path": "/private/v1/cancelBulkOrder", "method": "POST",
                        "params": "商品", "DataPaths": ("成功/status:0 失敗/status!:0 取消注文ID/data.[index]"),
                        "sample": {"status": 0, "data": [637000,637002], "responsetime": "2019-03-19T01:07:24.557Z"},
                    }, "注文一覧取得": {
                        "path": "/private/v1/activeOrders", "method": "GET",
                        "params": "商品 ページ", "DataPaths": (
                            "注文ID/data.list.[index].orderId 商品/data.list.[index].symbol "
                            "買い/data.list.[index].side:BUY 売り/data.list.[index].side:SELL "
                            "指値/data.list.[index].executionType:LIMIT 成行/data.list.[index].executionType:MARKET "
                            "逆指値/null 逆成行/null 価格/data.list.[index].price 平均価格/null 数量/data.list.[index].size "
                            "有効注文/data.list.[index].status:WAITING,ORDERED 完了注文/null 取消注文/data.list.[index].status:CANCELLING "
                            "期限切れ注文/null 失敗注文/null 有効期限/null 注文日時/data.list.[index].timestamp:TimeZoneUTC 注文受付ID/null "
                            "未決済数量/null 決済数量/data.list.[index].executedSize 取消数量/null 手数料/null"),
                        "sample": {"status": 0, "data": {"pagination": {"currentPage": 1, "count": 30}, "list": [
                            {"rootOrderId": 123456789, "orderId": 123456789, "symbol": "BTC", "side": "BUY", "orderType": "NORMAL",
                            "executionType": "LIMIT", "settleType": "OPEN", "size": 1, "executedSize": 0, "price": 840000,
                            "losscutPrice": 0, "status": "ORDERED", "timeInForce": "FAS", "timestamp": "2019-03-19T01:07:24.217Z"},
                            {"rootOrderId": 123456790, "orderId": 123456790, "symbol": "ETH", "side": "SELL", "orderType": "NORMAL",
                            "executionType": "MARKET", "settleType": "CLOSE", "size": 0.5, "executedSize": 0.5, "price": 250000,
                            "losscutPrice": 0, "status": "COMPLETED", "timeInForce": "IOC", "timestamp": "2019-03-19T02:15:00.123Z"}]},
                            "responsetime": "2019-03-19T01:07:24.217Z"},
                    }, "建玉一覧取得": {
                        "path": "/private/v1/openPositions", "method": "GET",
                        "params": "商品", "DataPaths": (
                            "商品/data.list.[index].symbol 買い/data.list.[index].side:BUY 売り/data.list.[index].side:SELL "
                            "価格/data.list.[index].price 数量/data.list.[index].size 手数料/null スワップポイント/null "
                            "必要証拠金/null 注文日時/null 約定日時/data.list.[index].timestamp:TimeZoneUTC "
                            "レバレッジ/data.list.[index].leverage 評価損益/data.list.[index].lossGain SFD比率/null"),
                        "sample": {"status": 0, "data": {"pagination": {"currentPage": 1, "count": 30}, "list": [
                            {"positionId": 1234567, "symbol": "BTC_JPY", "side": "BUY", "size": 0.22, "orderdSize": 0, "price": 876045,
                            "lossGain": 14, "leverage": 4, "losscutPrice": 766540, "timestamp": "2019-03-19T02:15:06.094Z"},
                            {"positionId": 1234568, "symbol": "ETH_JPY", "side": "SELL", "size": 1.5, "orderdSize": 0, "price": 35000,
                            "lossGain": -10, "leverage": 2, "losscutPrice": 33000, "timestamp": "2019-03-19T03:00:00.123Z"},
                            {"positionId": 1234569, "symbol": "XRP_JPY", "side": "BUY", "size": 300, "orderdSize": 0, "price": 50,
                            "lossGain": 30, "leverage": 1, "losscutPrice": 45, "timestamp": "2019-03-19T03:30:10.456Z"}]},
                            "responsetime": "2019-03-19T02:15:06.095Z"},
                    }, "取引手数料取得": {
                        "path": "/private/v1/account/tradingVolume", "method": "GET",
                        "params": "なし", "DataPaths": (
                            "商品/data.limit.[index].symbol "
                            "手数料率TakerBase/data.limit.[index].takerFee 手数料率TakerQuote/null "
                            "手数料率MakerBase/data.limit.[index].makerFee 手数料率MakerQuote/null"),
                        "sample": {"status": 0, "data": {"jpyVolume": 9988888, "tierLevel": 1, "limit": [
                            {"symbol": "BTC/JPY", "todayLimitOpenSize": 10000, "takerFee": 0, "makerFee": 0},
                            {"symbol": "BTC", "todayLimitBuySize": 98, "todayLimitSellSize": 102, "takerFee": 0.0015,
                            "makerFee": -0.0007}]}, "responsetime": "2019-03-19T02:15:06.055Z"},
                    },
                },
            },
        }

        self.DefAccess = "bitFlyer"  # デフォルトの接続先を定義

        self.EncryptionKey = None  # 暗号化キーの変数を定義
        self.IV_ofEncryption = None  # CBC モードの初期化ベクトルの変数を定義

        # キャッシュファイルの有無を示すフラグ変数を定義
        self.CacheIsEnabled_ofAPI_1 = self.CacheIsEnabled_ofAPI_2 = self.CacheIsEnabled_ofAPI_3 = self.CacheIsEnabled_ofAPI_4 = \
        self.CacheIsEnabled_ofAPI_5 = False

        # メインフレーム「設定」タブ用の変数を定義
        pass

        # メインフレーム「設定」タブでの「キーを表示／伏せる」ボタンを切り替えるためのフラグ変数を定義
        self.ShowKeys_1 = self.ShowKeys_2 = self.ShowKeys_3 = self.ShowKeys_4 = self.ShowKeys_5 = False

        # メインフレーム「設定」タブでの設定項目一覧を配列化
        self.SettingNames = [
            "Exchange_Pull",]

        ##############################################################################
        # ### MainThreadFunctionsClass と SubThreadFunctionsClass で使用する変数を定義 ###
        ##############################################################################

        # ログテキストエリアを識別する、マジックナンバーを避けるための定数を定義
        self.一般 = 0  # アプリケーションのエンジン以外の動作とテストエンジンの動作のログを記録するログテキストエリア
        self.接続先1 = 1  # 接続先 1 で稼働中のエンジンの動作のログを記録するログテキストエリア
        self.接続先2 = 2  # 接続先 2 で稼働中のエンジンの動作のログを記録するログテキストエリア
        self.接続先3 = 3  # 接続先 3 で稼働中のエンジンの動作のログを記録するログテキストエリア
        self.接続先4 = 4  # 接続先 4 で稼働中のエンジンの動作のログを記録するログテキストエリア
        self.接続先5 = 5  # 接続先 5 で稼働中のエンジンの動作のログを記録するログテキストエリア

        # 関数の呼び出しを制御する、マジックナンバーを避けるための定数を定義
        self.主 = 1  # 関数の主要処理を呼び出すための定数
        self.副 = 2  # 関数の付属処理を呼び出すための定数
        self.デバッグ = 1  # 関数をデバッグモードで呼び出すための定数
        self.通常 = 2  # 関数を通常モードで呼び出すための定数

        # 関数 LoadAccess() の呼び出しを制御する、マジックナンバーを避けるための定数を定義
        self.EditAccess = 1  # EditAccess_Pull のための呼び出し
        self.Exchange = 2  # Exchange_Pull のための呼び出し

        # タスク名を定義
        self.TaskNames = {
            "PathTest": "PathTest", "ExtractAndFormatData": "ExtractAndFormatData"}

        # API キー及び API シークレットの bytes 型変数を定義
        self.APIkey_EncryptedBytes_1 = self.APIkey_EncryptedBytes_2 = self.APIkey_EncryptedBytes_3 = self.APIkey_EncryptedBytes_4 = \
        self.APIkey_EncryptedBytes_5 = b""
        self.APIsecret_EncryptedBytes_1 = self.APIsecret_EncryptedBytes_2 = self.APIsecret_EncryptedBytes_3 = \
        self.APIsecret_EncryptedBytes_4 = self.APIsecret_EncryptedBytes_5 = b""

        # プロダクトコードの変数を定義
        self.ProductCode_1 = self.ProductCode_2 = self.ProductCode_3 = self.ProductCode_4 = self.ProductCode_5 = None

        # API 通信に使用する各種データを格納する辞書型配列を定義
        for TabNum in range(1, self.Settings_TabCount + 1):  # メインフレーム「設定」タブの各「接続先」タブのためのイテレーション
            setattr(self, "ConnectionsStandby_{0}".format(str(TabNum)), {})

        ###################################################
        # ### SubThreadFunctionsClass で使用する変数を定義 ###
        ###################################################

        # 文字列のエスケープ処理の種類を識別する、マジックナンバーを避けるための定数を定義
        self.標準 = 1  # 標準エスケープ
        self.特殊 = 2  # 特殊エスケープ

        # アプリケーションで使用するユーザーエージェントを定義
        self.DefaultUserAgent = \
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36"
        # BitTrade の API 用のユーザーエージェントを定義
        self.BitTradeUserAgent = \
            "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36"

        self.MaxNestLevel = 3  # API から返されるデータの内、対応するネストの深さを定義

        # エンドポイントのパラメータ変数を定義
        self.EndpointParamNameList = [
            "商品", "年月日", "数量", "価格", "方向", "種別", "注文ID", "注文IDリスト", "ページ", "注文ID_or_受付ID", "注文状態", "グループ",
            "アカウントID", "方向と種別", "注文番号64", "逆価格",]
        """ self.DefConnections での出現順で並べています。 """
        self.EndpointParams = {self.ParamName: None for self.ParamName in self.EndpointParamNameList}

        # 受信データの取り扱い形式を定義
        self.DataHandleForm = {
            "約定履歴取得": {
                # レスポンスから取得した値の格納場所を定義
                # 値の格納場所を None で初期化しておくことで、後でどのようなデータ型にも対応可能
                "DataHandleNames":
                    [{"方向": None, "価格": None, "数量": None, "日時": None,},],
                # 値にアクセスするためのデータパスを定義
                "KeyPath":
                    {"買い": "index.方向", "売り": "index.方向", "方向": "index.方向",
                    "価格": "index.価格", "数量": "index.数量", "日時": "index.日時",},},
            "Ticker取得": {
                "DataHandleNames":
                    [{"商品": None, "日時": None, "TickID": None, "買高値": None, "売安値": None, "買高値数量": None, "売安値数量": None,
                    "買深度": None, "売深度": None, "買付可能注文量": None, "売付可能注文量": None, "最終取引価格": None,
                    "一日取引量": None,},],
                "KeyPath":
                    {"商品": "index.商品", "日時": "index.日時", "TickID": "index.TickID",
                    "買高値": "index.買高値", "売安値": "index.売安値", "買高値数量": "index.買高値数量", "売安値数量": "index.売安値数量",
                    "買深度": "index.買深度", "売深度": "index.売深度",
                    "買付可能注文量": "index.買付可能注文量", "売付可能注文量": "index.売付可能注文量", "最終取引価格": "index.最終取引価格",
                    "一日取引量": "index.一日取引量",},},
            "板情報取得": {
                "DataHandleNames":
                    [{"仲値": None, "板情報":
                        {"買い": [{"買い価格": None, "買い数量": None,},],
                        "売り": [{"売り価格": None, "売り数量": None,},],},},],
                "KeyPath":
                    {"仲値": "0.仲値", "板情報": "0.板情報", "買い": "0.板情報.買い", "売り": "0.板情報.売り",
                    "買い価格": "0.板情報.買い.index.買い価格", "買い数量": "0.板情報.買い.index.買い数量",
                    "売り価格": "0.板情報.売り.index.売り価格", "売り数量": "0.板情報.売り.index.売り数量",},},
            "板の状態取得": {
                "DataHandleNames":
                    [[None, {"取引所状態": None, "板状態": None, "最小注文数量": None,},],],
                "KeyPath":
                    {"商品": "index.0",
                    "取引所稼働": "index.1.取引所状態", "取引所高負荷": "index.1.取引所状態", "取引所非稼働": "index.1.取引所状態",
                    "取引所状態": "index.1.取引所状態", "板稼働": "index.1.板状態", "板非稼働": "index.1.板状態",
                    "板状態": "index.1.板状態", "最小注文数量": "index.1.最小注文数量",},},
            "アカウント情報取得": {
                "DataHandleNames":
                    [{"アカウントID": None,},],
                "KeyPath":
                    {"アカウントID": "index.アカウントID",},},
            "資産残高取得": {
                "DataHandleNames":
                    [[None, {"数量": None, "可処分": None,},],],
                "KeyPath":
                    {"通貨": "index.0", "数量": "index.1.数量", "可処分": "index.1.可処分",},},
            "証拠金の状態取得": {
                "DataHandleNames":
                    [{"預入証拠金": None, "建玉評価損益": None, "必要証拠金": None, "維持率": None, "追証状態": None, "追証額": None,
                    "追証期限": None,}],
                "KeyPath":
                    {"預入証拠金": "index.預入証拠金", "建玉評価損益": "index.建玉評価損益", "必要証拠金": "index.必要証拠金",
                    "維持率": "index.維持率", "追証なし": "index.追証状態", "追証中": "index.追証状態", "強制追証": "index.追証状態",
                    "追証状態": "index.追証状態", "追証額": "index.追証額", "追証期限": "index.追証期限",},},
            "新規注文": {
                "DataHandleNames":
                    [{"成否": None, "注文ID": None,},],
                "KeyPath":
                    {"成功": "index.成否", "失敗": "index.成否", "成否": "index.成否", "注文ID": "index.注文ID",},},
            "注文取消": {
                "DataHandleNames":
                    [{"成否": None,}],
                "KeyPath":
                    {"成功": "index.成否", "失敗": "index.成否", "成否": "index.成否",},},
            "全注文取消": {
                "DataHandleNames":
                    [{"成否": None, "取消注文ID": None,},],
                "KeyPath":
                    {"成功": "index.成否", "失敗": "index.成否", "成否": "index.成否", "取消注文ID": "index.取消注文ID",},},
            "注文一覧取得": {
                "DataHandleNames":
                    [{"注文ID": None, "商品": None, "方向": None, "種別": None, "価格": None, "平均価格": None, "数量": None,
                    "注文状態": None, "有効期限": None, "注文日時": None, "注文受付ID": None, "未決済数量": None, "決済数量": None,
                    "取消数量": None, "手数料": None,},],
                "KeyPath":
                    {"注文ID": "index.注文ID", "商品": "index.商品", "買い": "index.方向", "売り": "index.方向", "方向": "index.方向",
                    "指値": "index.種別", "成行": "index.種別", "逆指値": "index.種別", "逆成行": "index.種別", "種別": "index.種別",
                    "価格": "index.価格", "平均価格": "index.平均価格", "数量": "index.数量", "有効注文": "index.注文状態",
                    "完了注文": "index.注文状態", "取消注文": "index.注文状態", "期限切れ注文": "index.注文状態", "失敗注文": "index.注文状態",
                    "注文状態": "index.注文状態", "有効期限": "index.有効期限", "注文日時": "index.注文日時", "注文受付ID": "index.注文受付ID",
                    "未決済数量": "index.未決済数量", "決済数量": "index.決済数量", "取消数量": "index.取消数量", "手数料": "index.手数料",},},
            "建玉一覧取得": {
                "DataHandleNames":
                    [{"商品": None, "方向": None, "価格": None, "数量": None, "手数料": None, "スワップポイント": None, "必要証拠金": None,
                    "注文日時": None, "約定日時": None, "レバレッジ": None, "評価損益": None, "SFD比率": None,},],
                "KeyPath":
                    {"商品": "index.商品", "買い": "index.方向", "売り": "index.方向", "方向": "index.方向", "価格": "index.価格",
                    "数量": "index.数量", "手数料": "index.手数料", "スワップポイント": "index.スワップポイント",
                    "必要証拠金": "index.必要証拠金", "注文日時": "index.注文日時", "約定日時": "index.約定日時",
                    "レバレッジ": "index.レバレッジ", "評価損益": "index.評価損益", "SFD比率": "index.SFD比率",},},
            "取引手数料取得": {
                "DataHandleNames":
                    [{"商品": None,
                    "手数料率TakerBase": None, "手数料率TakerQuote": None, "手数料率MakerBase": None, "手数料率MakerQuote": None,},],
                "KeyPath":
                    {"商品": "index.商品",
                    "手数料率TakerBase": "index.手数料率TakerBase", "手数料率TakerQuote": "index.手数料率TakerQuote",
                    "手数料率MakerBase": "index.手数料率MakerBase", "手数料率MakerQuote": "index.手数料率MakerQuote",},
            },
        }
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # アプリケーションのグラフィカルユーザーインターフェース（GUI）を初期化する関数
    def Init_GUI(self):
        """ この部分を「関数の docstring」と言います。
        アプリケーションのグラフィカルユーザーインターフェース（GUI）を初期化する関数。

        この関数は、アプリケーションのウィンドウに表示される全てのオブジェクト（GUI ウィジェット）を定義し、初期化します。この関数で定義するオブジェクトには
        AppClass 以外のクラス（LogManagerClass、MainThreadFunctionsClass）からのアクセスがあります。AppClass はアプリケーションが機能するための処理
        部分（関数）を持たないため、AppClass 以外のクラスにオブジェクトへのアクセス（参照）を提供する必要があります。このため、全てのオブジェクトは AppClass
        のクラス属性として定義します。AppClass 以外のクラスは、このクラス属性にアクセスすることでユーザーインタラクションに対するレスポンスを視覚的に表現
        します。また、ユーザーインタラクションに対するレスポンスの指示（シグナル）は全て AppClass から MainThreadFunctionsClass に伝え（接続）ます
        （シグナルの接続は AppClass のコンストラクタで呼び出される後続の関数が行います）。システムログの表示に関係するオブジェクトが全て初期化され次第
        LogManagerClass のシングルトンインスタンスを self.LogManager 属性（クラス属性）に設定し、ログの記録を開始します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        ####################
        # ### 骨組みを作成 ###
        ####################
        """ 以下、PyQt フレームワークの仕様 1 ウィジェット 1 レイアウトに則り、GUI ウィジェットの定義を行います。 """

        # マスターコンテナを作成し、クラス（self）属性に設定
        self.Master = QtWidgets.QWidget(self)  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
        self.Master.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
        self.setCentralWidget(self.Master)  # アプリケーションのコンテンツを配置する中央ウィジェットに設定
        """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

        # マスターコンテナにレイアウトを定義（サブフレームとメインフレームを管理するレイアウトマネージャ）し、クラス（self）属性に設定
        self.Master_layout = QtWidgets.QHBoxLayout(self.Master)  # 水平レイアウトのインスタンスを作成
        self.Master_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
        self.Master_layout.setSpacing(0)  # レイアウト内のウィジェット間の間隔を設定

        # サブフレーム（画面左側）を作成し、クラス（self）属性に設定
        self.sub_frame = QtWidgets.QFrame(self.Master)  # QFrame のインスタンスを作成（サブフレームの文脈のため QFrame を選択）
        self.sub_frame.setStyleSheet(self.FrameStyle)  # 対応するスタイルシートを設定
        self.Master_layout.addWidget(self.sub_frame, 1)  # サブフレームにウィジェットスペースの比率（25%）を割り当て

        # サブフレームにレイアウトを定義（サブフレームの内容を管理するレイアウトマネージャ）し、クラス（self）属性に設定
        self.sub_layout = QtWidgets.QVBoxLayout(self.sub_frame)  # 垂直レイアウトのインスタンスを作成
        self.sub_layout.setContentsMargins(10, 15, 5, 10)  # レイアウトのマージンを設定
        self.sub_layout.setSpacing(5)  # レイアウト内のウィジェット間の間隔を設定

        # メインフレーム（画面右側）を作成し、クラス（self）属性に設定
        self.main_frame = QtWidgets.QFrame(self.Master)  # QFrame のインスタンスを作成（メインフレームの文脈のため QFrame を選択）
        self.main_frame.setStyleSheet(self.FrameStyle)  # 対応するスタイルシートを設定
        self.Master_layout.addWidget(self.main_frame, 3)  # メインフレームにウィジェットスペースの比率（75%）を割り当て

        # メインフレームにレイアウトを定義（メインフレームの内容を管理するレイアウトマネージャ）し、クラス（self）属性に設定
        self.main_layout = QtWidgets.QVBoxLayout(self.main_frame)  # 垂直レイアウトのインスタンスを作成
        self.main_layout.setContentsMargins(5, 15, 0, 10)  # レイアウトのマージンを設定
        self.main_layout.setSpacing(0)  # レイアウト内のウィジェット間の間隔を設定

        ############################
        # ### 以下サブフレームの記述 ###
        ############################

        ####################
        # ### 骨組みを作成 ###
        ####################

        # 「システムログ」のラベルを作成し、クラス（self）属性に設定
        self.Log_Label = QtWidgets.QLabel("システムログ", self.sub_frame)  # QLabel のインスタンスを作成
        self.Log_Label.setAlignment(QtCore.Qt.AlignCenter)  # テキストを中央に整列
        self.sub_layout.addWidget(self.Log_Label)  # インスタンスをサブフレームのレイアウトに追加

        # タブグループウィジェットを作成し、クラス（self）属性に設定
        self.SubFrameTab = QtWidgets.QTabWidget(self.sub_frame)  # QTabWidget のインスタンスを作成
        self.sub_layout.addWidget(self.SubFrameTab)  # インスタンスをサブフレームのレイアウトに追加

        for TabNum, InternalName, DisplayName in self.SubFrame_TabNames:  # サブフレームの各タブの内容を定義するためのイテレーション
            # タブウィジェットを作成
            self.Tab_widget = QtWidgets.QWidget(self.SubFrameTab)  # QWidget のインスタンスを作成（QTabWidget の文脈のため QWidget を選択）
            self.Tab_widget.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            setattr(self, str(InternalName), self.Tab_widget)  # InternalName を使用してクラス（self）属性として保存
            """ QTabWidget の子属性としての単なる一つのタブウィジェットには文脈情報は必要ないため、QWidget を使用しています。 """

            self.SubFrameTab.addTab(self.Tab_widget, DisplayName)  # タブグループウィジェットにタブウィジェットを追加

            # タブウィジェットにレイアウトを定義（タブの内容を管理するレイアウトマネージャ）
            self.Tab_layout = QtWidgets.QVBoxLayout(self.Tab_widget)  # 垂直レイアウトのインスタンスを作成
            self.Tab_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.Tab_layout.setSpacing(0)  # レイアウト内のウィジェット間の間隔を設定
            setattr(self, "{0}_layout".format(str(InternalName)), self.Tab_layout)  # InternalName を使用してクラス（self）属性として保存

            # 「システムログ」のテキストエリアのコンテナを作成
            self.Log_cntnr = QtWidgets.QWidget(self.Tab_widget)  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.Log_cntnr.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            self.Tab_layout.addWidget(self.Log_cntnr)  # インスタンスをタブウィジェットのレイアウトに追加
            setattr(self, "Log_cntnr_{0}".format(str(TabNum)), self.Log_cntnr)  # TabNum を使用してクラス（self）属性として保存
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # 「システムログ」のテキストエリアのコンテナにレイアウトを定義（テキストエリアを管理するレイアウトマネージャ）
            self.Log_cntnr_layout = QtWidgets.QVBoxLayout(self.Log_cntnr)  # 垂直レイアウトのインスタンスを作成
            self.Log_cntnr_layout.setContentsMargins(0, 0, 10, 0)  # レイアウトのマージンを設定
            self.Log_cntnr_layout.setSpacing(0)  # レイアウト内のウィジェット間の間隔を設定
            setattr(self, "Log_cntnr_layout_{0}".format(str(TabNum)), self.Log_cntnr_layout)  # TabNum を使用してクラス（self）属性として保存

            #######################
            # ### コンテンツを作成 ###
            #######################

            # 「システムログ」のテキストエリアを作成
            self.LogText = QtWidgets.QTextEdit(self.Tab_widget)  # QTextEdit のインスタンスを作成
            self.LogText.setStyleSheet(self.TextStyle)  # 対応するスタイルシートを設定
            self.LogText.setLineWrapMode(QTextEdit.FixedPixelWidth)  # テキストの折り返し方法を指定ピクセル幅に設定（DisplayClass でリサイズ）
            self.LogText.setReadOnly(True)  # 編集モードを編集不可に設定
            self.Font = QFont()  # QFont のインスタンスを作成
            self.Font.setPointSize(10)  # フォントサイズを設定
            self.LogText.setFont(self.Font)  # フォント設定を QTextEdit に反映
            self.Tab_layout.addWidget(self.LogText)  # インスタンスをタブウィジェットのレイアウトに追加
            setattr(self, "LogText_{0}".format(str(TabNum)), self.LogText)  # TabNum を使用してクラス（self）属性として保存

        # LogManagerClass の初期化
        self.LogManager, self.LF = LogManagerClass.GetInstance()  # LogManagerClass のシングルトンインスタンスと OS 依存改行文字を取得
        """
ここでは、関数が複数の要素を含むタプルを返すと分かっているため、関数の返り値を代入する先をあらかじめタプルが含む要素の数だけ用意しておきます。このようにすること
で、関数が返す複数の要素を含むタプルを自動的にアンパックすることができ、タプルの要素はそれぞれタプル内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
        """
        self.LogManager.SetLogInstance(  # ログテキストエリアへの参照を LogManagerClass に注入
            self.LogText_0, self.LogText_1, self.LogText_2, self.LogText_3, self.LogText_4, self.LogText_5)

        self.LogManager.InsertLOG("サブフレーム：初期化完了", self.一般)
        self.LogManager.InsertLOG("アプリケーション初期化：続行", self.一般)

        ##############################
        # ### 以下メインフレームの記述 ###
        ##############################

        # タブグループウィジェットを作成し、クラス（self）属性に設定
        self.Tab = QtWidgets.QTabWidget(self.main_frame)  # QTabWidget のインスタンスを作成
        self.main_layout.addWidget(self.Tab)  # インスタンスをメインフレームのレイアウトに追加

        for InternalName, DisplayName in self.MainFrame_TabNames:  # メインフレームの各タブの内容を定義するためのイテレーション
            # タブウィジェットを作成
            self.Tab_widget = QtWidgets.QWidget(self.Tab)  # QWidget のインスタンスを作成（QTabWidget の文脈のため QWidget を選択）
            self.Tab_widget.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            setattr(self, str(InternalName), self.Tab_widget)  # InternalName を使用してクラス（self）属性として保存
            """ QTabWidget の子属性としての単なる一つのタブウィジェットには文脈情報は必要ないため、QWidget を使用しています。 """

            self.Tab.addTab(self.Tab_widget, DisplayName)  # タブグループウィジェットにタブウィジェットを追加

            # タブウィジェットにレイアウトを定義（タブの内容を管理するレイアウトマネージャ）
            self.Tab_layout = QtWidgets.QVBoxLayout(self.Tab_widget)  # 垂直レイアウトのインスタンスを作成
            self.Tab_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.Tab_layout.setSpacing(0)  # レイアウト内のウィジェット間の間隔を設定
            setattr(self, "{0}_layout".format(str(InternalName)), self.Tab_layout)  # InternalName を使用してクラス（self）属性として保存

        self.Tab.setCurrentIndex(2)  # デフォルトで表示するタブを設定

        ##########################################
        # ### 以下メインフレーム「使い方」タブの記述 ###
        ##########################################

        ####################
        # ### 骨組みを作成 ###
        ####################

        # 「使い方」のコンテナを作成し、クラス（self）属性に設定
        self.Manual_cntnr = QtWidgets.QWidget(self.Tab_1)  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
        self.Manual_cntnr.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
        self.Tab_1_layout.addWidget(self.Manual_cntnr)  # インスタンスをメインフレームのタブウィジェットのレイアウトに追加
        """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

        # 「使い方」のコンテナにレイアウトを定義（テキストの内容を管理するレイアウトマネージャ）し、クラス（self）属性に設定
        self.Manual_cntnr_layout = QtWidgets.QVBoxLayout(self.Manual_cntnr)  # 垂直レイアウトのインスタンスを作成
        self.Manual_cntnr_layout.setContentsMargins(0, 0, 10, 0)  # レイアウトのマージンを設定
        self.Manual_cntnr_layout.setSpacing(0)  # レイアウト内のウィジェット間の間隔を設定

        #######################
        # ### コンテンツを作成 ###
        #######################

        # 「使い方」のテキストを作成し、クラス（self）属性に設定
        self.Manual_Text = QtWidgets.QTextEdit(self.Manual_cntnr)  # QTextEdit のインスタンスを作成
        self.Manual_Text.setStyleSheet(self.TextStyle)  # 対応するスタイルシートを設定
        self.Manual_Text.setLineWrapMode(QTextEdit.FixedPixelWidth)  # テキストの折り返し方法を指定ピクセル幅に設定（DisplayClass でリサイズ）
        self.Manual_Text.setReadOnly(True)  # 編集モードを編集不可に設定
        self.Manual_Text.setText(  # テキストを設定（リッチテキストを使用可能）
"""【このアプリケーションの使用方法】

●ご利用にあたって
　本アプリケーションの開発にあたり、サーバーとの通信テストの実施は、
開発者の利用環境である「bitFlyer」でのみ行っております。
　そのため、開発当初からの目的は当該取引所での適切な動作にあり、
後天的に追加されたその他の取引所または販売所との適切な通信及び動作は保証しておりません。

　また「bitFlyer」でのご利用にあたっても、設定値や設定条件の組み合わせによって動作は変化いたします。
　そのため「このアプリケーションを使えば利益が出る」というものではないことを予めご理解ください。
　本アプリケーションは、あくまで開発者の為替取引経験を自動化するためのものであり、
未経験者に識者と同じ取引益をもたらすことを意図して設計されているわけではありません。
　また開発者自身、為替取引の識者であるという認識を持っているものでもありません。
　そのため、本アプリケーションは為替取引のプロが扱うツール等とは異なる発想の下に設計されております。
　もし、広く一般に認知されている取引手法を用いた自動売買を目的としておいででしたら、
本アプリケーションの使用は不適当となりますことをご理解ください。

　本アプリケーションには試験的なロジックが多く含まれております。
　本アプリケーション内部での演算手法（ロジック）は、開発者独自の認識の下に設計されております。
　設計思想は「可能な限り手放しで最大限の取引益を得る」ですが、そこに至ろうとするアプローチは
開発者独自のものとなることをくれぐれもご理解の上、慎重にご利用ください。


●免責事項
　本アプリケーションを用いて行った取引結果について、それがどのようなものであろうと、
「ご利用にあたって」をよく読まれた上で取引を行った（本アプリケーションを使用した）ものであるとみなされます。
　このため、本アプリケーションを用いた取引において損害を被った場合、開発者は如何なる責任も負いません。


●注意事項
　1、ソースコードの提供を受けて変更した場合、実際にエンジンを稼働させる前に、必ず「接続先編集」タブで API が返す
レスポンスデータの JSON サンプルを使って日時情報を正しく認識できるかテストしてください。このときのデータパス及び
期待値の設定方法は「接続先編集」タブのドキュメントを参照してください。


●現在確認済みのバグ【分類：クリティカル、順序：重要度】
　なし


●現在確認済みのバグ【分類：サテライト、順序：重要度】
　なし

（以下はここまでの英語版です）

------------------------------------------------------------------------------------------------------------------

【How to Use This Application】

● Usage Instructions
When developing this application, server communication tests were conducted only in the developer's usage
environment, which is "bitFlyer." Therefore, the initial purpose of the development was to ensure proper operation
with this exchange, and appropriate communication and operation with other exchanges or trading platforms that
were added later are not guaranteed.

Additionally, even when using it with "bitFlyer," the operation may change depending on the combination of setting
values and conditions. Therefore, please understand in advance that this application does not guarantee profits.
This application is designed to automate the developer's own trading experience and is not intended to provide the
same trading profits as an expert to inexperienced users. Furthermore, the developer does not consider themselves an
expert in trading. Therefore, this application is designed with a different approach than tools used by
professional traders. If you aim to use automated trading with widely recognized trading methods, please understand
that this application is not suitable for you.

This application contains many experimental logics. The calculation methods (logics) within this application are
designed based on the developer's unique understanding. The design philosophy is "to achieve maximum trading
profits with minimal intervention," but please understand that the approach to achieve this is unique to the
developer and use the application with caution.

● Disclaimer
No matter the outcome of trades made using this application, it will be considered that the user has read and
understood the "Usage Instructions" before conducting trades (using this application). Therefore, the developer
assumes no responsibility for any damages incurred from trades made using this application.

● Cautions
If you have modified the source code after receiving it, be sure to test whether the date and time information can be
correctly recognized using the JSON sample of the response data returned by the API in the "Edit Connection" tab
before actually running the engine. For the data path and setting method of expected values at this time, refer to the
documentation in the "Edit Connection" tab.

● Currently Known Bugs [Category: Critical, Order: Importance]
None

● Currently Known Bugs [Category: Satellite, Order: Importance]
None

------------------------------------------------------------------------------------------------------------------

●ライセンス条項（LICENSE TERMS）
　本アプリケーションは GPLv3 ライセンスの下、開発及び配布されています。
　Copyright ©2023 Shohei KIMURA (bitBuyer.dev)

0. bitBuyerプロジェクト（https://bitBuyer.dev/bitbuyer-0-8-1-a-とは）
   GPL v3（GNU General Public License version 3）
   http://www.gnu.org/licenses/gpl-3.0.html

   クレジット表記
   - プロジェクト -
   『bitBuyerプロジェクト』におけるオリジナル版『0.8.1.a』。

   - 開発者 -
   Shohei KIMURA (Founder & Lead Developer)

   - 連絡先 -
   Mail：bitbuyer.0.8.1.a@icloud.com（件名には "bitBuyer 0.8.1.a" を必ず含めてください）

   - ライセンス -
   GNU General Public License, version 3.

   - スペシャルサンクス -
   Ai YAMAMOTO (Stakeholder: Shohei KIMURA)
   Saki UMEDA (Stakeholder: Shohei KIMURA)
   And others, by memory with figures...

　本アプリケーションには、以下のソフトウェアが含まれています。

1. PyQt5（https://www.riverbankcomputing.com/software/pyqt/intro）
   GPL v3（GNU General Public License version 3）
   http://www.gnu.org/licenses/gpl-3.0.html

2. Cryptography Project（https://cryptography.io/）
   Apache License, Version 2.0
   http://www.apache.org/licenses/LICENSE-2.0

3. Pympler Project（https://github.com/pympler/pympler）
   Apache License, Version 2.0
   http://www.apache.org/licenses/LICENSE-2.0

4. Requests Project（https://docs.python-requests.org/）
   Apache License, Version 2.0
   http://www.apache.org/licenses/LICENSE-2.0
   ISC License
   https://opensource.org/licenses/ISC

5. Requests-oauthlib Project（https://github.com/requests/requests-oauthlib）
   ISC License
   https://opensource.org/licenses/ISC

これらのソフトウェアは、各ライセンスに基づいてのみ使用することができます。
（以下はここまでの英語版です）

------------------------------------------------------------------------------------------------------------------

 This application is developed and distributed under the GPLv3 license.
 Copyright ©2023 Shohei KIMURA (bitBuyer.dev)

0. bitBuyer Project（https://bitBuyer.dev/bitbuyer-0-8-1-a-とは）
   GPL v3（GNU General Public License version 3）
   http://www.gnu.org/licenses/gpl-3.0.html

   Credits
   - Project -
   The original version "0.8.1.a" of the "bitBuyer Project".

   - Developer -
   Shohei KIMURA (Founder & Lead Developer)

   - Contact -
   Mail: bitbuyer.0.8.1.a@icloud.com (Please include "bitBuyer 0.8.1.a" in the subject line)

   - License -
   GNU General Public License, version 3.

   - Special Thanks -
   Ai YAMAMOTO (Stakeholder: Shohei KIMURA)
   Saki UMEDA (Stakeholder: Shohei KIMURA)
   And others, by memory with figures...

 This application includes the following software:

1. PyQt5（https://www.riverbankcomputing.com/software/pyqt/intro）
   GPL v3（GNU General Public License version 3）
   http://www.gnu.org/licenses/gpl-3.0.html

2. Cryptography Project（https://cryptography.io/）
   Apache License, Version 2.0
   http://www.apache.org/licenses/LICENSE-2.0

3. Pympler Project（https://github.com/pympler/pympler）
   Apache License, Version 2.0
   http://www.apache.org/licenses/LICENSE-2.0

4. Requests Project（https://docs.python-requests.org/）
   Apache License, Version 2.0
   http://www.apache.org/licenses/LICENSE-2.0
   ISC License
   https://opensource.org/licenses/ISC

5. Requests-oauthlib Project（https://github.com/requests/requests-oauthlib）
   ISC License
   https://opensource.org/licenses/ISC

These software components are licensed for use only under their respective licenses.

------------------------------------------------------------------------------------------------------------------

本アプリケーションは、GNU 一般公衆利用許諾契約書（GPL）の下でライセンスされている PyQt5 を使用しています。

PyQt5
Copyright (c) 2009-2024, Riverbank Computing Limited

GNU 一般公衆利用許諾契約書、バージョン 3 またはそれ以降のバージョン（「ライセンス」）の下でライセンスされています。
このファイルは、ライセンスに従わない限り使用できません。
ライセンスのコピーは以下から入手できます：

　　https://www.gnu.org/licenses/gpl-3.0.html

適用法により要求されない限り、または書面で合意されない限り、ライセンスの下で配布されるソフトウェアは「現状のまま」
提供され、明示的または黙示的な保証や条件はありません。
ライセンスで規定されている特定の言語については、ライセンスを参照してください。

（以下はここまでの英語版です）

------------------------------------------------------------------------------------------------------------------

This application uses PyQt5, which is licensed under the GNU General Public License (GPL).

PyQt5
Copyright (c) 2009-2024, Riverbank Computing Limited

Licensed under the GNU General Public License, version 3 or any later version (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at:

　　https://www.gnu.org/licenses/gpl-3.0.html

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.

------------------------------------------------------------------------------------------------------------------

Apache License, Version 2.0, 2004 年 1 月（日本語版：非公式）
http://www.apache.org/licenses/

Cryptography
Copyright (c) 2013-2024, PyCA
All rights reserved.

Pympler
Copyright (c) 2008-2024, Jean Brouwers, Ludwig Haehne, Robert Schuppenies
All rights reserved.

Requests
Copyright 2011 Kenneth Reitz
Licensed under the Apache License, Version 2.0 (the "License")

使用、複製、及び配布に関する利用規約

1. 定義。
「ライセンス」とは、本書の第 1 節から第 9 節に定義された使用、複製、及び配布のための条件を意味します。
「ライセンサー」とは、ライセンスを許諾している著作権所有者または著作権所有者により許可された法人を意味します。
「法的実体」とは、行動する法人と、その法人を支配し、またはその法人により支配されている、もしくは共通の支配下にある他
の全ての法人の結合を意味します。この定義の目的のために､「支配」とは､（i）契約またはその他の方法によってその法人の
方向性や管理を直接的または間接的に引き起こす権力、または（ii）発行済株式の 50% 以上の所有、または（iii）その法人の
実質的所有を意味します。
「あなた」（または「あなたの」）とは、このライセンスによって許可された権限を行使する個人または法的実体を意味します。
「ソース」形式とは、ソフトウェアソースコード、ドキュメントソース、及び構成ファイルを含むがこれらに限定されない、修正を
行うための好ましい形式を意味します。
「オブジェクト」形式とは、ソース形式の機械的変換または翻訳の結果として得られるいかなる形式をも意味し、コンパイルされた
オブジェクトコード、生成されたドキュメント、及び他のメディアタイプへの変換を含みますが、これらに限定されません。
「作品」とは、ライセンスの下で利用可能とされる著作物を意味し、ソース形式またはオブジェクト形式のいずれかであり、その
作品に含まれるまたは付随する著作権表示によって示されるものです（例は以下の附属書に示されています）。
「派生作品」とは、ソース形式またはオブジェクト形式のいずれかで、作品に基づく（または作品から派生した）ものであり、その
編集上の改訂、注釈、説明またはその他の修正が全体として独自の著作物を構成するものを意味します。このライセンスの目的の
ために、派生作品は、作品及びその派生作品のインターフェースにリンクされている（または名前でバインドされている）だけで、
分離可能な作品を含みません。
「寄稿」とは、作品の元のバージョン及びその作品または派生作品への修正または追加を含むがこれらに限定されない、著作権所有
者によって意図的にライセンサーに提出された著作物を意味します。この定義の目的のために､「提出された」とは、ライセンサー
またはその代表者に送られたあらゆる形式の電子的、口頭的、または書面による通信を意味し、電子メールリスト、ソースコード
管理システム、及びライセンサーによって管理される、またはその代表者によって管理される課題追跡システムを含みますが、
著作権所有者によって「寄稿ではない」と明示的に記載された通信は除きます。
「寄稿者」とは、ライセンサー及び寄稿がライセンサーに受領され、
その後作品に組み込まれた全ての個人または法的実体を意味します。

2. 著作権ライセンスの許諾。
このライセンスの条件に従うことを条件として、各寄稿者はあなたに対し、作品及びその派生作品をソース形式またはオブジェクト
形式で複製、派生作品の作成、公開展示、公開実行、サブライセンス、及び配布するための永続的、世界的、非独占的、無償、ロイ
ヤルティーフリー、取り消し不可能な著作権ライセンスを許諾します。

3. 特許ライセンスの許諾。
このライセンスの条件に従うことを条件として、各寄稿者はあなたに対し、作品を作成、作成させ、使用、販売の申し出、販売、
輸入、その他の移転を行うための永続的、世界的、非独占的、無償、ロイヤルティーフリー、取り消し不可能な（この節に記載された
場合を除く）特許ライセンスを許諾します。このライセンスは、寄稿者の寄稿のみ、または寄稿と寄稿が提出された作品の組み合わせ
によって必然的に侵害される特許請求にのみ適用されます。あなたが作品または作品に組み込まれた寄稿が直接的または従属的な特許
侵害を構成するとして、いかなる実体に対しても特許訴訟（反訴または反訴を含む）を提起した場合、その作品に対してこの
ライセンスの下であなたに許諾された特許ライセンスは、当該訴訟が提起された日付で終了します。

4. 再配布。
あなたは、修正の有無に関わらず、作品またはその派生作品の複製をあらゆる媒体で、ソース形式またはオブジェクト形式で配布する
ことができます。ただし、以下の条件を満たす必要があります：

（a）作品または派生作品の他の受領者に本ライセンスのコピーを提供しなければなりません。
（b）修正したファイルには、ファイルを変更したことを明記した目立つ通知を付けなければなりません。
（c）あなたが配布する派生作品のソース形式には、作品のソース形式からの全ての著作権、特許、商標、及び帰属通知を保持しな
ければなりませんが、派生作品の一部に関係のない通知は除きます。
（d）作品が配布の一部として「NOTICE」テキストファイルを含んでいる場合、あなたが配布する派生作品には、その NOTICE
ファイルに含まれる帰属通知の可読なコピーを、派生作品の一部に関係のない通知を除いて、次のいずれかの場所に含めなければ
なりません：

派生作品の一部として配布される NOTICE テキストファイル内、ソース形式またはドキュメント内（派生作品と共に提供される
場合）、または派生作品によって生成される表示内（及び第三者通知が通常表示される場所で）。NOTICE ファイルの内容は情報提供
のみを目的としており、ライセンスを変更するものではありません。あなたは、派生作品の配布において、NOTICE テキストの横また
は付録として、自身の帰属通知を追加することができます。ただし、そのような追加の帰属通知は、ライセンスを変更するものとして
解釈されてはなりません。

あなたは、修正に対して自身の著作権表示を追加することができ、また、修正や派生作品全体の使用、複製、または配布に対して追加
または異なるライセンス条件を提供することができます。ただし、あなたの使用、複製、及び配布が本ライセンスの条件に従っている
限りにおいてです。

5. 寄稿の提出。
あなたが明示的に異なる声明をしない限り、あなたによってライセンサーに提出された作品への意図的な寄稿は、追加の条件なしに
本ライセンスの条件の下で行われるものとします。ただし、ここに記載されている事項は、あなたがライセンサーと締結した別の
ライセンス契約の条件を上書きまたは変更するものではありません。

6. 商標。
本ライセンスは、ライセンサーの商号、商標、サービスマーク、または製品名の使用を許諾するものではありませんが、作品の起源を
記述し、NOTICE ファイルの内容を再現するために必要な場合を除きます。

7. 保証の否認。
適用法により要求されるか、書面で合意されない限り、ライセンサーは作品を（各寄稿者はその寄稿を）「現状のまま」提供し、
いかなる種類の保証または条件も明示的にも黙示的にも提供しません。これには、所有権の保証、非侵害、商品性、特定の目的への
適合性の保証または条件が含まれますが、これらに限定されません。あなたは、作品の使用または再配布の適切性を判断する責任を
単独で負い、このライセンスに基づく権限の行使に関連するリスクを引き受けます。

8. 責任の制限。
いかなる場合でも、またいかなる法理論においても（過失を含む不法行為、契約、その他を含む）、適用法により要求されない限り
（意図的及び重大な過失行為など）、または書面で合意されない限り、いかなる寄稿者もあなたに対して、ライセンスの結果として、
または作品の使用または使用不能に起因するいかなる種類の損害についても責任を負いません（これには、善意の喪失、作業の停止、
コンピュータの故障または誤動作、その他の商業的損害または損失を含みますが、これらに限定されません）。寄稿者がそのような
損害の可能性について通知されていた場合でも同様です。

9. 保証または追加責任の受け入れ。
作品またはその派生作品を再配布する際に、あなたはサポート、保証、補償、またはその他の責任義務及び権利の受け入れを提供し、
料金を請求することを選択することができます。ただし、そのような義務を受け入れる場合、あなたは自身の責任でのみ行動し、他の
いかなる寄稿者を代理して行動することはできません。また、あなたがそのような保証または追加責任を受け入れることにより、寄稿
者に対して発生するいかなる責任または請求についても、各寄稿者を補償し、防御し、無害とすることに同意する場合に限ります。

利用規約の終了

附属書：Apache ライセンスをあなたの作品に適用する方法。

Apache ライセンスをあなたの作品に適用するには、以下の定型文通知を、角括弧「[]」で囲まれたフィールドをあなたの識別情報に
置き換えて添付します（角括弧は含めません）。テキストは、ファイル形式に適したコメント構文で囲む必要があります。また、著作
権通知と同じ「印刷されたページ」にファイルまたはクラス名及び目的の説明を含めることをお勧めします。第三者のアーカイブ内
での識別が容易になります。

　　Copyright [yyyy] [著作権所有者の名前]

　　Licensed under the Apache License, Version 2.0 (the "License");
　　you may not use this file except in compliance with the License.
　　You may obtain a copy of the License at

　　　　http://www.apache.org/licenses/LICENSE-2.0

　　Unless required by applicable law or agreed to in writing, software
　　distributed under the License is distributed on an "AS IS" BASIS,
　　WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
　　See the License for the specific language governing permissions and
　　limitations under the License.

（以下はここまでの英語版です）

------------------------------------------------------------------------------------------------------------------

Apache License, Version 2.0, January 2004 (English: Official)
http://www.apache.org/licenses/

Cryptography
Copyright (c) 2013-2024, PyCA
All rights reserved.

Pympler
Copyright (c) 2008-2024, Jean Brouwers, Ludwig Haehne, Robert Schuppenies
All rights reserved.

Requests
Copyright 2011 Kenneth Reitz
Licensed under the Apache License, Version 2.0 (the "License")

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.
"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by
Sections 1 through 9 of this document.
"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.
"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by,
or are under common control with that entity. For the purposes of this definition,
"control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by
contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares,
or (iii) beneficial ownership of such entity.
"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.
"Source" form shall mean the preferred form for making modifications, including but not limited to software source
code, documentation source, and configuration files.
"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form,
including but not limited to compiled object code, generated documentation, and conversions to other media types.
"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License,
as indicated by a copyright notice that is included in or attached to the work (an example is provided in
the Appendix below).
"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the
Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole,
an original work of authorship. For the purposes of this License, Derivative Works shall not include works that
remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.
"Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or
additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in
the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of
the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or
written communication sent to the Licensor or its representatives, including but not limited to communication on
electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or
on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that
is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution."
"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been
received by Licensor and subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants
to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce,
prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and
such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to
You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section)
patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work,
where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed
by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s)
was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a
lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or
contributory patent infringement, then any patent licenses granted to You under this License for
that Work shall terminate as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium,
with or without modifications, and in Source or Object form, provided that You meet the following conditions:

(a) You must give any other recipients of the Work or Derivative Works a copy of this License; and
(b) You must cause any modified files to carry prominent notices stating that You changed the files; and
(c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent,
trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to
any part of the Derivative Works; and
(d) If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You
distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those
notices that do not pertain to any part of the Derivative Works, in at least one of the following places:
within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation,
if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever
such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not
modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or
as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be
construed as modifying the License.

You may add Your own copyright statement to Your modifications and may provide additional or different license terms
and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a
whole, provided Your use, reproduction, and distribution of the Work otherwise complies with
the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for
inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any
additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any
separate license agreement you may have executed with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or
product names of the Licensor, except as required for describing the origin of the Work and
reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work
(and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE,
NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for
determining the appropriateness of using or redistributing the Work and assume any risks associated with
Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract,
or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing,
shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or
consequential damages of any character arising as a result of this License or out of the use or inability to use the
Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any
and all other commercial damages or losses), even if such Contributor
has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof,
You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability
obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only
on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to
indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against,
such Contributor by reason of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by
brackets "[]" replaced with your own identifying information. (Don't include the brackets!) The text should be
enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and
description of purpose be included on the same "printed page" as the copyright notice for easier
identification within third-party archives.

　　Copyright [yyyy] [name of copyright owner]

　　Licensed under the Apache License, Version 2.0 (the "License");
　　you may not use this file except in compliance with the License.
　　You may obtain a copy of the License at

　　　　http://www.apache.org/licenses/LICENSE-2.0

　　Unless required by applicable law or agreed to in writing, software
　　distributed under the License is distributed on an "AS IS" BASIS,
　　WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
　　See the License for the specific language governing permissions and
　　limitations under the License.

------------------------------------------------------------------------------------------------------------------

ISC ライセンス（日本語版）
Copyright (c) 2013-2024, The Requests Project Authors.
Copyright (c) 2013-2024, The Requests-oauthlib Project Authors.

本ソフトウェアは、上記の著作権表示と本許可表示が全てのコピーに記載されていることを条件に、料金の支払いの有無に関わらず、
あらゆる目的で使用、複製、変更、及び／または配布することを許可します。本ソフトウェアは「現状のまま」提供され、
著者は本ソフトウェアに関して、商品性及び特定の目的への適合性を含む全ての明示的または黙示的な保証を否認します。
契約行為、不法行為、その他の行為の如何を問わず、本ソフトウェアの使用または性能に起因または関連して発生した使用、
データまたは利益の損失、または特殊、直接、間接、または結果的な損害について、著者は一切の責任を負わないものとします。

（以下はここまでの英語版です）

------------------------------------------------------------------------------------------------------------------

ISC License (English)
Copyright (c) 2013-2024, The Requests Project Authors.
Copyright (c) 2013-2024, The Requests-oauthlib Project Authors.

Permission to use, copy, modify, and/or distribute this software for any purpose with
or without fee is hereby granted, provided that the above copyright notice and this
permission notice appear in all copies. THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR
DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

------------------------------------------------------------------------------------------------------------------

　本アプリケーションは、ライセンス「GNU General Public License version 3 (GPLv3)」に基づいて開発され、
配布されています。GPL ライセンスは、ユーザーにソフトウェアを自由に使用、共有、変更する権利を与えます。
　このライセンスの下では、ユーザーは自由にソフトウェアを使用し、改良し、及び改良したソフトウェアを再配布
することができます。再配布を行う場合は、改良元と同じく GPL ライセンスの下で行う必要があります。
　GPLv3 の全文には、以下の URL からアクセスできます。

　　http://www.gnu.org/licenses/gpl-3.0.html

　本アプリケーションのソースコードは無条件で提供されます。
　本アプリケーションのソースコードが必要な場合は、以下のメールアドレスにメールしてください。
日本語を母語としないユーザーは、英語でメールしてください。

　　Mail：bitbuyer.0.8.1.a@icloud.com（件名には "bitBuyer 0.8.1.a" を必ず含めてください）

　ソースコードの送り先と方法を任意のものに指定する必要がある場合は、メールでその旨をお知らせください。
その場合、返信には数日を要します。

（以下はここまでの英語版です）

------------------------------------------------------------------------------------------------------------------

 This application is developed and distributed under the license "GNU General Public License version 3 (GPLv3)".
 The GPL license grants users the freedom to use, share, and modify the software.
 Under this license, users are free to use the software, make improvements, and redistribute the improved software.
 When redistributing, it must be done under the same GPL license.
 The full text of GPLv3 can be accessed at the following URL:

　　http://www.gnu.org/licenses/gpl-3.0.html

 The source code of this application is provided unconditionally.
 If you require the source code of this application, please email the following address.
 Users who do not speak Japanese as their native language should email in English.

　　Mail: bitbuyer.0.8.1.a@icloud.com (Please make sure to include "bitBuyer 0.8.1.a" in the subject line)

 If you need to specify a particular method or destination for the source code delivery, please let us know via email.
 Please note that it may take a few days to receive a response.""")
        self.Manual_cntnr_layout.addWidget(self.Manual_Text)  # インスタンスを「使い方」のコンテナのレイアウトに追加

        self.LogManager.InsertLOG("メインフレーム：タブ 1 初期化完了", self.一般)

        #############################################
        # ### 以下メインフレーム「接続先編集」タブの記述 ###
        #############################################

        ####################
        # ### 骨組みを作成 ###
        ####################

        # 編集メニューのフレームを作成し、クラス（self）属性に設定
        self.EditAccess_Menu = QtWidgets.QFrame(self.Tab_2)  # QFrame のインスタンスを作成（編集メニューのフレームの文脈のため QFrame を選択）
        self.EditAccess_Menu.setStyleSheet(self.FrameStyle)  # 対応するスタイルシートを設定
        self.Tab_2_layout.addWidget(self.EditAccess_Menu)  # インスタンスをメインフレームのタブウィジェットのレイアウトに追加

        # 編集メニューのフレームにレイアウトを定義（編集メニューの内容を管理するレイアウトマネージャ）し、クラス（self）属性に設定
        self.EditAccess_Menu_layout = QtWidgets.QHBoxLayout(self.EditAccess_Menu)  # 水平レイアウトのインスタンスを作成
        self.EditAccess_Menu_layout.setContentsMargins(10, 20, 20, 0)  # レイアウトのマージンを設定
        self.EditAccess_Menu_layout.setSpacing(10)  # レイアウト内のウィジェット間の間隔を設定

        # 編集フォームを包摂するコンテナを作成し、クラス（self）属性に設定
        self.EditAccess_EditArea = QtWidgets.QWidget(self.Tab_2)  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
        self.EditAccess_EditArea.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
        self.Tab_2_layout.addWidget(self.EditAccess_EditArea)  # インスタンスをメインフレームのタブウィジェットのレイアウトに追加
        """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

        # 編集フォームを包摂するコンテナにレイアウトを定義（編集フォームとテキストを管理するレイアウトマネージャ）し、クラス（self）属性に設定
        self.EditAccess_EditArea_layout = QtWidgets.QHBoxLayout(self.EditAccess_EditArea)  # 水平レイアウトのインスタンスを作成
        self.EditAccess_EditArea_layout.setContentsMargins(10, 20, 20, 0)  # レイアウトのマージンを設定
        self.EditAccess_EditArea_layout.setSpacing(10)  # レイアウト内のウィジェット間の間隔を設定

        # 編集フォームのフレームのスクロールエリアを作成し、クラス（self）属性に設定
        self.EditAccess_EditScroll = QScrollArea(self.EditAccess_EditArea)  # QScrollArea のインスタンスを作成
        self.EditAccess_EditScroll.setStyleSheet(self.ScrollStyle)  # 対応するスタイルシートを設定
        self.EditAccess_EditArea_layout.addWidget(self.EditAccess_EditScroll)  # インスタンスを編集フォームを包摂するコンテナのレイアウトに追加
        # スクロールエリア内のウィジェットのサイズ変更を許可し、それに応じエリアを調整するよう設定
        self.EditAccess_EditScroll.setWidgetResizable(True)

        # 編集フォームのフレームを作成し、クラス（self）属性に設定
        self.EditAccess_EditForm = QtWidgets.QFrame()  # QFrame のインスタンスを作成（編集フォームのフレームの文脈のため QFrame を選択）
        self.EditAccess_EditForm.setStyleSheet(self.FrameStyle)  # 対応するスタイルシートを設定
        self.EditAccess_EditScroll.setWidget(self.EditAccess_EditForm)  # インスタンスをスクロールエリアのウィジェットとして設定

        # 編集フォームのフレームにレイアウトを定義（編集フォームの内容を管理するレイアウトマネージャ）し、クラス（self）属性に設定
        self.EditAccess_EditForm_layout = QtWidgets.QVBoxLayout(self.EditAccess_EditForm)  # 垂直レイアウトのインスタンスを作成
        self.EditAccess_EditForm_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
        self.EditAccess_EditForm_layout.setSpacing(5)  # レイアウト内のウィジェット間の間隔を設定

        #######################
        # ### コンテンツを作成 ###
        #######################

        # 編集メニューの接続先選択プルダウンを作成し、クラス（self）属性に設定
        self.EditAccess_Pull = QtWidgets.QComboBox(self.EditAccess_Menu)  # QComboBox のインスタンスを作成
        self.EditAccess_Pull.setStyleSheet(self.PullStyle)  # 対応するスタイルシートを設定
        self.EditAccess_Menu_layout.addWidget(self.EditAccess_Pull)  # インスタンスを編集メニューのフレームのレイアウトに追加

        self.EditAccess_Menu_btns = QtWidgets.QButtonGroup(self.EditAccess_Menu)  # 編集メニューの QButtonGroup のインスタンスを作成

        # 編集メニューの各種ボタンを配置
        for InternalName, Label, StyleName in self.EditAccess_Menu_BtnsLabels:  # 編集メニューの各種ボタンを定義するためのイテレーション
            self.Btn = QtWidgets.QPushButton(Label, self.EditAccess_Menu)  # QPushButton のインスタンスを作成
            self.Btn_style = getattr(self, StyleName, None)  # 対応するスタイルシートを取得
            self.Btn.setStyleSheet(self.Btn_style)  # 対応するスタイルシートを設定
            self.Btn.installEventFilter(self)  # マウスホバー時のポインタ表示を変更するためのメソッドを呼び出し
            self.EditAccess_Menu_layout.addWidget(self.Btn)  # インスタンスを編集メニューのフレームのレイアウトに追加
            self.EditAccess_Menu_btns.addButton(self.Btn)  # 編集メニューの QButtonGroup にボタンを追加
            setattr(self, str(InternalName), self.Btn)  # InternalName を使用してクラス（self）属性として保存

        self.EditAccess_EditForm_btns = QtWidgets.QButtonGroup(self.EditAccess_EditForm)  # 編集フォームの QButtonGroup のインスタンスを作成

        # 編集フォームのラベルと入力欄及びテストボタンのウィジェットを作成
        for PresetIndex, InternalName, DisplayName, DataAddress in self.Connections:  # 編集フォームを定義するためのイテレーション
            # 編集フォームの行コンテナを作成し、クラス（self）属性に設定
            # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.EditAccess_EditRow = QtWidgets.QWidget(self.EditAccess_EditForm)
            self.EditAccess_EditRow.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            self.EditAccess_EditForm_layout.addWidget(self.EditAccess_EditRow)  # インスタンスを編集フォームのフレームのレイアウトに追加
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # 編集フォームの行コンテナにレイアウトを定義（編集フォームの行内容を管理するレイアウトマネージャ）し、クラス（self）属性に設定
            self.EditAccess_EditRow_layout = QtWidgets.QHBoxLayout(self.EditAccess_EditRow)  # 水平レイアウトのインスタンスを作成
            self.EditAccess_EditRow_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.EditAccess_EditRow_layout.setSpacing(self.LabelSpacing)  # レイアウト内のウィジェット間の間隔を設定

            if "データパスをテスト" not in DisplayName:  # "データパスをテスト" ボタン以外の定義
                # 編集フォームのラベルを作成
                self.EditAccess_EditRow_Label = QtWidgets.QLabel(DisplayName, self.EditAccess_EditRow)  # QLabel のインスタンスを作成
                self.EditAccess_EditRow_Label.setStyleSheet(self.LabelStyle)  # 対応するスタイルシートを設定
                # インスタンスを編集フォームの行コンテナのレイアウトに追加
                self.EditAccess_EditRow_layout.addWidget(self.EditAccess_EditRow_Label)

                # 特定のラベルの場合
                if any(Check in DisplayName for Check in {"同メソッド：", "同パラメータ：", "同データパス：", "JSON サンプル：",}):
                    self.EditAccess_EditRow_Label.setAlignment(Qt.AlignRight)  # ラベルを右揃えに整列

                self.ConnectionLabels[InternalName] = self.EditAccess_EditRow_Label  # 編集フォームのラベルを配列に格納

                # 編集フォームのエントリーを作成し、クラス（self）属性に設定
                if not any(Check in DisplayName for Check in {"同データパス：", "JSON サンプル：",}):  # 特定の DisplayName 以外の場合
                    self.EditAccess_EditRow_Entry = QtWidgets.QLineEdit(self.EditAccess_EditRow)  # QLineEdit のインスタンスを作成
                    self.EditAccess_EditRow_Entry.setObjectName(str(InternalName))  # InternalName を使用してオブジェクト名を設定
                    self.EditAccess_EditRow_Entry.setStyleSheet(self.EntryStyle)  # 対応するスタイルシートを設定
                    # インスタンスを編集フォームの行コンテナのレイアウトに追加
                    self.EditAccess_EditRow_layout.addWidget(self.EditAccess_EditRow_Entry)
                else:  # 特定の DisplayName（"同データパス："、"JSON サンプル："）の場合
                    self.EditAccess_EditRow_Entry = QtWidgets.QTextEdit(self.EditAccess_EditRow)  # QTextEdit のインスタンスを作成
                    self.EditAccess_EditRow_Entry.setObjectName(str(InternalName))  # InternalName を使用してオブジェクト名を設定
                    self.EditAccess_EditRow_Entry.setFixedHeight(100)  # QTextEdit の高さを設定（px）
                    self.EditAccess_EditRow_Entry.setStyleSheet(self.TextStyle)  # 対応するスタイルシートを設定
                    # テキストの折り返し方法を指定ピクセル幅に設定（DisplayClass でリサイズ）
                    self.EditAccess_EditRow_Entry.setLineWrapMode(QTextEdit.FixedPixelWidth)
                    # インスタンスを編集フォームの行コンテナのレイアウトに追加
                    self.EditAccess_EditRow_layout.addWidget(self.EditAccess_EditRow_Entry)

                self.ConnectionEntries[InternalName] = self.EditAccess_EditRow_Entry  # 編集フォームのエントリーを配列に格納
            else:  # "データパスをテスト" ボタンの定義
                # 編集フォームの行コンテナのマージンを上書き
                self.EditAccess_EditRow_layout.setContentsMargins(0, 0, (self.ScrllBarWdth - self.LabelSpacing), 0)

                self.EditAccess_EditRow_layout.addStretch(1)  # 余白を吸収

                # テストボタンを作成し、クラス（self）属性に設定
                self.Btn = QtWidgets.QPushButton(DisplayName, self.EditAccess_EditRow)  # QPushButton のインスタンスを作成
                self.Btn.setObjectName(str(InternalName))  # InternalName を使用してオブジェクト名を設定
                self.Btn.setStyleSheet(self.BtnStyle)  # 対応するスタイルシートを設定
                self.Btn.installEventFilter(self)  # マウスホバー時のポインタ表示を変更するためのメソッドを呼び出し
                self.EditAccess_EditRow_layout.addWidget(self.Btn)  # インスタンスを編集フォームの行コンテナのレイアウトに追加
                self.EditAccess_EditForm_btns.addButton(self.Btn)  # 編集フォームの QButtonGroup にボタンを追加

                self.ConnectionBtns[InternalName] = self.Btn  # 編集フォームのボタンを配列に格納

            self.EditAccess_EditRow_layout.addStretch()  # 余白を吸収

        # 「接続先について」のテキストを作成し、クラス（self）属性に設定
        self.EditAccess_Text = QtWidgets.QTextEdit(self.EditAccess_EditArea)  # QTextEdit のインスタンスを作成
        self.EditAccess_Text.setStyleSheet(self.TextStyle)  # 対応するスタイルシートを設定
        self.EditAccess_Text.setLineWrapMode(QTextEdit.FixedPixelWidth)  # テキストの折り返し方法を指定ピクセル幅に設定（DisplayClass でリサイズ）
        self.EditAccess_Text.setReadOnly(True)  # 編集モードを編集不可に設定
        self.EditAccess_Text.setText((  # テキストを設定（リッチテキストを使用可能）
"　このタブはデバッグ用に用意されたものです。{0}"
"接続先データの編集は可能ですが、編集した結果正しく動作しなくなる場合があります。{0}"
"　ソースコードの提供を受けた方は、このタブでデバッグを行うことができます。{0}"
"{0}"
"{0}"
"【接続先について】{0}"
"　このアプリケーションでは「bitFlyer」でのみ正常な動作を確認しております。{0}"
"　従いまして、これ以外の取引所または販売所での動作はサポート対象外となります。{0}"
"　アプリケーションの汎用性向上のための比較サンプルとして「bitbank」「BitTrade」「Coincheck」「GMOコイン」の API ドキュメントを参照し、設計に反映しており"
"ますが、このアプリケーションはこれらの取引所を直接的にはサポートしておりません。{0}"
"これらの取引所は、あくまで API ドキュメントの内容を設計に反映しているのみであり、実際の動作テストは行っていないことをご承知おきください。{0}"
"{0}"
"{0}"
"【設定方法】{0}"
"各サービス元の API ドキュメントをご参照の上、以下の説明に沿ってご入力ください。{0}"
"{0}"
"接続先 URL：API のドメインをご入力ください。形式は、http から始まり .com などで終わるようにしてください。エンドポイント毎にドメインが異なる場合、null と"
"ご入力の上、パスとしてフルパスをご入力ください。{0}"
"{0}"
"パス：接続先 URL に続くアドレスをご入力ください。形式は、デフォルトの「bitFlyer」を選択して表示されるものに倣ってください。またアドレス自体に後述のパラメータ"
"を含めるパターンを採用している取引所も存在します。その場合は{0}"
"{0}"
"/v1/account/accounts/[アカウントID]/balance{0}"
"{0}"
"のように、パラメータを「[]」で囲んでご入力ください。この形式に対応しているパラメータは、後述のパラメータリストに含まれるものに限ります。リストをご確認の上、"
"ご入力ください。{0}"
"{0}"
"メソッド：GET または POST をご入力ください。この他のメソッドも存在しますが、それらの入力が必要な場合、現時点では「bitbank」「BitTrade」「Coincheck」"
"「GMOコイン」のみの「机上対応」となります。{0}"
"{0}"
"パラメータ：指定可能な値は以下の通りです。複数ご入力の際は半角スペースで区切ってご入力ください。{0}"
"{0}"
"※必要なパラメータのご入力がない場合、アプリケーションは正常に動作いたしません。{0}"
"{0}"
"●「商品」商品コード。プロダクトコードや pear とも表記されます。{0}"
"{0}"
"●「年月日」情報を取得する際に日付を指定するように記載がありましたらご入力ください。{0}"
"{0}"
"●「ページ」count、before、after を指定するように記載がありましたらご入力ください。{0}"
"{0}"
"●「グループ」板情報取得時の価格集約度を指定するように記載がありましたらご入力ください。システムは「step0」を指定します。{0}"
"{0}"
"●「方向」注文時の売買方向を指定するように記載がありましたらご入力ください。{0}"
"{0}"
"●「種別」注文時の指値、成行注文の別を指定するように記載がありましたらご入力ください。{0}"
"{0}"
"●「方向と種別」注文時の「売買方向」と「指値、成行注文の別」を一つの値として指定するように記載がありましたらご入力ください。システムは「buy-limit」"
"「sell-limit」「buy-market」「sell-market」のいずれかを指定します。{0}"
"{0}"
"●「価格」注文時の価格を指定するように記載がありましたらご入力ください。{0}"
"{0}"
"●「逆価格」注文時の「価格」と同時に逆指値を指定するように記載がありましたらご入力ください。{0}"
"{0}"
"●「数量」注文時の数量を指定するように記載がありましたらご入力ください。{0}"
"{0}"
"●「注文番号64」注文時の注文 ID を指定するように記載がありましたらご入力ください。システムが 64 文字の ID を作成します。{0}"
"{0}"
"●「注文ID_or_受付ID」注文取消時の「bitFlyer」専用の値です。{0}"
"{0}"
"●「注文ID」注文取消時の注文 ID を指定するように記載がありましたらご入力ください。{0}"
"{0}"
"●「注文IDリスト」注文取消時の注文 ID リストを指定するように記載がありましたらご入力ください。{0}"
"{0}"
"●「注文状態」注文一覧取得時の注文状態を指定するように記載がありましたらご入力ください。システムは「ACTIVE」「COMPLETED」「CANCELED」「EXPIRED」"
"「REJECTED」のいずれかを指定します。{0}"
"{0}"
"●「アカウントID」アカウント ID を指定するように記載がありましたらご入力ください。{0}"
"{0}"
"データパス：以下に詳細な設定方法を示します。{0}"
"　「項目名/レスポンスデータのパス:期待値」の形式を取ります。レスポンスデータのパスは、ドキュメントのレスポンスサンプルを参照してドット区切りでご入力ください。"
"サンプル内に「[]」で囲まれた箇所がある場合、リスト形式となっていることを表していますので、データパスの「[」の位置に相当する箇所に「[index]」とご入力ください。"
"以下に例を示します。{0}").format(self.LF) +
"""
{
    "success": "ok",
    "data": [
        {"data1": "value1"},
        {"data2": "value2"}
    ]
}

""" +
("このサンプルの場合「data1」の値を取得するには、以下のデータパスが必要になります。{0}"
"{0}"
"項目名/data.[index].data1:期待値{0}"
"{0}"
"　また、データパスの後に「:期待値」とする必要がある場合があります。その場合「期待値」は具体的な期待値の内容に置き換えられます。先程のサンプルを例に「success」"
"が「ok」であることを期待する場合の例を以下に示します。{0}"
"{0}"
"項目名/success:ok{0}"
"{0}"
"　また、サンプルのように「成功時の値（ok）は示されているが、失敗時の値は示されていない」場合があります。そのような場合、否定的期待値を使用することができます。"
"以下に否定的期待値の使用例を示します。{0}"
"{0}"
"項目名/success!:ok{0}"
"{0}"
"　このように、否定的期待値（この例では成功時の値とは違う値で真と評価）は「:」の前に「!」を付け加えた「!:」で表すことができます。否定的期待値を使用することで"
"「失敗時の値が示されていない」場合でも､「成功時とは違う値で失敗」と判断するように指定することができます。{0}"
"{0}"
"　また、本来ならリストアップされたレスポンスデータを期待しているところが、リストになっていないデータを返されることがあります。このことに起因する問題は、システム"
"内でのデータの取り扱い方に関する技術的な問題ですので、この部分の説明で不明点があり、かつ未対応の取引所を登録した際に「データパスをテスト」でレスポンスサンプル"
"から正しく値の取得ができない、またはエラーが発生する、または正常に動作しない場合は、開発者にご連絡ください（誠意をもって対応させていただきますが、必ずしもご期待"
"には沿えないことをご了承ください）。{0}"
"　以下は「Coincheck」の該当する例です（「資産残高取得」のレスポンスサンプル）。{0}").format(self.LF) +
"""
{
    "success": "true",
    "jpy": 108401,
    "btc": 7.75052654,
    ...
}

""" +
(r"　このように一見するとリストになっているように見えますが、これは「{}」で囲まれた辞書型のデータであり「[]」で囲まれていないので、リスト型のデータでは"
"ありません｡") +
("「jpy」と「btc」は値ではなくキーとして同一階層上に併記されており、それぞれ「数量」を値として持っています。従って、通貨名は値としては存在していません。しかし、"
"システム内では通貨名も値として扱い、数量も含めて以下のように取り扱うことを前提としています。{0}").format(self.LF) +
"""
[
    [jpy, {"数量": 108401, "可処分": ...,},],
    [btc, {"数量": 7.75052654, "可処分": ...,},],
]

""" +
("　このようなデータ構造の不整合を解決するために、アプリケーションでは「[list]」「[listup]」タグを用意しています。「[list]」タグは、リストにするべき（リスト"
"になっていない）項目名を指定するものです。そして「[listup]」タグは、値として抽出したいデータパスのキー（この場合は「jpy」と「btc」）を指定するために使います。"
"以下に使用例を示します。{0}"
"{0}"
"[list]通貨/[listup]jpy [list]通貨/[listup]btc [list]数量/jpy [list]数量/btc{0}"
"{0}"
"　「通貨」と「数量」ではいずれもデータパス部分（「/」の右側）で指定しているパス（キー）は同じですが､「[listup]」でタグ付けされているパスに対しては値（数量）の"
"取得処理は行わず、キー自体を値として取り扱います。その後、項目名「数量」で改めて数量の取得を行い、対応するリストに値を格納します。このように適切に「[list]」"
"「[listup]」タグを使用することで、対応可能な取引所の幅を広げることができます。{0}"
"{0}"
"{0}"
"以下はシステムで取り扱い可能な項目名と期待値の種類です。{0}"
"※項目名に対応するデータがレスポンスサンプルに存在しない場合は「項目名/null」とするか、項目名の入力自体を消去してください。{0}"
"※同じ項目名に対する期待値の解説は省略いたします。{0}"
"{0}"
"●「約定履歴取得」で指定可能な項目名と期待値{0}"
"　項目名：「買い」「売り」「価格」「数量」「日時」{0}"
"{0}"
"　期待値：「買い」「売り」では、それぞれどのような単語や値で「買い」「売り」が表現されるかを指定します（例：buy）。「日時」では、どのような形式で日時データが"
"提供されるかを指定します。指定方法は以下から選べます｡「UnixTime（Unix タイムスタンプ）」「MilliUnixTime（ミリ秒単位の Unix タイムスタンプ）」。日時データ"
"が日時を表す文字列で提供される場合、以下から指定方法を選べます。「TimeZoneAsia-Tokyo（地域/都市名、または UTC は、適切なものを指定してください）」"
"「LocalTime（世界標準時間ではないことは分かっているものの、地域/都市名が分からない場合に使用、または日本在住の場合は「TimeZoneAsia-Tokyo」と同じ意味でも"
"使用可能、ただし日時データの文字列がタイムゾーン情報を含まない場合に限り正しく動作します）」{0}"
"{0}"
"●「Ticker 取得」で指定可能な項目名と期待値{0}"
"　項目名：「商品」「日時」「TickID」「買高値」「売安値」「買高値数量」「売安値数量」「買深度」「売深度」「買付可能注文量」「売付可能注文量」「最終取引価格」"
"「一日取引量」{0}"
"{0}"
"　期待値：未解説の期待値はありません。{0}"
"{0}"
"●「板情報取得」で指定可能な項目名と期待値{0}"
"　項目名：「仲値」「買い」「売り」「買い価格」「買い数量」「売り価格」「売り数量」{0}"
"{0}"
"　期待値：未解説の期待値はありません。{0}"
"{0}"
"●「板の状態取得」で指定可能な項目名と期待値{0}"
"　項目名：「商品」「取引所稼働」「取引所高負荷」「取引所非稼働」「板稼働」「板非稼働」「最小注文数量」{0}"
"{0}"
"　期待値：各種稼働状態を指定する項目名に対しては、取引所が返す稼働状態の表現を指定します。その際、複数の単語から構成される一つの表現が存在する場合は、各単語間を"
"「_」で区切ります。例えば取引所の稼働状態を表す「SUPER-BUSY」という表現が存在する場合（該当する項目名：取引所高負荷）、期待値としての指定は「SUPER_BUSY」と"
"なります。単一の単語の場合はそのまま指定してください。また値が複数存在する場合は、各値を「,」で区切ります。このとき、スペースは使用しません。例えば取引所の稼働"
"状態を表す「BUSY」「SUPER-BUSY」という表現が存在する場合、いずれも該当する項目名は「取引所高負荷」となります。従って項目名「取引所高負荷」に対してこの二つの"
"値を指定する必要がありますが、その際の指定方法は「:BUSY,SUPER_BUSY」となります。{0}"
"{0}"
"●「アカウント情報取得」で指定可能な項目名と期待値{0}"
"　項目名：「アカウントID」{0}"
"{0}"
"　期待値：未解説の期待値はありません。{0}"
"{0}"
"●「資産残高取得」で指定可能な項目名と期待値{0}"
"　項目名：「通貨」「数量」「可処分」{0}"
"{0}"
"　期待値：未解説の期待値はありません。{0}"
"{0}"
"●「証拠金の状態取得」で指定可能な項目名と期待値{0}"
"　項目名：「預入証拠金」「建玉評価損益」「必要証拠金」「維持率」「追証なし」「追証中」「強制追証」「追証額」「追証期限」{0}"
"{0}"
"　期待値：項目名「追証なし」「追証中」「強制追証」について、取引所が使用する表現の指定方法は、前述の「取引所の稼働状態の表現を指定する方法」と同じです。{0}"
"{0}"
"●「新規注文」で指定可能な項目名と期待値{0}"
"　項目名：「成功」「失敗」「注文ID」{0}"
"{0}"
"　期待値：項目名「成功」「失敗」について、取引所が使用する表現の指定方法は、前述の「取引所の稼働状態の表現を指定する方法」と同じですが､「成否はステータスコード"
"で表される」旨の説明がある場合は「StatusCode」と指定してください。{0}"
"{0}"
"●「注文取消」で指定可能な項目名と期待値{0}"
"　項目名：「成功」「失敗」{0}"
"{0}"
"　期待値：未解説の期待値はありません。{0}"
"{0}"
"●「全注文取消」で指定可能な項目名と期待値{0}"
"　項目名：「成功」「失敗」「取消注文ID」{0}"
"{0}"
"　期待値：未解説の期待値はありません。{0}"
"{0}"
"●「注文一覧取得」で指定可能な項目名と期待値{0}"
"　項目名：「注文ID」「商品」「買い」「売り」「指値」「成行」「逆指値」「逆成行」「価格」「平均価格」「数量」「有効注文」「完了注文」「取消注文」「期限切れ注文」"
"「失敗注文」「有効期限」「注文日時」「注文受付ID」「未決済数量」「決済数量」「取消数量」「手数料」{0}"
"{0}"
"　期待値：項目名「指値」「成行」「逆指値」「逆成行」「有効注文」「完了注文」「取消注文」「期限切れ注文」「失敗注文」について、取引所が使用する表現の指定方法は、"
"前述の「取引所の稼働状態の表現を指定する方法」や「成否の表現を指定する方法」と同じです。{0}"
"{0}"
"●「建玉一覧取得」で指定可能な項目名と期待値{0}"
"　項目名：「商品」「買い」「売り」「価格」「数量」「手数料」「スワップポイント」「必要証拠金」「注文日時」「約定日時」「レバレッジ」「評価損益」「SFD比率」{0}"
"{0}"
"　期待値：未解説の期待値はありません。{0}"
"{0}"
"●「取引手数料取得」で指定可能な項目名と期待値{0}"
"　項目名：「商品」「手数料率TakerBase」「手数料率TakerQuote」「手数料率MakerBase」「手数料率MakerQuote」{0}"
"{0}"
"　期待値：未解説の期待値はありません。").format(self.LF))
        self.EditAccess_EditArea_layout.addWidget(self.EditAccess_Text)  # インスタンスを編集フォームを包摂するコンテナのレイアウトに追加
        self.LogManager.InsertLOG("メインフレーム：タブ 2 初期化完了", self.一般)

        ########################################
        # ### 以下メインフレーム「設定」タブの記述 ###
        ########################################

        ####################
        # ### 骨組みを作成 ###
        ####################

        # 接続先設定のタブグループウィジェットのコンテナを作成し、クラス（self）属性に設定
        self.SetTradeTab_cntnr1 = QtWidgets.QWidget(self.Tab_3)  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
        self.SetTradeTab_cntnr1.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
        self.Tab_3_layout.addWidget(self.SetTradeTab_cntnr1)  # インスタンスをメインフレームのタブウィジェットのレイアウトに追加
        """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

        # 接続先設定のタブグループウィジェットのコンテナにレイアウトを定義（タブグループウィジェットを管理するレイアウトマネージャ）し、クラス（self）属性に設定
        self.SetTradeTab_layout1 = QtWidgets.QHBoxLayout(self.SetTradeTab_cntnr1)  # 水平レイアウトのインスタンスを作成
        self.SetTradeTab_layout1.setContentsMargins(0, 20, 0, 0)  # レイアウトのマージンを設定
        self.SetTradeTab_layout1.setSpacing(0)  # レイアウト内のウィジェット間の間隔を設定

        # 接続先設定のタブグループウィジェットを作成し、クラス（self）属性に設定
        self.SetTradeTab = QtWidgets.QTabWidget(self.SetTradeTab_cntnr1)  # QTabWidget のインスタンスを作成
        self.SetTradeTab_layout1.addWidget(self.SetTradeTab)  # インスタンスを接続先設定のタブグループウィジェットのコンテナのレイアウトに追加

        for TabNum in range(1, self.Settings_TabCount + 1):  # メインフレーム「設定」タブの各「接続先」タブのためのイテレーション
            # 接続先のタブウィジェットを作成
            self.Tab_widget = QtWidgets.QWidget(self.SetTradeTab)  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.Tab_widget.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            setattr(self, "SetTradeTab_{0}".format(str(TabNum)), self.Tab_widget)  # TabNum を使用してクラス（self）属性として保存
            """ QTabWidget の子属性としての単なる一つのタブウィジェットには文脈情報は必要ないため、QWidget を使用しています。 """

            # 接続先設定のタブグループウィジェットに接続先のタブウィジェットを追加
            self.SetTradeTab.addTab(self.Tab_widget, "接続先 {0}".format(str(TabNum)))

            # 接続先の各タブウィジェットにレイアウトを定義（タブの内容を管理するレイアウトマネージャ）
            self.Tab_layout = QtWidgets.QVBoxLayout(self.Tab_widget)  # 垂直レイアウトのインスタンスを作成
            self.Tab_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.Tab_layout.setSpacing(0)  # レイアウト内のウィジェット間の間隔を設定
            setattr(self, "SetTradeTab_{0}_layout".format(str(TabNum)), self.Tab_layout)  # TabNum を使用してクラス（self）属性として保存

            # 接続先の各タブウィジェットのスクロールエリアを作成し、クラス（self）属性に設定
            self.SetTradeTab_Scroll = QScrollArea(self.SetTradeTab)  # QScrollArea のインスタンスを作成
            self.SetTradeTab_Scroll.setStyleSheet(self.ScrollStyle)  # 対応するスタイルシートを設定
            self.Tab_layout.addWidget(self.SetTradeTab_Scroll)  # インスタンスを接続先の各タブウィジェットのレイアウトに追加
            # スクロールエリア内のウィジェットのサイズ変更を許可し、それに応じエリアを調整するよう設定
            self.SetTradeTab_Scroll.setWidgetResizable(True)

            # 接続先の各タブウィジェットのコンテンツを包摂するコンテナを作成
            self.SetTradeTab_cntnr2 = QtWidgets.QWidget()  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.SetTradeTab_cntnr2.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            self.SetTradeTab_Scroll.setWidget(self.SetTradeTab_cntnr2)  # インスタンスをスクロールエリアのウィジェットとして設定
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "SetTradeTab_cntnr2_{0}".format(str(TabNum)), self.SetTradeTab_cntnr2)
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # 接続先の各タブウィジェットのコンテンツを包摂するコンテナにレイアウトを定義（接続先の各タブウィジェットのコンテンツを管理するレイアウトマネージャ）
            self.SetTradeTab_layout2 = QtWidgets.QVBoxLayout(self.SetTradeTab_cntnr2)  # 垂直レイアウトのインスタンスを作成
            self.SetTradeTab_layout2.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.SetTradeTab_layout2.setSpacing(20)  # レイアウト内のウィジェット間の間隔を設定
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "SetTradeTab_layout2_{0}".format(str(TabNum)), self.SetTradeTab_layout2)

            # 接続先設定を包摂するコンテナを作成
            # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.SetAccess = QtWidgets.QWidget(self.SetTradeTab_cntnr2)
            self.SetAccess.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            # インスタンスを接続先の各タブウィジェットのコンテンツを包摂するコンテナのレイアウトに追加
            self.SetTradeTab_layout2.addWidget(self.SetAccess)
            setattr(self, "SetAccess_{0}".format(str(TabNum)), self.SetAccess)  # TabNum を使用してクラス（self）属性として保存
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # 接続先設定を包摂するコンテナにレイアウトを定義（接続先設定コンテナとテキストを管理するレイアウトマネージャ）
            self.SetAccess_layout = QtWidgets.QHBoxLayout(self.SetAccess)  # 水平レイアウトのインスタンスを作成
            self.SetAccess_layout.setContentsMargins(10, 20, 20, 0)  # レイアウトのマージンを設定
            self.SetAccess_layout.setSpacing(self.LabelSpacing)  # レイアウト内のウィジェット間の間隔を設定
            setattr(self, "SetAccess_layout_{0}".format(str(TabNum)), self.SetAccess_layout)  # TabNum を使用してクラス（self）属性として保存

            # 接続先設定コンテナを作成
            self.SetAccess_Set = QtWidgets.QFrame(self.SetAccess)  # QFrame のインスタンスを作成（接続先設定の文脈のため QFrame を選択）
            self.SetAccess_Set.setStyleSheet(self.FrameStyle)  # 対応するスタイルシートを設定
            self.SetAccess_layout.addWidget(self.SetAccess_Set)  # インスタンスを接続先設定を包摂するコンテナのレイアウトに追加
            setattr(self, "SetAccess_Set_{0}".format(str(TabNum)), self.SetAccess_Set)  # TabNum を使用してクラス（self）属性として保存

            # 接続先設定コンテナにレイアウトを定義（接続先設定を管理するレイアウトマネージャ）
            self.SetAccess_Set_layout = QtWidgets.QVBoxLayout(self.SetAccess_Set)  # 垂直レイアウトのインスタンスを作成
            self.SetAccess_Set_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.SetAccess_Set_layout.setSpacing(20)  # レイアウト内のウィジェット間の間隔を設定
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "SetAccess_Set_layout_{0}".format(str(TabNum)), self.SetAccess_Set_layout)

            # 接続先設定テキストのコンテナを作成
            # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.SetAccess_Text_cntnr = QtWidgets.QWidget(self.SetAccess)
            self.SetAccess_Text_cntnr.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            self.SetAccess_layout.addWidget(self.SetAccess_Text_cntnr)  # インスタンスを接続先設定を包摂するコンテナのレイアウトに追加
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "SetAccess_Text_cntnr_{0}".format(str(TabNum)), self.SetAccess_Text_cntnr)
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # 接続先設定テキストのコンテナにレイアウトを定義（テキストを管理するレイアウトマネージャ）
            self.SetAccess_Text_layout = QtWidgets.QVBoxLayout(self.SetAccess_Text_cntnr)  # 垂直レイアウトのインスタンスを作成
            self.SetAccess_Text_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.SetAccess_Text_layout.setSpacing(0)  # レイアウト内のウィジェット間の間隔を設定
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "SetAccess_Text_layout_{0}".format(str(TabNum)), self.SetAccess_Text_layout)

            # 接続先選択プルダウンのコンテナを作成
            self.SetExchange = QtWidgets.QWidget(self.SetAccess_Set)  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.SetExchange.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            self.SetAccess_Set_layout.addWidget(self.SetExchange)  # インスタンスを接続先設定コンテナのレイアウトに追加
            setattr(self, "SetExchange_{0}".format(str(TabNum)), self.SetExchange)  # TabNum を使用してクラス（self）属性として保存
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # 接続先選択プルダウンのコンテナにレイアウトを定義（ラベルとプルダウンを管理するレイアウトマネージャ）
            self.SetExchange_layout = QtWidgets.QHBoxLayout(self.SetExchange)  # 水平レイアウトのインスタンスを作成
            self.SetExchange_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.SetExchange_layout.setSpacing(self.LabelSpacing)  # レイアウト内のウィジェット間の間隔を設定
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "SetExchange_layout_{0}".format(str(TabNum)), self.SetExchange_layout)

            # API キー及び API シークレットのラベルのコンテナを作成
            self.APIkey_Labels = QtWidgets.QWidget(self.SetAccess_Set)  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.APIkey_Labels.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            self.SetAccess_Set_layout.addWidget(self.APIkey_Labels)  # インスタンスを接続先設定コンテナのレイアウトに追加
            setattr(self, "APIkey_Labels_{0}".format(str(TabNum)), self.APIkey_Labels)  # TabNum を使用してクラス（self）属性として保存
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # API キー及び API シークレットのラベルのコンテナにレイアウトを定義（ラベルを管理するレイアウトマネージャ）
            self.APIkey_Labels_layout = QtWidgets.QVBoxLayout(self.APIkey_Labels)  # 垂直レイアウトのインスタンスを作成
            self.APIkey_Labels_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.APIkey_Labels_layout.setSpacing(10)  # レイアウト内のウィジェット間の間隔を設定
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "APIkey_Labels_layout_{0}".format(str(TabNum)), self.APIkey_Labels_layout)

            # API キー設定関連ボタンのコンテナを作成
            self.APIkey_btns = QtWidgets.QWidget(self.SetAccess_Set)  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.APIkey_btns.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            self.SetAccess_Set_layout.addWidget(self.APIkey_btns)  # インスタンスを接続先設定コンテナのレイアウトに追加
            setattr(self, "APIkey_btns_{0}".format(str(TabNum)), self.APIkey_btns)  # TabNum を使用してクラス（self）属性として保存
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # API キー設定関連ボタンのコンテナにレイアウトを定義（API キー設定関連ボタンを管理するレイアウトマネージャ）
            self.APIkey_btns_layout = QtWidgets.QHBoxLayout(self.APIkey_btns)  # 水平レイアウトのインスタンスを作成
            self.APIkey_btns_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.APIkey_btns_layout.setSpacing(5)  # レイアウト内のウィジェット間の間隔を設定
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "APIkey_btns_layout_{0}".format(str(TabNum)), self.APIkey_btns_layout)

            # ボーダーラインのコンテナを作成
            # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.Border_cntnr = QtWidgets.QWidget(self.SetTradeTab_cntnr2)
            self.Border_cntnr.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            # インスタンスを接続先の各タブウィジェットのコンテンツを包摂するコンテナのレイアウトに追加
            self.SetTradeTab_layout2.addWidget(self.Border_cntnr)
            setattr(self, "Border_cntnr_{0}".format(str(TabNum)), self.Border_cntnr)  # TabNum を使用してクラス（self）属性として保存
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # ボーダーラインのコンテナにレイアウトを定義（ボーダーラインを管理するレイアウトマネージャ）
            self.Border_layout = QtWidgets.QHBoxLayout(self.Border_cntnr)  # 水平レイアウトのインスタンスを作成
            self.Border_layout.setContentsMargins(10, 0, 20, 0)  # レイアウトのマージンを設定
            self.Border_layout.setSpacing(0)  # レイアウト内のウィジェット間の間隔を設定
            setattr(self, "Border_layout_{0}".format(str(TabNum)), self.Border_layout)  # TabNum を使用してクラス（self）属性として保存

            # ボーダーラインを作成
            self.Border = QtWidgets.QWidget(self.Border_cntnr)  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.Border.setFixedHeight(2)  # QWidget の高さを設定
            self.Border.setStyleSheet("background-color: {0};".format(str(self.BrdrClr)))  # スタイルシートを設定
            self.Border_layout.addWidget(self.Border)  # インスタンスをボーダーラインのコンテナのレイアウトに追加
            setattr(self, "Border_{0}".format(str(TabNum)), self.Border)  # TabNum を使用してクラス（self）属性として保存
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # 自動取引設定画面のコンテナを作成
            self.SetTrade = QtWidgets.QFrame(self.SetTradeTab_cntnr2)  # QFrame のインスタンスを作成（自動取引設定画面の文脈のため QFrame を選択）
            self.SetTrade.setStyleSheet(self.FrameStyle)  # 対応するスタイルシートを設定
            # インスタンスを接続先の各タブウィジェットのコンテンツを包摂するコンテナのレイアウトに追加
            self.SetTradeTab_layout2.addWidget(self.SetTrade)
            setattr(self, "SetTrade_{0}".format(str(TabNum)), self.SetTrade)  # TabNum を使用してクラス（self）属性として保存

            # 自動取引設定画面のコンテナにレイアウトを定義（自動取引設定項目を管理するレイアウトマネージャ）
            self.SetTrade_layout = QtWidgets.QVBoxLayout(self.SetTrade)  # 垂直レイアウトのインスタンスを作成
            self.SetTrade_layout.setContentsMargins(10, 0, 20, 0)  # レイアウトのマージンを設定
            self.SetTrade_layout.setSpacing(20)  # レイアウト内のウィジェット間の間隔を設定
            setattr(self, "SetTrade_layout_{0}".format(str(TabNum)), self.SetTrade_layout)  # TabNum を使用してクラス（self）属性として保存

            # 通貨ペアプルダウンのコンテナを作成
            # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.SetCurrencyPair_cntnr = QtWidgets.QWidget(self.SetTrade)
            self.SetCurrencyPair_cntnr.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            self.SetTrade_layout.addWidget(self.SetCurrencyPair_cntnr)  # インスタンスを自動取引設定画面のコンテナのレイアウトに追加
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "SetCurrencyPair_cntnr_{0}".format(str(TabNum)), self.SetCurrencyPair_cntnr)
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # 通貨ペアプルダウンのコンテナにレイアウトを定義（ラベルとプルダウンを管理するレイアウトマネージャ）
            self.SetCurrencyPair_layout = QtWidgets.QHBoxLayout(self.SetCurrencyPair_cntnr)  # 水平レイアウトのインスタンスを作成
            self.SetCurrencyPair_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.SetCurrencyPair_layout.setSpacing(self.LabelSpacing)  # レイアウト内のウィジェット間の間隔を設定
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "SetCurrencyPair_layout_{0}".format(str(TabNum)), self.SetCurrencyPair_layout)

            # 通貨ペアリスト取得ボタンのコンテナを作成
            # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.GetCurrencyPair_cntnr = QtWidgets.QWidget(self.SetTrade)
            self.GetCurrencyPair_cntnr.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
            self.SetTrade_layout.addWidget(self.GetCurrencyPair_cntnr)  # インスタンスを自動取引設定画面のコンテナのレイアウトに追加
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "GetCurrencyPair_cntnr_{0}".format(str(TabNum)), self.GetCurrencyPair_cntnr)
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # 通貨ペアリスト取得ボタンのコンテナにレイアウトを定義（通貨ペアリスト取得ボタンを管理するレイアウトマネージャ）
            self.GetCurrencyPair_layout = QtWidgets.QHBoxLayout(self.GetCurrencyPair_cntnr)  # 水平レイアウトのインスタンスを作成
            self.GetCurrencyPair_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
            self.GetCurrencyPair_layout.setSpacing(self.LabelSpacing)  # レイアウト内のウィジェット間の間隔を設定
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "GetCurrencyPair_layout_{0}".format(str(TabNum)), self.GetCurrencyPair_layout)

            self.SetTradeTab_layout2.addStretch(1)  # 余白を吸収

            #######################
            # ### コンテンツを作成 ###
            #######################

            # 接続先選択プルダウンのラベルを作成
            self.Exchange_Label = QtWidgets.QLabel("接続先取引所：", self.SetExchange)  # QLabel のインスタンスを作成
            self.Exchange_Label.setStyleSheet(self.LabelStyle)  # 対応するスタイルシートを設定
            self.SetExchange_layout.addWidget(self.Exchange_Label)  # インスタンスを接続先選択プルダウンのコンテナのレイアウトに追加
            setattr(self, "Exchange_Label_{0}".format(str(TabNum)), self.Exchange_Label)  # TabNum を使用してクラス（self）属性として保存

            # 接続先選択プルダウンを作成
            self.Exchange_Pull = QtWidgets.QComboBox(self.SetExchange)  # QComboBox のインスタンスを作成
            self.Exchange_Pull_attr = "Exchange_Pull_{0}".format(str(TabNum))  # TabNum を使用して属性名を設定
            self.Exchange_Pull.setObjectName(self.Exchange_Pull_attr)  # 属性名を使用してオブジェクト名を設定
            self.Exchange_Pull.setStyleSheet(self.PullStyle)  # 対応するスタイルシートを設定
            self.SetExchange_layout.addWidget(self.Exchange_Pull)  # インスタンスを接続先選択プルダウンのコンテナのレイアウトに追加
            setattr(self, self.Exchange_Pull_attr, self.Exchange_Pull)  # 属性名を使用してクラス（self）属性として保存

            self.SetExchange_layout.addStretch()  # 余白を吸収

            # API キー及び API シークレットのラベルを作成
            self.APIkey_Label = QtWidgets.QLabel("API Key：", self.APIkey_Labels)  # QLabel のインスタンスを作成
            # インスタンスを API キー及び API シークレットのラベルのコンテナのレイアウトに追加
            self.APIkey_Labels_layout.addWidget(self.APIkey_Label)
            setattr(self, "APIkey_Label_{0}".format(str(TabNum)), self.APIkey_Label)  # TabNum を使用してクラス（self）属性として保存
            self.APIsecret_Label = QtWidgets.QLabel("API Secret：", self.APIkey_Labels)  # QLabel のインスタンスを作成
            # インスタンスを API キー及び API シークレットのラベルのコンテナのレイアウトに追加
            self.APIkey_Labels_layout.addWidget(self.APIsecret_Label)
            setattr(self, "APIsecret_Label_{0}".format(str(TabNum)), self.APIsecret_Label)  # TabNum を使用してクラス（self）属性として保存

            # API キー設定関連ボタンの作成
            for InternalName, Label, StyleName in self.APIkey_BtnLabels:  # API キー設定関連ボタンを定義するためのイテレーション
                self.Btn = QtWidgets.QPushButton(Label, self.APIkey_btns)  # QPushButton のインスタンスを作成
                # InternalName と TabNum を使用してオブジェクト名を設定
                self.Btn.setObjectName("{0}_{1}".format(str(InternalName), str(TabNum)))
                self.Btn.setFixedWidth(100)  # QPushButton の幅を設定
                self.Btn_style = getattr(self, StyleName, None)  # 対応するスタイルシートを取得
                self.Btn.setStyleSheet(self.Btn_style)  # 対応するスタイルシートを設定
                self.Btn.installEventFilter(self)  # マウスホバー時のポインタ表示を変更するためのメソッドを呼び出し
                self.APIkey_btns_layout.addWidget(self.Btn)  # インスタンスを API キー設定関連ボタンのコンテナのレイアウトに追加
                # InternalName と TabNum を使用してクラス（self）属性として保存
                setattr(self, "{0}_{1}".format(str(InternalName), str(TabNum)), self.Btn)

            self.APIkey_btns_layout.addStretch()  # 余白を吸収
            self.SetAccess_Set_layout.addStretch()  # 余白を吸収

            self.Exchange_Pull.setFixedWidth(int(  # 接続先選択プルダウンのサイズを調整
                self.APIkey_btns.sizeHint().width() - self.Exchange_Label.sizeHint().width() - self.LabelSpacing))

            # 接続先設定テキストを作成
            self.SetAccess_Text = QtWidgets.QTextEdit(self.SetAccess_Text_cntnr)  # QTextEdit のインスタンスを作成
            self.SetAccess_Text.setFixedHeight(int(self.SetAccess_Set.sizeHint().height()))  # QTextEdit の高さを設定
            self.SetAccess_Text.setStyleSheet(self.TextStyle)  # 対応するスタイルシートを設定
            # テキストの折り返し方法を指定ピクセル幅に設定（DisplayClass でリサイズ）
            self.SetAccess_Text.setLineWrapMode(QTextEdit.FixedPixelWidth)
            self.SetAccess_Text.setReadOnly(True)  # 編集モードを編集不可に設定
            self.SetAccess_Text.setText((  # テキストを設定（リッチテキストを使用可能）
"　このアプリケーションは一度に五つの接続先に対して Engine を稼働させることができるように設計されておりますが、Engine に AI 技術を採用している性質上、"
"ハードウェアの構成条件によってはリソースの多くの割合を要求することになりかねません。{0}"
"　もし一度に複数の接続先に対して Engine を稼働させてこのアプリケーションまたは他のアプリケーションの動作が遅くなるなどの弊害が生じる場合、このアプリケーション"
"の自動取引処理にも影響が及びかねません（取引処理に遅延が生じるなど）。{0}"
"もしそのような状況に陥るようでしたら、ハードウェアのリソースが足りていない可能性がございます。{0}"
"その際は、一度に処理する接続先の数を減らすなどしてご対応ください。{0}"
"{0}"
"　また、Engine の AI は自動取引の判断を行うと同時に学習も行います。しかし、これには多くの計算リソースを必要とするため、学習は接続先 1 でのみ行います。{0}"
"従って、もし特定の取引所の情報を学習に使用したい場合は、その取引所への接続を接続先 1 に設定してください。").format(self.LF))
            self.SetAccess_Text_layout.addWidget(self.SetAccess_Text)  # インスタンスを接続先設定テキストのコンテナのレイアウトに追加
            setattr(self, "SetAccess_Text_{0}".format(str(TabNum)), self.SetAccess_Text)  # TabNum を使用してクラス（self）属性として保存

            self.SetAccess_Text_layout.addStretch()  # 余白を吸収

            # 通貨ペアプルダウンのラベルを作成
            self.SetCurrencyPair_Label = QtWidgets.QLabel("取引設定通貨ペア：", self.SetCurrencyPair_cntnr)  # QLabel のインスタンスを作成
            self.SetCurrencyPair_Label.setStyleSheet(self.LabelStyle)  # 対応するスタイルシートを設定
            self.SetCurrencyPair_layout.addWidget(self.SetCurrencyPair_Label)  # インスタンスを通貨ペアプルダウンのコンテナのレイアウトに追加
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "SetCurrencyPair_Label_{0}".format(str(TabNum)), self.SetCurrencyPair_Label)

            # 通貨ペアプルダウンを作成
            self.SetCurrencyPair = QtWidgets.QComboBox(self.SetCurrencyPair_cntnr)  # QComboBox のインスタンスを作成
            self.SetCurrencyPair_attr = "SetCurrencyPair_{0}".format(str(TabNum))  # TabNum を使用して属性名を設定
            self.SetCurrencyPair.setObjectName(self.SetCurrencyPair_attr)  # 属性名を使用してオブジェクト名を設定
            self.SetCurrencyPair.setFixedWidth(int(  # 通貨ペアプルダウンのサイズを調整
                self.APIkey_btns.sizeHint().width() - self.SetCurrencyPair_Label.sizeHint().width() - self.LabelSpacing))
            self.SetCurrencyPair.setStyleSheet(self.PullStyle)  # 対応するスタイルシートを設定
            self.SetCurrencyPair_layout.addWidget(self.SetCurrencyPair)  # インスタンスを通貨ペアプルダウンのコンテナのレイアウトに追加
            setattr(self, self.SetCurrencyPair_attr, self.SetCurrencyPair)  # 属性名を使用してクラス（self）属性として保存

            # 通貨ペアプルダウンの注意事項ラベルを作成
            # QLabel のインスタンスを作成
            self.SetCurrencyPair_Announce = QtWidgets.QLabel("※ 1 取引所につき 1 ペアのみ設定ください。", self.SetCurrencyPair_cntnr)
            self.SetCurrencyPair_Announce.setStyleSheet(self.LabelStyle)  # 対応するスタイルシートを設定
            self.SetCurrencyPair_layout.addWidget(self.SetCurrencyPair_Announce)  # インスタンスを通貨ペアプルダウンのコンテナのレイアウトに追加
            # TabNum を使用してクラス（self）属性として保存
            setattr(self, "SetCurrencyPair_Announce_{0}".format(str(TabNum)), self.SetCurrencyPair_Announce)

            self.SetCurrencyPair_layout.addStretch()  # 余白を吸収

            # 通貨ペアリスト取得ボタンを作成
            self.GetCurrencyPair = QtWidgets.QPushButton("通貨ペアリスト取得", self.GetCurrencyPair_cntnr)  # QPushButton のインスタンスを作成
            self.GetCurrencyPair.setObjectName("GetCurrencyPair_{0}".format(str(TabNum)))  # TabNum を使用してオブジェクト名を設定
            self.GetCurrencyPair.setFixedWidth(150)  # QPushButton の幅を設定
            self.GetCurrencyPair.setStyleSheet(self.BtnStyle)  # 対応するスタイルシートを設定
            self.GetCurrencyPair.installEventFilter(self)  # マウスホバー時のポインタ表示を変更するためのメソッドを呼び出し
            self.GetCurrencyPair_layout.addWidget(self.GetCurrencyPair)  # インスタンスを通貨ペアリスト取得ボタンのコンテナのレイアウトに追加
            setattr(self, "GetCurrencyPair_{0}".format(str(TabNum)), self.GetCurrencyPair)  # TabNum を使用してクラス（self）属性として保存

            self.GetCurrencyPair_layout.addStretch()  # 余白を吸収

        self.LogManager.InsertLOG("メインフレーム：タブ 3 初期化完了", self.一般)

        ###########################################
        # ### 以下メインフレーム「Engine」タブの記述 ###
        ###########################################

        ####################
        # ### 骨組みを作成 ###
        ####################

        # タブの内容を包摂するスクロールエリアを作成し、クラス（self）属性に設定
        self.EngineTab_Scroll = QScrollArea(self.Tab_4)  # QScrollArea のインスタンスを作成
        self.EngineTab_Scroll.setStyleSheet(self.ScrollStyle)  # 対応するスタイルシートを設定
        self.Tab_4_layout.addWidget(self.EngineTab_Scroll)  # インスタンスをメインフレームのタブウィジェットのレイアウトに追加
        self.EngineTab_Scroll.setWidgetResizable(True)  # スクロールエリア内のウィジェットのサイズ変更を許可し、それに応じエリアを調整するよう設定

        # タブの内容を包摂するコンテナを作成し、クラス（self）属性に設定
        self.EngineTab_cntnr = QtWidgets.QWidget()  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
        self.EngineTab_cntnr.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
        self.EngineTab_Scroll.setWidget(self.EngineTab_cntnr)  # インスタンスをスクロールエリアのウィジェットとして設定
        """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

        # タブの内容を包摂するコンテナにレイアウトを定義（タブの内容を管理するレイアウトマネージャ）し、クラス（self）属性に設定
        self.EngineTab_layout = QtWidgets.QVBoxLayout(self.EngineTab_cntnr)  # 垂直レイアウトのインスタンスを作成
        self.EngineTab_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
        self.EngineTab_layout.setSpacing(20)  # レイアウト内のウィジェット間の間隔を設定

        self.LogManager.InsertLOG("メインフレーム：タブ 4 初期化完了", self.一般)

        ###########################################
        # ### 以下メインフレーム「利益試算」タブの記述 ###
        ###########################################

        ####################
        # ### 骨組みを作成 ###
        ####################

        # タブの内容を包摂するスクロールエリアを作成し、クラス（self）属性に設定
        self.ProfitProjectionTab_Scroll = QScrollArea(self.Tab_5)  # QScrollArea のインスタンスを作成
        self.ProfitProjectionTab_Scroll.setStyleSheet(self.ScrollStyle)  # 対応するスタイルシートを設定
        self.Tab_5_layout.addWidget(self.ProfitProjectionTab_Scroll)  # インスタンスをメインフレームのタブウィジェットのレイアウトに追加
        # スクロールエリア内のウィジェットのサイズ変更を許可し、それに応じエリアを調整するよう設定
        self.ProfitProjectionTab_Scroll.setWidgetResizable(True)

        # タブの内容を包摂するコンテナを作成し、クラス（self）属性に設定
        self.ProfitProjectionTab_cntnr = QtWidgets.QWidget()  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
        self.ProfitProjectionTab_cntnr.setStyleSheet(self.WidgetStyle)  # 対応するスタイルシートを設定
        self.ProfitProjectionTab_Scroll.setWidget(self.ProfitProjectionTab_cntnr)  # インスタンスをスクロールエリアのウィジェットとして設定
        """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

        # タブの内容を包摂するコンテナにレイアウトを定義（タブの内容を管理するレイアウトマネージャ）し、クラス（self）属性に設定
        self.ProfitProjectionTab_layout = QtWidgets.QVBoxLayout(self.ProfitProjectionTab_cntnr)  # 垂直レイアウトのインスタンスを作成
        self.ProfitProjectionTab_layout.setContentsMargins(0, 0, 0, 0)  # レイアウトのマージンを設定
        self.ProfitProjectionTab_layout.setSpacing(20)  # レイアウト内のウィジェット間の間隔を設定

        self.LogManager.InsertLOG("メインフレーム：タブ 5 初期化完了", self.一般)
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # アプリケーションに必要なクラスの初期化中にエラーが発生し、アプリケーションウィンドウが表示されない場合にメッセージボックスを表示する関数
    def ShowMessage_ofAppInitializingError(self, Message):
        """ この部分を「関数の docstring」と言います。
        アプリケーションに必要なクラスの初期化中にエラーが発生し、アプリケーションウィンドウが表示されない場合にメッセージボックスを表示する関数。

        この関数は、このクラスのコンストラクタで他のクラスの初期化中に何らかのエラーが発生し、正しくアプリケーションを起動できず、アプリケーションウィンドウを
        表示できない場合に、エラーが発生しアプリケーションを起動できないことをエラー内容と共にユーザーに知らせる責務を担っています。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Message (str): エラー内容の文字列。

        Returns:
            なし。
        """
        MessageBox = QMessageBox()  # QMessageBox のインスタンスを作成
        MessageBox.setIcon(QMessageBox.Critical)  # メッセージボックスに表示するアイコンを設定
        MessageBox.setWindowTitle("クリティカルエラー")  # メッセージボックスのウィンドウタイトルを設定
        MessageBox.setText("初期化処理中にエラーが発生しました")  # メッセージボックスに表示するテキストを設定
        MessageBox.setInformativeText(Message)  # エラー内容の文字列（str）を表示する設定
        MessageBox.exec_()  # メッセージボックスを表示
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # GUI に関数を割り当て、必要に応じて GUI の表示状態を初期化する関数
    def Init_FUNCTIONS(self):
        """ この部分を「関数の docstring」と言います。
        GUI に関数を割り当て、必要に応じて GUI の表示状態を初期化する関数。

        この関数は、各種 GUI ウィジェットにユーザーインタラクションに対するレスポンスを行う関数を接続します。これにより、ユーザーが GUI を操作した際に
        アプリケーションが反応するようにします。また、この関数では必要に応じて GUI ウィジェットの表示状態を適切な初期状態に初期化します。この関数では PyQt
        フレームワークにおけるシグナルとスロットのメカニズムに過度に依存することのないよう、シグナルが持つパラメータを全て無視しています。これは、この
        アプリケーションが設計方針として特定のフレームワークやライブラリに依存する設計を極力避けることを定めているためです。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        # メインフレーム「接続先編集」タブの編集メニュー「接続先選択」プルダウンに関数を接続
        self.MainFunctions.Init_ExchangePull(self.EditAccess_Pull)  # GUI 表示状態の初期化
        self.EditAccess_Pull.currentIndexChanged.connect(  # プルダウンメニューの選択項目変更の際のシグナルを関数（スロット）に接続
            # ラムダ関数でカスタムパラメータを定義（シグナルのデフォルトのパラメータを無視）
            lambda Index: self.MainFunctions.Trace_ExchangePull(self.EditAccess_Pull, Trace = True))
        """
MainThreadFunctionsClass の関数 Init_ExchangePull() は、メインフレーム「接続先編集」タブの編集メニュー「接続先選択」プルダウンの初期化と共に、
メインフレーム「設定」タブの「接続先選択」プルダウン（各接続先タブ）の初期化も行います。これは、これら二つのプルダウンメニューの内容が同じものであるためです。
しかしそれぞれのプルダウンメニューの持つ役割は各々少し異なるため、関数のパラメータによってこれらを制御します。そして関数の名前から察せられる通り、関数
Trace_ExchangePull() も同様に、二つの異なるプルダウンメニューをパラメータによって管理しています。このアプリケーションでは、同じ内容を持つこれら二つの
プルダウンメニューの微妙に異なる役割を、初期化とトレースそれぞれのステップ毎に一つの関数で管理することで、メンテナンス性の向上を図っています。
        """

        # メインフレーム「接続先編集」タブの編集メニュー「保存」ボタンに関数を接続（ラムダ関数でシグナルのデフォルトのパラメータを無視）
        self.SaveConnections_btn.clicked.connect(lambda Check: self.MainFunctions.SaveAccess())  # シグナル clicked を関数（スロット）に接続

        # メインフレーム「接続先編集」タブの編集メニュー「この接続先を削除」ボタンに関数を接続（ラムダ関数でシグナルのデフォルトのパラメータを無視）
        self.DeleteConnections_btn.clicked.connect(
            lambda Check: self.MainFunctions.DeleteSelectedAccess())  # シグナル clicked を関数（スロット）に接続

        # メインフレーム「接続先編集」タブの編集メニュー「全ての接続先を消去及び復元」ボタンに関数を接続（ラムダ関数でシグナルのデフォルトのパラメータを無視）
        self.DeleteAllConnections_btn.clicked.connect(
            lambda Check: self.MainFunctions.DeleteAllAccess())  # シグナル clicked を関数（スロット）に接続
        """
ここまでの MainThreadFunctionsClass の関数 SaveAccess()、DeleteSelectedAccess()、DeleteAllAccess() に対して、ボタンの内部名に使用している単語が
異なりますが（関数名が Access を使用しているのに対して、ボタン名では Connections を使用）、これは関数の定義側では接続先名（取引所名）を使用して API の機能別
の細かな接続先を一括で管理することを意識しているのに対し、ボタン名では接続先名（取引所名）の中の API の機能別の細かな接続先を意識しているという違いによるものです。
        """

        # メインフレーム「接続先編集」タブの「データパスをテスト」ボタン（各ボタン）に関数を接続するためのイテレーション
        for PresetIndex, InternalName, DisplayName, DataAddress in self.Connections:
            if DisplayName == "データパスをテスト":  # リスト self.Connections の各 Connection 毎に存在する "データパスをテスト" ボタンを検知
                self.ConnectionBtns[InternalName].clicked.connect(  # ラムダ関数でシグナルのデフォルトのパラメータを無視
                    lambda Check: self.MainFunctions.PathTest())  # シグナル clicked を関数（スロット）に接続

        for TabNum in range(1, self.Settings_TabCount + 1):  # メインフレーム「設定」タブの各「接続先」タブのためのイテレーション
            # メインフレーム「設定」タブの「接続先選択」プルダウン（各接続先タブ）に関数を接続
            # TabNum に対応する属性名を設定及びクラス（self）属性の対応する属性から Exchange_Pull を取得
            self.Exchange_Pull = getattr(self, "Exchange_Pull_{0}".format(str(TabNum)), None)
            # プルダウンメニューの選択項目変更の際のシグナルを関数（スロット）に接続
            # （ラムダ関数でカスタムパラメータを定義（シグナルのデフォルトのパラメータを無視））
            self.Exchange_Pull.currentIndexChanged.connect(lambda Index, Exchange_Pull = self.Exchange_Pull, TabNum = TabNum:
                self.MainFunctions.Trace_ExchangePull(Exchange_Pull, Trace = True, TabNum = TabNum))

            # メインフレーム「設定」タブの API キー設定関連ボタンに関数を接続するためのイテレーション
            for InternalName, Label, StyleName in self.APIkey_BtnLabels:
                # InternalName と TabNum に対応する属性名を設定及びクラス（self）属性の対応する属性からボタンの参照を取得
                self.Btn = getattr(self, "{0}_{1}".format(str(InternalName), str(TabNum)))
                # ラムダ関数でシグナルのデフォルトのパラメータを無視
                # シグナル clicked を関数（スロット）に接続
                self.Btn.clicked.connect(lambda Check: self.MainFunctions.APIkeys_BtnResponder())

        # メインフレーム「設定」タブの設定保存対象の GUI ウィジェットのシグナルを設定保存関数（スロット）に接続
        self.MainFunctions.ConnectsSaveProcessor()
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # ウィンドウのサイズ変更イベントをハンドルする関数
    def resizeEvent(self, Event):
        """ この部分を「関数の docstring」と言います。
        この関数は PyQt フレームワークにおいて、ウィンドウのサイズ変更イベント発生時に自動的に呼び出される特殊な関数です。システムによって自動的に呼び出される
        ため、関数名は変更不可であり、また直接呼び出されることもありません。ウィンドウのサイズが変更された際の GUI ウィジェットのリサイズをハンドリングし、適切
        なレイアウト調整やリソースの再配置を行います。リサイズイベントが発生すると、この関数がトリガーされ、DisplayClass の関数 resizeHandler() を呼び出し、
        続けて QWidgets のデフォルトのメソッド resizeEvent() をスーパークラス呼び出しによって実行します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Event: QResizeEvent オブジェクト。ウィンドウの新しいサイズと古いサイズの情報を含む。

        Returns:
            なし。
        """
        self.Display.resizeHandler(Event)  # DisplayClass の関数 resizeHandler() の呼び出し
        super().resizeEvent(Event)  # スーパークラスのリサイズイベント処理の呼び出し
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # インタラクションをサポートする関数
    def eventFilter(self, Obj, Event):
        """ この部分を「関数の docstring」と言います。
        この関数は PyQt フレームワークにおいて、イベント発生時に自動的に呼び出される特殊な関数です。システムによって自動的に呼び出されるため、関数名は変更不可で
        あり、また直接呼び出されることもありません。イベントフィルタリングを通じて、アプリケーションの様々なインタラクションに対応します。そのため将来的に様々な
        役割を持つことになり得ます。この関数は、マウスカーソルがオブジェクト上に入る（Enter）または離れる（Leave）イベントに応じて、カーソルのスタイルを変更
        することで、ユーザーインターフェースの操作性の向上を図ります。現在、マウスカーソルの位置の変更イベントに対応しているのは QPushButton です。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Obj: イベントを受け取る QObject のインスタンス。
            Event: 発生したイベントに関する情報を持つ QEvent のインスタンス。

        Returns:
            QObject のメソッド eventFilter() による標準のイベント処理結果。イベントがフィルタリングされた場合、True。そうでなければ False。
        """
        # マウスポインタがオブジェクトに入るか、または出るイベントをチェック
        if Event.type() == QtCore.QEvent.Enter or Event.type() == QtCore.QEvent.Leave:
            if isinstance(Obj, QtWidgets.QPushButton):  # オブジェクトが QPushButton のインスタンスの場合
                # カーソルタイプを設定：マウスがオブジェクト上にある場合は指を指すカーソル、そうでなければ矢印カーソル
                cursorType = QtCore.Qt.PointingHandCursor if Event.type() == QtCore.QEvent.Enter else QtCore.Qt.ArrowCursor
                AssistanceClass.ChangeCursor(Obj, cursorType)  # オブジェクトのカーソルを変更

        return super().eventFilter(Obj, Event)  # 親クラスのメソッド eventFilter() を呼び出し、残りのイベント処理を行う
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

# ウィジェットの表示に関する処理を行うクラス
class DisplayClass:
    """ この部分を「クラスの docstring」と言います。
    このクラスは、AppClass で定義される各種 GUI ウィジェットの適切なサイズをウィンドウサイズを基に計算し、設定する役割を持ちます。GUI ウィジェットの適切な
    サイズの計算には、AppClass の関数 Init_NAMES() で定義される、GUI ウィジェットのウィンドウサイズに対する割合を使用します。
    """
    # DisplayClass を初期化する関数（コンストラクタ）
    def __init__(self, AppInstance):
        """ この部分を「関数の docstring」と言います。
        DisplayClass を初期化する関数。

        この初期化関数は、DisplayClass の新しいインスタンスを作成します。引数 AppInstance は AppClass のインスタンスを指し、このクラス内で使用されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            AppInstance: AppClass のインスタンス。DisplayClass が操作する AppClass のインスタンスを指定。

        Returns:
            なし。
        """
        # QObject を継承していないのでメソッド "super().__init__()" の呼び出しは不要
        # クラス（self）属性を定義
        self.App = AppInstance  # AppClass のインスタンスを定義
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # ウィンドウのサイズ変更イベントをハンドルする関数
    def resizeHandler(self, Event):
        """ この部分を「関数の docstring」と言います。
        ウィンドウのサイズ変更イベントをハンドルする関数。

        この関数は、ウィンドウのサイズ変更イベントをハンドルする責務を担っています。ウィンドウのサイズが変更された際に、AppClass でオーバーライドしている
        イベントハンドラ resizeEvent() によって自動的に呼び出されるので、その他の部分でこの関数を直接呼び出す必要はありません。

        ウィンドウの横幅に基づいて、サブフレーム及びメインフレームの以下のタブのウィジェットのサイズを調整します：
            サブフレーム「システムログ」の各タブ内のテキストエリア（QTextEdit）。
            メインフレーム「使い方」タブ内のテキストエリア（QTextEdit）。
            メインフレーム「接続先編集」タブ内のラベル（QLabel）、エントリー（QLineEdit）、テキストエリア（QTextEdit）、ボタン（QPushButton）。
            メインフレーム「設定」タブ内のテキストエリア（QTextEdit）。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Event: QResizeEvent オブジェクト。リサイズイベントの情報を持つ。

        Returns:
            なし。
        """
        NewWidth = Event.size().width()  # リサイズされたウィンドウの横幅を取得

        # サブフレーム「システムログ」に対するリサイズ処理
        # リサイズされたウィンドウの横幅にログテキストエリア（QTextEdit）のテキスト折り返しまでの幅の「ウィンドウサイズに対する割合」を乗じる
        self.App.LogText_TextWdth = int(NewWidth * self.App.LogText_TextWght)
        for TabNum, InternalName, DisplayName in self.App.SubFrame_TabNames:  # サブフレームの各タブのためのイテレーション
            # TabNum に対応する属性名を設定及び AppClass（self.App）属性の対応する属性からログテキストエリア（QTextEdit）の参照を取得
            LogText = getattr(self.App, "LogText_{0}".format(str(TabNum)), None)
            LogText.setLineWrapColumnOrWidth(self.App.LogText_TextWdth)  # 先に算出したテキスト折り返し幅を設定

        # メインフレーム「使い方」タブ内のウィジェットに対するリサイズ処理
        # リサイズされたウィンドウの横幅にテキストエリア（QTextEdit）のテキスト折り返しまでの幅の「ウィンドウサイズに対する割合」を乗じる
        self.App.Manual_TextWdth = int(NewWidth * self.App.Manual_TextWght)
        self.App.Manual_Text.setLineWrapColumnOrWidth(self.App.Manual_TextWdth)  # 算出したテキスト折り返し幅を設定

        # メインフレーム「接続先編集」タブ内のウィジェットに対するリサイズ処理
        # リサイズされたウィンドウの横幅に編集用の各テキスト入力欄またはテキストエリアのラベル（QLabel）の「ウィンドウサイズに対する割合」を乗じる
        self.App.EditAccess_EditRow_LblWdth = int(NewWidth * self.App.EditAccess_EditRow_LblWght)
        # リサイズされたウィンドウの横幅に編集用の各テキスト入力欄（QLineEdit）の「ウィンドウサイズに対する割合」を乗じる
        self.App.EditAccess_EditRow_EntWdth = int(NewWidth * self.App.EditAccess_EditRow_EntWght)
        # リサイズされたウィンドウの横幅に編集用の各テキストエリア（QTextEdit）のテキスト折り返しまでの幅の「ウィンドウサイズに対する割合」を乗じる
        self.App.EditAccess_EditRow_TxtWdth = int(NewWidth * self.App.EditAccess_EditRow_TxtWght)
        # 編集フォームのフレームのスクロールエリアの横幅として、内包するオブジェクトの各横幅を足した値を設定
        self.App.EditAccess_EditScroll.setFixedWidth(
            self.App.EditAccess_EditRow_LblWdth + self.App.EditAccess_EditRow_EntWdth + self.App.ScrllBarWdth)
        # 編集フォームの各種ウィジェットを調整するためのイテレーション
        for PresetIndex, InternalName, DisplayName, DataAddress in self.App.Connections:
            if "データパスをテスト" not in DisplayName:  # "データパスをテスト" ボタン以外のウィジェットの場合
                # 編集用の各テキスト入力欄（QLineEdit）またはテキストエリア（QTextEdit）のラベル（QLabel）に、先に算出した横幅を設定
                self.App.ConnectionLabels[InternalName].setFixedWidth(self.App.EditAccess_EditRow_LblWdth)
                # 編集用の各テキスト入力欄（QLineEdit）またはテキストエリア（QTextEdit）に、先に算出した横幅を設定
                # （QTextEdit はメソッド setFixedWidth() を持たないが、QTextEdit は QWidget を継承しているため、間接的に設定可能）
                self.App.ConnectionEntries[InternalName].setFixedWidth(self.App.EditAccess_EditRow_EntWdth)

                if any(Check in DisplayName for Check in {"同データパス：", "JSON サンプル：",}):  # QTextEdit の場合
                    self.App.ConnectionEntries[InternalName].setLineWrapColumnOrWidth(
                        self.App.EditAccess_EditRow_TxtWdth)  # 先に算出したテキスト折り返し幅を設定
            else:  # "データパスをテスト" ボタンの場合
                # 先に算出した横幅を設定（編集用の各テキスト入力欄またはテキストエリアと同じ値を設定）
                self.App.ConnectionBtns[InternalName].setFixedWidth(self.App.EditAccess_EditRow_EntWdth)
        # リサイズされたウィンドウの横幅に説明用のテキストエリア（QTextEdit）のテキスト折り返しまでの幅の「ウィンドウサイズに対する割合」を乗じる
        self.App.EditAccess_TextWdth = int(NewWidth * self.App.EditAccess_TextWght)
        self.App.EditAccess_Text.setLineWrapColumnOrWidth(self.App.EditAccess_TextWdth)  # 算出したテキスト折り返し幅を設定

        # メインフレーム「設定」タブ内のウィジェットに対するリサイズ処理
        # リサイズされたウィンドウの横幅に説明用のテキストエリア（QTextEdit）のテキスト折り返しまでの幅の「ウィンドウサイズに対する割合」を乗じる
        self.App.SetAccess_TextWdth = int(NewWidth * self.App.SetAccess_TextWght)
        for TabNum in range(1, self.App.Settings_TabCount + 1):  # メインフレーム「設定」タブの各「接続先」タブのためのイテレーション
            # TabNum に対応する属性名を設定及び AppClass（self.App）属性の対応する属性からテキストエリア（QTextEdit）の参照を取得
            self.App.SetAccess_Text = getattr(self.App, "SetAccess_Text_{0}".format(str(TabNum)), None)
            self.App.SetAccess_Text.setLineWrapColumnOrWidth(self.App.SetAccess_TextWdth)  # 先に算出したテキスト折り返し幅を設定

# スクリプトのあるディレクトリの絶対パスを取得（実行ファイルが PyInstaller によってビルドされることを想定）
SCRIPT_DIR = getattr(sys, "_MEIPASS", os.path.dirname(os.path.abspath(__file__)))
DATA_DIR = os.path.join(SCRIPT_DIR, "bitBuyer data")  # アプリケーションのデータ用のディレクトリパス
CACHE_DIR = os.path.join(DATA_DIR, "cache")  # キャッシュファイル用のディレクトリパス
MATERIALS_DIR = os.path.join(DATA_DIR, "materials")  # 素材データ用のディレクトリパス

if not os.path.exists(CACHE_DIR):  # キャッシュファイル用ディレクトリが存在しない場合は作成
    os.makedirs(CACHE_DIR)

ACCESS_CACHE = os.path.join(CACHE_DIR, "access_cache.json")  # 接続先データを保存するファイルの名前を設定
ENCRYPTION_KEY = os.path.join(CACHE_DIR, "encryption.key")  # 暗号化キーを保存するファイルの名前を設定
API_KEYS_CACHE = os.path.join(CACHE_DIR, "APIkeys_cache.json")  # API キー及び API シークレットを保存するファイルの名前を設定
SETTINGS_CACHE = os.path.join(CACHE_DIR, "settings_cache.json")  # 設定を保存するファイルの名前を設定

# AppClass の機能を補助するクラス
class AssistanceClass:
    """ この部分を「クラスの docstring」と言います。
    このクラスは、AppClass で定義される各種 GUI ウィジェットが、ユーザーインタラクションに対するレスポンスを適切に行うための機能の提供を行う役割を持ちます。
    ここで言う機能とは、例えばボタンがクリックされることで開始される処理のようなものを指すのではなく、ボタン上にマウスカーソルが移動したことを検知して呼び出される
    PyQt フレームワークのイベントハンドラが行う処理のことを指します。例えばボタン上にマウスカーソルが移動した場合、マウスカーソルの種類（指差しカーソルや矢印
    カーソル）を変更する、などです。このような処理が適切に行われないと、ユーザーはボタンがクリック可能な状態なのかを認識しにくくなり、混乱を招き、結果として
    アプリケーションのユーザーエクスペリエンスを低下させる原因となります。ここまではボタンを例として取り上げてきましたが、イベントハンドラに追加の処理を適用する
    必要のある GUI ウィジェットは他にも存在する可能性があります。それを見つけるには実際にアプリケーションをテストして、GUI ウィジェットが通常想定される挙動を
    取るか確認することが重要です。もしイベントハンドラに処理を追加する必要のある GUI ウィジェットが見つかった場合、このクラスにその処理を追加することで迅速に対応
    することができます。
    """
    # 指定されたウィジェットのカーソルの種類を変更する静的関数
    @staticmethod  # 静的関数であることを示すデコレータ
    def ChangeCursor(Widget, CursorType):
        """ この部分を「関数の docstring」と言います。
        指定されたウィジェットのカーソルの種類を変更する静的関数。

        この関数は、渡されたウィジェットのカーソルを指定されたタイプに変更します。これにより、ウィジェットのカーソルの外観や動作をカスタマイズすることができます。

        Args:
            Widget: カーソルを変更するウィジェット。
            CursorType: 適用するカーソルのタイプ。

        Returns:
            なし。
        """
        Widget.setCursor(CursorType)  # カーソルタイプを変更
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

###################################################################################
# ### MainThreadFunctionsClass、SubThreadFunctionsClass 双方で使用する純粋関数の定義 ###
###################################################################################
"""
プログラミングにおける「純粋関数」とは、ある関数が同じ入力値に対して常に同じ結果を返し、その計算過程でプログラムの他の部分や外部の状態に影響を与えるような副作用が
一切ない関数を指します。純粋関数の特性には主に予測可能性と副作用のなさがあり、これによりプログラムがより信頼性高く動作し、バグの発生を抑えやすくなります。予測可能
性とは、関数が外部の変数や状態、外部システムとのインタラクションに依存せずに、提供された入力のみを基に計算を行う性質を意味します。このため、テストが容易であり、
同じ条件下であればテスト結果が常に一致するため、デバッグが容易になります。副作用のなさとは、関数が値を計算して返す以外の任意の作用、例えばグローバル変数の変更、
ファイルシステムへの書き込み、データベースへのデータ保存、ネットワーク越しのデータ送信などを行わない性質を指します。副作用がないことで、関数の振る舞いが入力値に
のみ依存し、予測や再現が容易になります。純粋関数の利点は多岐に渡ります。まず、関数の出力が入力にのみ依存するため、プログラムの動作が明確で予測しやすく、自動的な
テストや最適化がしやすい状態を提供します。また、関数の再利用性が高まり、複数の場所で同じ関数を安全に使えるようになるため（複数のスレッドが同時に呼び出すことも
可能）、コードの重複を減らし、保守性を高めることができます。さらに、副作用のない設計は、プログラムの各部分を独立して考えることができるため、大規模なシステムに
おいても、モジュールの組み合わせやテストが容易になります。関数型プログラミング言語では、このような純粋関数の概念が中心となり、より宣言的で数学的なアプローチを取り
ます。このアプローチにより、コードの副作用を最小化し、プログラムの動作をより透明にし、エラーの発生を減らすことが可能です。例えば、Python において
def add(a, b): return a + b のような関数は純粋関数です。この関数は入力された数値にのみ基づき計算を行い、同じ入力に対して常に同じ出力を返すため、予測可能で
副作用がありません。このように純粋関数を利用することで、アプリケーションの信頼性と保守性を向上させることができます。
"""
# 指定された正規表現パターンに一致する行をテキストから抽出、または有無を知らせる bool 値を返す純粋関数
def ExtractMatchingIndexesAndLines(TextLines, Pattern, AskMatching = False):
    """ この部分を「関数の docstring」と言います。
    指定された正規表現パターンに一致する行をテキストから抽出、または有無を知らせる bool 値を返す純粋関数。

    この関数は、指定された正規表現パターン、または単純な文字列に基づき、テキストから一致する行を抽出し、それらを行のインデックスと共にリスト形式で返します。
    さらに、引数 AskMatching パラメータが True の場合、指定パターンがテキストにマッチするかどうかの確認を求められていると判断し、マッチする場合に True を、
    そうでなければ False を返します。全てのマッチングは部分一致で行いますが、パターンとして行頭から行末までを指定することで行全体の完全一致にも対応可能です。
    この関数は、単純な文字列マッチングから複雑な正規表現パターンによる検索まで、多様なテキスト処理ニーズに対応しています。関数は re.search を利用しており、
    これによりパターンとして単なる文字列が渡された場合にも対応可能です。正規表現の特殊文字を含まない単純な文字列でも、テキスト内でその文字列を含む行を効率的に
    見つけ出すことができます。この柔軟性は、エラーログの分析、特定のキーワードに基づくデータのフィルタリング、あるいは条件に応じたデータのセグメンテーションなど、
    幅広いシナリオでの利用を想定した上で実装されたものです。テキストは行毎のリストとして渡されることを想定しており、これによって複数行に渡るシステムログや、単一行
    のテキストデータなど、様々な形式のテキストデータに対応可能です。特に、正規表現を用いた検索では、その強力なパターンマッチング機能を活かし、高度なテキスト処理
    タスクを実現します。

    Parameters:
        TextLines (list): 検索対象のテキスト（str）を含むリスト。
        Pattern (str): 検索に使用する文字列、または正規表現パターン。
        AskMatching (bool, optional): マッチするかどうかの確認を行う場合は True、そうでない場合は False（デフォルト）。

    Returns:
        list of tuples or bool:
            AskMatching が False（デフォルト）の場合、マッチした各行の tuple(インデックス, 行内容)のリスト（マッチする行がない場合は None）。
            AskMatching が True の場合、パターンがテキストにマッチするかどうかの bool 値。
    """
    MatchedLines = []  # 一致した行を格納するリストを初期化

    for Index, Line in enumerate(TextLines):  # 各行に対して正規表現のマッチをチェック
        if re.search(Pattern, Line):  # パターンに一致するかチェック
            MatchedLines.append((Index, Line,))  # インデックスと一致した行をタプルとして追加

    if AskMatching:  # マッチするかどうかの確認が求められている場合
        return bool(MatchedLines)  # マッチした行があれば True、なければ False を返す

    return MatchedLines if MatchedLines else None  # 一致した行の tuple(インデックス, 行内容)のリストを返す（一致がなければ None を返す）
    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

# ドット区切りのデータパスに従って、データオブジェクトから値を取得する純粋関数
def GetDataVal(Data, DataPath):
    """ この部分を「関数の docstring」と言います。
    ドット区切りのデータパスに従って、データオブジェクトから値を取得する純粋関数。

    この関数は、ネストされたデータ構造内で特定の値をデータパスに基づいて取得するための高度な処理を実行します。データパスはドット（"."）で区切られた文字列形式で、
    辞書のキーとリストまたはタプルのインデックスの両方を指定できます。例えば、データパス "key1.key2.0.key3" は、辞書内の "key1" にある辞書の "key2" にある
    リストの最初の要素内の "key3" キーに対応する値を指します。この処理過程で関数は、存在しないキーまたはインデックスへのアクセス試行や、サポートされていない
    データ型へのアクセスなど、一般的に発生し得るエラーを適切に処理します。処理はまず、データパスをドットで分割し、個々の要素をキーまたはインデックスとして使用
    します。データ構造が辞書型の場合、メソッド get() を使用してキーに対応する値を安全に取得し、キーが存在しない場合は None を返します。データがリスト型または
    タプル型の場合、キー（この文脈ではインデックス）を整数値に変換し、該当する要素にアクセスします。この変換またはアクセスに失敗した場合、None を返します。データ
    構造が辞書型、リスト型、タプル型でない場合、またはデータパスに従ってデータを探索する過程で存在しないキーまたはインデックスに遭遇した場合、関数は None を
    返して処理を終了します。この処理方法により、関数はネストされた構造内で安全に特定の値を取得し、取得を試みる際に発生する可能性のある一般的なエラーを適切に
    ハンドリングします。処理中に予期せぬエラーが発生した場合は、エラーの詳細を含む例外を発生させて、呼び出し元に問題を知らせます。このアプローチにより、複雑な
    データ構造内でのデータアクセスを効率的かつ安全に行うことができます。

    Parameters:
        Data (dict or list): 値を取得するためのデータオブジェクト。データオブジェクトは辞書型、リスト型、タプル型、またはそれらの混合型。
        DataPath (str): 値の取得に使用するドットで区切られたデータパス。辞書のキーとリストまたはタプルのインデックスを指定可能。

    Returns:
        Any: 指定されたデータパスに対応する値。該当する値がデータオブジェクト内に存在しない場合、None。

    Raises:
        Exception: データの探索中に予期せぬエラーが発生した場合に発生。エラーメッセージは、エラーの種類と内容を含む。
    """
    # データパスの分解
    Keys = DataPath.split(".")  # データパスを "." で分割してリストを取得

    try:  # エラーを検出するブロック
        for Key in Keys:  # キーリストのキーを順番に一つずつ使用してデータを探索するイテレーション
            if isinstance(Data, dict):  # データが辞書型の場合
                Data = Data.get(Key, None)  # キーに対応する値を取得、存在しない場合は None
            elif isinstance(Data, (list, tuple)):  # データがリスト型またはタプル型の場合
                try:  # エラーを検出するブロック
                    IntKey = int(Key)  # キーを整数値（int）に変換
                    Data = Data[IntKey]  # 変換されたキーでリストまたはタプルから要素を取得
                except (ValueError, IndexError):  # キー変換またはインデックスアクセスに失敗した場合
                    return None  # リスト型またはタプル型データの処理に失敗したため、None を返す
            else:  # 未対応のデータ型の場合、None を返す（データが辞書型、リスト型、タプル型でない場合）
                return None  # None を返して処理を終了

            if Data is None:  # データが見つからない場合（中間データが None）、イテレーションを終了
                break
    except Exception as e:  # 何らかのエラーが発生した場合、呼び出し元にエラーを知らせる
        raise Exception(("データ取得中にエラーが発生しました。データとデータパスが整合していない可能性があります。"
            "エラータイプ：{0}、エラー内容：{1}").format(str(type(e).__name__), str(e)))  # エラー情報を含む例外を再発生させる

    if Data is None:  # データの取得に失敗した場合（最終的にデータが None）、None を返す
        return None  # None を返す
    else:  # データの取得に成功した場合（データが None 以外）、値を返す
        return Data  # 値を返す
    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

# 指定された暗号化キーを使用してメッセージを AES 暗号化する純粋関数
def EncryptMessage(Message, Key, IV):
    """ この部分を「関数の docstring」と言います。
    指定された暗号化キーを使用してメッセージを AES 暗号化する純粋関数。

    この関数は、指定されたキーと初期化ベクトルを使用してメッセージを AES 暗号化します。これにはエラーハンドリングを含まないため、例外が発生した場合は呼び出し元で
    適切に処理する必要があります。暗号化プロセスは次のステップで構成されます。1、暗号化器の初期化 2、PKCS7 パディングの適用 3、メッセージの暗号化。この関数は
    初見では難易度の高い処理を行っているため、コード内に詳細な説明を配置しています。この関数は、内包しているガイダンスが、同じくグローバル関数として定義されている
    関数 DecryptMessage() の理解を補助するものとしても機能するよう、隣接した位置、グローバル関数として定義されています。

    Parameters:
        Message (bytes): 暗号化するメッセージ。
        Key (bytes): AES での暗号化に使用するキー。
        IV (bytes): AES での暗号化に使用する CBC モードの初期化ベクトル。

    Returns:
        bytes: 暗号化したメッセージ。
    """
    try:  # エラーを検出するブロック
        # AES アルゴリズムと CBC モードを使用して暗号化器をセットアップ（IV もここで指定）
        CipherObject = Cipher(algorithms.AES(Key), modes.CBC(IV), backend = default_backend())  # 暗号化の設定を初期化
        Encryptor = CipherObject.encryptor()  # 暗号化プロセスのための encryptor オブジェクト（暗号化器）を作成
        """
ここまでの、情報を安全に暗号化するための手順を説明します。暗号化は情報を保護する重要な技術であり、ここでは AES（Advanced Encryption Standard）方式と CBC
（Cipher Block Chaining）モードを使用します。

1、秘密鍵（Key）の設定：
    秘密鍵は、暗号化及び復号化プロセスにおいて情報の変換を行うための鍵です。この鍵は情報を暗号化する際に必要であり、安全に管理される必要があります。
2、初期化ベクトル（IV）の設定：
    初期化ベクトルは、暗号化セッションを開始するための一時的な値であり、特に CBC モードで重要です。IV は暗号化されたブロック間の連鎖を初期化し、同じ内容の
    メッセージでも異なる暗号文となることを保証します。

これらの要素を用いて、AES と CBC を適用することで、任意のメッセージ（データ）を効果的に保護します。暗号化プロセスは以下の通りです：

- CipherObject の作成：
    AES 方式と CBC モードを組み合わせた Cipher オブジェクトを作成します。
    このオブジェクトは、暗号化の具体的なパラメータを設定するためのコンテナとして機能します。
- Encryptor の作成：
    暗号化器（Encryptor）は、実際にデータを暗号化するためのツールです。Cipher オブジェクトから作成され、渡されたデータを安全に変換します。

このプロセスを通じて、セキュリティ保護が不可欠な敏感情報の暗号化が行われ、敏感情報の安全性が強化されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
        """

        # Message に対して PKCS7 パディングを適用
        Padder = padding.PKCS7(algorithms.AES.block_size).padder()  # パディング処理器を作成
        PaddedData = Padder.update(Message) + Padder.finalize()  # Message をパディングし、完了処理を行う
        """
ここまでの、メッセージにパディングを適用するプロセスを説明します。パディングとは、データを特定の長さに合わせるために追加される余分な情報のことです。これは、暗号化
アルゴリズムが特定のデータブロックサイズを要求するために必要となるものです。暗号化プロセスにおいては、全てのデータブロックがアルゴリズムが要求するサイズになって
いる必要があります。データが必要な長さに満たない場合、パディングを追加して要求を満たします。PKCS7 パディングは、この目的に広く使用される方法の一つです。

適用プロセスは以下の通りです：

- パディング処理器の作成：
    PKCS7 クラスを使用して、暗号化アルゴリズム（ここでは AES）が要求するブロックサイズに基づいてパディング処理器を作成します。この処理器は、渡したメッセージに
    適切な量のパディングを追加する役割を持ちます。

- パディングの適用：
    処理器を使用して、渡されたメッセージ（Message）にパディングを追加し、メッセージが AES 暗号化に適するブロックサイズになるようにします。

- パディングの完了処理：
    パディングの適用後、メソッド finalize() を呼び出してパディングプロセスを完了します。このステップにより、パディングが適用された最終的なデータ（PaddedData）
    が作成されます。

このプロセスを通じて、メッセージは暗号化処理のための適切な形式に整えられます。このパディングプロセスは、安全で効率的な暗号化の基礎となります。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
        """

        Ciphertext = Encryptor.update(PaddedData) + Encryptor.finalize()  # パディングされたデータを暗号化し、完了処理を行う
        """
このコード行は、パディング処理を施されたデータ（PaddedData）を Encryptor オブジェクトを用いて暗号化し、メソッド update() で暗号化プロセスを行った後、メソッド
finalize() で完了させることで、最終的な暗号化されたデータ（Ciphertext）を作成します。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
        """
        return Ciphertext  # 暗号化したデータを返す
    except Exception as e:  # 何らかのエラーが発生した場合、エラーを再発生させる
        raise Exception("エラータイプ：{0}、エラー内容：{1}".format(str(type(e)), str(e)))  # エラーを再発生させる
    finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
        Message = None  # 使用完了した平文データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
        PaddedData = None  # 使用完了したパディングデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
        Ciphertext = None  # 使用完了した暗号化データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる

# 指定された暗号化キーを使用して AES 暗号化されたメッセージを復号化する純粋関数
def DecryptMessage(EncryptedMessage, Key, IV):
    """ この部分を「関数の docstring」と言います。
    指定された暗号化キーを使用して AES 暗号化されたメッセージを復号化する純粋関数。

    この関数は、指定されたキーと初期化ベクトルを使用してメッセージを AES 復号化します。これにはエラーハンドリングを含まないため、例外が発生した場合は呼び出し元で
    適切に処理する必要があります。復号化プロセスは次のステップで構成されます。1、復号化器の初期化 2、メッセージの復号化 3、パディングの削除。この関数は、関数
    EncryptMessage() とは逆の処理を行っています。このため、この関数内で理解が困難な部分がある場合、関数 EncryptMessage() 内に配置している詳細な説明を参照
    することが理解の一助となります。この関数は API キー及び API シークレットの復号化をメインスレッド（Qt イベントループ）とバックグラウンドスレッドの両方で行う
    必要に対応するためにグローバル関数として定義されています。

    Parameters:
        Message (bytes): AES 暗号化されたメッセージ。
        Key (bytes): AES での暗号化に使用したキー。
        IV (bytes): AES での暗号化に使用した CBC モードの初期化ベクトル。

    Returns:
        bytes: 復号化したメッセージ。
    """
    try:  # エラーを検出するブロック
        # AES アルゴリズムと CBC モードを使用して復号化器をセットアップ（IV もここで指定）
        CipherObject = Cipher(algorithms.AES(Key), modes.CBC(IV), backend = default_backend())  # 復号化の設定を初期化
        Decryptor = CipherObject.decryptor()  # 復号化プロセスのための decryptor オブジェクト（復号化器）を作成

        PaddedData = Decryptor.update(EncryptedMessage) + Decryptor.finalize()  # パディングされたデータを復号化し、完了処理を行う

        # EncryptedMessage に対して適用されている PKCS7 パディングを削除
        Unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()  # パディング処理器を作成
        # データからパディングを削除し、完了処理を行う（元の Message を取得）
        DecryptedMessage = Unpadder.update(PaddedData) + Unpadder.finalize()
        return DecryptedMessage  # 復号化したメッセージを返す
    except Exception as e:  # 何らかのエラーが発生した場合、エラーを再発生させる
        raise Exception("エラータイプ：{0}、エラー内容：{1}".format(str(type(e)), str(e)))  # エラーを再発生させる
    finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
        EncryptedMessage = None  # 使用完了した暗号化データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
        PaddedData = None  # 使用完了したパディングデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
        DecryptedMessage = None  # 使用完了した復号化データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

# メッセージを暗号化または復号化するグローバル関数のエラーハンドリングを行う純粋関数
def ErrorHandler_ofEncryptOrDecrypt(LogManager, App, Message, Type, ThreadID = None, Encrypt = False, Decrypt = False, SaveAttr = None,
    RequireBase64 = False, ReturnStr = False):
    """ この部分を「関数の docstring」と言います。
    メッセージを暗号化または復号化するグローバル関数のエラーハンドリングを行う純粋関数。

    この関数は、メッセージを暗号化するグローバル関数 EncryptMessage() と復号化するグローバル関数 DecryptMessage() のエラーハンドリングをカプセル化すること
    を目的に設計されています。グローバル関数を使用した暗号化または復号化はこの関数を通して一元的に行うことが可能です。追加的に、この関数ではメッセージの bytes
    型への変換と Base64 形式へのエンコード、または Base64 形式からのデコードといった、暗号化または復号化に伴う前後処理も行うことができるように設計されています。
    必要に応じて AppClass（self.App）属性に暗号化したメッセージを保存することも可能です。また処理の各過程をシステムログに記録します。このときに、引数 Type を
    「どのようなデータを暗号化または復号化しているのか」をシステムログの記録に含めるために使用します。引数 ThreadID を指定しない場合、この関数はメインスレッド
    から呼び出されたと判断し処理を行います。
    処理の各過程に対応するログは LogManagerClass によって LogText_0 または BackLog 属性に記録されます。

    Parameters:
        LogManager (LogManagerClass): LogManagerClass のインスタンス。
        App (AppClass): AppClass のインスタンス。
        Message (str or bytes): 暗号化または復号化するメッセージ。文字列型（str）で渡された場合、関数 base64.b64decode() に渡してデコードを行う。
        Type (str): 暗号化または復号化するメッセージがどのようなデータなのかを示す、ログ記録用の文字列。
        ThreadID (int, optional): バックグラウンドスレッドからの呼び出しの場合に指定、そうでない場合は None（デフォルト）。
        Encrypt (bool, optional): 暗号化する場合は True、そうでない場合は False（デフォルト）。Decrypt が True の場合は True 不可。
        Decrypt (bool, optional): 復号化する場合は True、そうでない場合は False（デフォルト）。Encrypt が True の場合は True 不可。
        SaveAttr (str, optional): 暗号化したメッセージを AppClass（self.App）属性に保存する場合はその属性名、そうでない場合は None（デフォルト）。
        RequireBase64 (bool, optional): 暗号化後の処理結果を Base64 形式で求める場合は True、そうでない場合は False（デフォルト）。
        ReturnStr (bool, optional):
            暗号化後の処理結果を Base64 形式の文字列型（str）で求める場合は True、そうでない場合は False（デフォルト）。
            復号化後の処理結果を文字列型（str）で求める場合は True、そうでない場合は False（デフォルト）。

    Returns:
        bytes or str or bool: 処理に成功した場合は処理後のメッセージ、そうでない場合は False。
    """
    if (Encrypt and Decrypt) or not Message:  # 引数が不正な場合、処理を行わない
        return False  # 処理を終了して False を返す

    # 引数 Encrypt と Decrypt に基づいて引数 Type を使用したシステムログの基礎部分を作成
    BaseLog = "{0}：暗号化".format(str(Type)) if Encrypt and not Decrypt else "{0}：復号化".format(str(Type))

    try:  # エラーを検出するブロック
        if Encrypt:  # メッセージを暗号化する場合
            if ThreadID is None:  # メインスレッドからの呼び出しの場合のログ記録
                LogManager.InsertLOG("{0}開始".format(str(BaseLog)), App.一般)
            else:  # バックグラウンドスレッドからの呼び出しの場合のログ記録
                LogManager.RecordBackLOG("{0}開始".format(str(BaseLog)), ThreadID)
            Message = Message.encode("utf-8") if isinstance(Message, str) else Message  # Message が文字列型（str）の場合、bytes 型に変換
            EncryptedMessage = EncryptMessage(Message, App.EncryptionKey, App.IV_ofEncryption)  # グローバル関数を使用して暗号化
            # 有効な値が返されていないか、値が bytes 型でない場合、例外を発生させる
            if not EncryptedMessage or not isinstance(EncryptedMessage, bytes):
                raise ValueError("暗号化関数で予期しないエラーが発生しました")  # except ブロックを実行

            if SaveAttr:  # 暗号化したメッセージの AppClass（App）属性への保存が求められている場合
                setattr(App, SaveAttr, EncryptedMessage)  # 引数 SaveAttr の値（属性名）を使用して暗号化したメッセージを保存
            if RequireBase64:  # Base64 形式の返り値が求められている場合
                EncryptedMessage = base64.b64encode(EncryptedMessage)  # Base64 エンコード
            if ReturnStr:  # 文字列型（str）の返り値が求められている場合
                EncryptedMessage = EncryptedMessage.decode("utf-8")  # メソッド decode() を使用して文字列型（str）に変換

            if ThreadID is None:  # メインスレッドからの呼び出しの場合のログ記録
                LogManager.InsertLOG("{0}完了".format(str(BaseLog)), App.一般)
            else:  # バックグラウンドスレッドからの呼び出しの場合のログ記録
                LogManager.RecordBackLOG("{0}完了".format(str(BaseLog)), ThreadID)

            return EncryptedMessage  # 暗号化した処理結果を返す
        elif Decrypt:  # メッセージを復号化する場合
            if ThreadID is None:  # メインスレッドからの呼び出しの場合のログ記録
                LogManager.InsertLOG("{0}開始".format(str(BaseLog)), App.一般)
            else:  # バックグラウンドスレッドからの呼び出しの場合のログ記録
                LogManager.RecordBackLOG("{0}開始".format(str(BaseLog)), ThreadID)
            # Message が文字列型（str）の場合、bytes 型に変換（Base64 エンコードされたものであることが前提）
            Message = base64.b64decode(Message) if isinstance(Message, str) else Message
            DecryptedMessage = DecryptMessage(Message, App.EncryptionKey, App.IV_ofEncryption)  # グローバル関数を使用して復号化
            # 有効な値が返されていないか、値が bytes 型でない場合、例外を発生させる
            if not DecryptedMessage or not isinstance(DecryptedMessage, bytes):
                raise ValueError("復号化関数で予期しないエラーが発生しました")  # except ブロックを実行

            if ReturnStr:  # 文字列型（str）の返り値が求められている場合
                DecryptedMessage = DecryptedMessage.decode("utf-8")  # メソッド decode() を使用して文字列型（str）に変換

            if ThreadID is None:  # メインスレッドからの呼び出しの場合のログ記録
                LogManager.InsertLOG("{0}完了".format(str(BaseLog)), App.一般)
            else:  # バックグラウンドスレッドからの呼び出しの場合のログ記録
                LogManager.RecordBackLOG("{0}完了".format(str(BaseLog)), ThreadID)

            return DecryptedMessage  # 復号化した処理結果を返す
    except Exception as e:  # 何らかのエラーが発生した場合、エラーをシステムログに記録して処理を終了
        if ThreadID is None:  # メインスレッドからの呼び出しの場合のログ記録
            LogManager.InsertLOG("{0}失敗「{1}」".format(str(BaseLog), str(e)), App.一般)
        else:  # バックグラウンドスレッドからの呼び出しの場合のログ記録
            LogManager.RecordBackLOG("{0}失敗「{1}」".format(str(BaseLog), str(e)), ThreadID)

        return False  # 処理を終了して False を返す
    finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
        Message = None  # 使用完了したデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
        EncryptedMessage = None  # 使用完了した暗号化データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
        DecryptedMessage = None  # 使用完了した復号化データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。なお、エンコードやデコードに関する解説は各呼び出し元で行っています。 """

# キャッシュファイルの読み書きを行う純粋関数
def FileOpener(LogManager, LogSection, FilePath, Mode, ThreadID = None, WriteData = None, ObjectList = None):
    """ この部分を「関数の docstring」と言います。
    キャッシュファイルの読み書きを行う純粋関数。

    この関数は、引数に基づいてキャッシュファイルにデータを書き込み、または読み込みます。書き込みまたは読み込み時には、引数 FilePath の拡張子に基づいて適切な書き
    込みまたは読み込み方法を選択します。この関数はファイルパスの存在確認が行われている前提で処理を行います。また、メインスレッドまたはバックグラウンドスレッド毎に
    適切な try-except ブロックでのエラーハンドリングが必要です。
    処理の各過程に対応するログが LogManagerClass によって LogText_0 または BackLog 属性に記録されます。

    Args:
        LogManager (LogManagerClass): LogManagerClass のインスタンス。
        LogSection (str): 現在の処理内容を示す文字列｡「LogSection：ログ内容」の形式でシステムログを記録するためのもの。
        FilePath (str): キャッシュファイルのファイルパス。
        Mode (str): キャッシュファイルの読み書きモードを指定する文字列｡「with open()」で指定するもの。
        ThreadID (int, optional): バックグラウンドスレッドからの呼び出しの場合に指定、そうでない場合は None（デフォルト）。
        WriteData (object, optional):
            キャッシュファイルに書き込むデータオブジェクト。読み込みの場合は None（デフォルト）。JSON データを書き込む場合、Python オブジェクト。
            バイト列（bytes）を書き込む場合、そのリスト。
        ObjectList (list, optional):
            キャッシュファイルから読み込むオブジェクトのリスト。バイト指定を行う場合、整数値（int）のリスト。デフォルトは None（全体読み込み）。

    Returns:
        str or list: 書き込みが完了したことを示す文字列「書き込み完了（str）」。または読み込んだデータのリスト。
    """
    Data = []  # 変数を初期化

    FileType = FilePath.split(".")[-1]  # ファイルパスをドットで分割して最後のセグメント（拡張子）を取得
    ModeStr = "書き込み" if Mode[0] == "w" else "読み込み"  # メッセージ表示用の読み書きモードを示す文字列（str）を作成

    if ThreadID is None:  # メインスレッドからの呼び出しの場合のログ記録
        LogManager.InsertLOG("{0}：キャッシュファイル展開".format(str(LogSection)), CallNum = 0)
        LogManager.InsertLOG("{0}：{1} ファイル{2}".format(str(LogSection), str(FileType), str(ModeStr)), CallNum = 0)
    else:  # バックグラウンドスレッドからの呼び出しの場合のログ記録
        LogManager.RecordBackLOG("{0}：キャッシュファイル展開".format(str(LogSection)), ThreadID)
        LogManager.RecordBackLOG("{0}：{1} ファイル{2}".format(str(LogSection), str(FileType), str(ModeStr)), ThreadID)

    with open(FilePath, Mode) as File:  # キャッシュファイルを指定されたモードで展開
        if FileType == "json" and Mode[0] == "w":  # JSON ファイル、かつ書き込みモードの場合
            json.dump(WriteData, File, indent = 4)  # キャッシュファイルに内容を書き込み
        elif FileType == "json" and Mode[0] == "r":  # JSON ファイル、かつ読み込みモードの場合
            Data.append(json.load(File))  # キャッシュファイルの内容を読み込み（辞書）
        elif FileType == "key" and Mode[0] == "w":  # KEY ファイル、かつ書き込みモードの場合
            for Bytes in WriteData:  # WriteData に格納されているバイト列（bytes）を取り出すためのイテレーション
                File.write(Bytes)  # 取り出したバイト列（bytes）を書き込み
        elif FileType == "key" and Mode[0] == "r":  # KEY ファイル、かつ読み込みモードの場合
            for Bytes in ObjectList:  # ObjectList で指定されているバイト列の整数値（int）を取り出すためのイテレーション
                Data.append(File.read(Bytes))  # 取り出した「バイト列の整数値（int）」でバイト列を読み込み

    if Mode[0] == "w" and ThreadID is None:  # 書き込みモードでメインスレッドからの呼び出しの場合のログ記録
        LogManager.InsertLOG("{0}：キャッシュファイル書き込み完了".format(str(LogSection)), CallNum = 0)
    elif Mode[0] == "w":  # 書き込みモードでバックグラウンドスレッドからの呼び出しの場合のログ記録
        LogManager.RecordBackLOG("{0}：キャッシュファイル書き込み完了".format(str(LogSection)), ThreadID)

    return "書き込み完了" if Mode[0] == "w" else Data  # 書き込みが完了したことを示す文字列（str）を返す、または読み込んだデータのリストを返す
    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

# マルチスレッドエンジンの各スレッド ID をエンジン番号に変換する純粋関数
def IntegrationOfThreadIDtoEngineNum(ThreadID):
    """ この部分を「関数の docstring」と言います。
    マルチスレッドエンジンの各スレッド ID をエンジン番号に変換する純粋関数。

    この関数は、渡されたスレッド ID をそのスレッドが属するエンジンの番号に変換して返します。スレッド ID は整数値（int）またはその文字列型（str）で指定可能です。
    各スレッド ID は特定のエンジン番号に割り当てられており、以下のようにマッピングしています：

    - スレッド ID 0 または 6  -> エンジン番号 0
    - スレッド ID 1 または 7  -> エンジン番号 1
    - スレッド ID 2 または 8  -> エンジン番号 2
    - スレッド ID 3 または 9  -> エンジン番号 3
    - スレッド ID 4 または 10 -> エンジン番号 4
    - スレッド ID 5 または 11 -> エンジン番号 5

    この関数で定義しているマッピングを変更する場合、その変更はそのまま各エンジンに割り振られるスレッドの変更として扱われます。この仕様により、将来エンジンをさらに
    拡張する際には、この関数のマッピングの定義を変更するだけで対応可能です。

    Parameters:
        ThreadID (int or str): スレッド ID を表す整数値またはその文字列型。

    Returns:
        int or None: スレッド ID に対応するエンジン番号。または想定する入力値でない場合、None。
    """
    if (ThreadID in {0, 6}) or (ThreadID in {"0", "6"}):  # ThreadID が 0 または 6 の場合
        return 0  # エンジン番号を返す
    elif (ThreadID in {1, 7}) or (ThreadID in {"1", "7"}):  # ThreadID が 1 または 7 の場合
        return 1  # エンジン番号を返す
    elif (ThreadID in {2, 8}) or (ThreadID in {"2", "8"}):  # ThreadID が 2 または 8 の場合
        return 2  # エンジン番号を返す
    elif (ThreadID in {3, 9}) or (ThreadID in {"3", "9"}):  # ThreadID が 3 または 9 の場合
        return 3  # エンジン番号を返す
    elif (ThreadID in {4, 10}) or (ThreadID in {"4", "10"}):  # ThreadID が 4 または 10 の場合
        return 4  # エンジン番号を返す
    elif (ThreadID in {5, 11}) or (ThreadID in {"5", "11"}):  # ThreadID が 5 または 11 の場合
        return 5  # エンジン番号を返す
    else:  # 想定する入力値でない場合
        return None  # None を返す
    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

# アプリケーションの GUI 処理に必要な関数をまとめたクラス
class MainThreadFunctionsClass(QObject):  # QObject を継承（PyQt フレームワークのシグナルとスロットのメカニズムを使用するため）
    """ この部分を「クラスの docstring」と言います。
    このクラスは、AppClass で定義される各種 GUI ウィジェットに対してユーザーが入力を行った際の処理を管理する役割を持ちます。このため、このクラスの関数は全て
    メインスレッド、即ち Qt イベントループで動作することが保証されています。逆の表現をすれば、メインスレッドで行うべき処理は全てこのクラスで管理しています
    （ただし、処理に伴って出力するシステムログの管理は例外的に除かれます）。これは、AppClass のコンストラクタでこのクラスのインスタンスを作成し、作成後にどの
    スレッドにも移動しないことで実現しています。このクラスの関数が GUI ウィジェットに対するユーザーの入力に応答するには、PyQt フレームワークが採用している
    シグナルとスロットのメカニズムに基づいて、関数（スロット）が GUI ウィジェットが発行するシグナルに接続（connect()）されている必要があります。また、この
    クラスのコンストラクタではバックグラウンドスレッドでのデータ処理を管理する役割を持つクラス SubThreadFunctionsClass のインスタンスの作成、及び
    バックグラウンドスレッドのインスタンス（QThread）の作成とこのインスタンスへの SubThreadFunctionsClass のインスタンスの移動、及びバックグラウンド
    スレッドの開始を行っています。これは、このクラスでバックグラウンドスレッドの管理も行っていることを意味します。これにより、このクラスの関数は、データ処理を
    バックグラウンドスレッドでシームレスに行うことができます。さらに、このクラスのコンストラクタではバックグラウンドスレッドで行われるデータ処理タスクの進行状況を
    監視する役割を持つクラス TaskMonitoringThreadClass のインスタンスも作成し、先に説明したのと同様の方法でバックグラウンドスレッドに移動及び開始しています。
    このようにバックグラウンドスレッドでのデータ処理タスクの進行状況を監視するロジックを別のバックグラウンドスレッドに一任することで、メインスレッドがユーザー
    インタラクションの処理に専念することを可能にし、アプリケーションの即応性の維持を実現しています。
    ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。

    -----------------------------------------------------------------------------------------------------------------------------------

    このクラスでは、バックグラウンドスレッド（QThread）に移動した SubThreadFunctionsClass のインスタンスの関数の呼び出し用にシグナルを定義しています。これは
    PyQt フレームワークのシグナルとスロットのメカニズムを利用したもので、シグナルを使用してバックグラウンドスレッド（QThread）に移動したクラスのインスタンスの
    関数を呼び出すことで、処理をバックグラウンドスレッド（QThread）で行うことが可能となります。仮の話ですが、このクラスでは全てのバックグラウンドスレッド
    （QThread）のインスタンスと、全ての SubThreadFunctionsClass のインスタンスを保持・管理しているため、例えば SubThreadFunctionsClass のインスタンス
    を管理するためのリスト self.SubFunctions を通じて直接 SubThreadFunctionsClass の関数を呼び出すことも可能です。ただし、これを行った場合、呼び出された
    関数は呼び出し元と同じスレッド、つまりメインスレッドで処理を行います。これはメインスレッドから処理を分離する目的に即していないため、技術的には可能ではある
    ものの、推奨されるアプローチではありません。メインスレッドとバックグラウンドスレッドとで適切かつ安全に処理を分担するには、PyQt フレームワークを採用している
    限りにおいて、シグナルとスロットのメカニズムを利用するのが最も安全かつ効率的なアプローチです。
    ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。

    -----------------------------------------------------------------------------------------------------------------------------------

    【メインスレッドとバックグラウンドスレッドの役割についての追加解説 by ChatGPT 4】
    このクラスでは、GUI（グラフィカルユーザーインターフェイス）のウィジェット、つまりアプリケーションの見た目やユーザーの入力を扱うメインスレッドの機能に対応して
    います。これに対して、バックグラウンドスレッドはデータの処理や長時間を要するタスクを実行するために用います。メインスレッドとバックグラウンドスレッドを分離する
    主な理由は、アプリケーションが応答性を保ち、フリーズしないようにすることです。ユーザーが入力を行ったときに即座に応答を返すことができるように、重い処理は
    バックグラウンドスレッドで行います。

    【シグナルとスロットについての追加解説 by ChatGPT 4】
    シグナルとスロットのメカニズムは、PyQt フレームワークの中核的な概念で、イベント駆動プログラミング（プログラムがユーザーの入力、システムイベントに基づいて反応
    する方式）を容易にします。シグナルはあるイベントが発生したことを通知するためのメカニズムで、スロットはそのシグナルに呼応して呼び出される関数です。このクラス
    では、バックグラウンドスレッドが特定の処理を要する場合に発行するシグナルを受け、メインスレッドで適切なスロットを実行することで、スムーズにユーザー
    インターフェースを更新します。これにより、バックグラウンドスレッドでデータ処理が行われている間も、アプリケーションはユーザーとの対話を継続できます。
    """
    # シグナルを定義（シグナルを発行する際はトリガーする関数の引数がオプショナルな場合でも値の指定が必要）
    # クラス内から SubThreadFunctionsClass の関数をトリガーするシグナル
    # 関数 self.PathTest() でトリガーするシグナル（シグナルのデータ型は関数 self.SubFunctions[n].ExtractAndFormatData() の引数に対応）
    PathTestSignal = pyqtSignal(str, str, str, bool)

    # クラス内から TaskMonitoringThreadClass の関数をトリガーするシグナル
    # SubThreadFunctionsClass の関数をトリガーする各種関数でトリガーするシグナル
    # （シグナルのデータ型は関数 self.TaskMonitoring.AddTask() の引数に対応）
    AddTaskSignal = pyqtSignal(int, str)
    # （シグナルのデータ型は関数 self.TaskMonitoring.TaskCompleted() の引数に対応）
    TaskCompletedSignal = pyqtSignal(int, str, bool)
    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # MainThreadFunctionsClass を初期化する関数（コンストラクタ）
    def __init__(self, AppInstance):
        """ この部分を「関数の docstring」と言います。
        MainThreadFunctionsClass を初期化する関数。

        この初期化関数は、MainThreadFunctionsClass の新しいインスタンスを作成します。引数 AppInstance は AppClass のインスタンスを指し、このクラス内で
        使用されます。また LogManagerClass のシングルトンインスタンスを self.LogManager 属性に設定し、ログ管理機能を準備します。さらにバックグラウンドでの
        データ処理を担う SubThreadFunctionsClass を初期化して self.SubFunctions リストにインスタンスを保存します。各インスタンスで行われる処理は
        バックグラウンドスレッドに移動し、各スレッドのインスタンスは self.SubFunctionsThread リストで管理します。self.SubFunctions リストと
        self.SubFunctionsThread リストのインデックス 0 に対応するインスタンスは実際に使用するエンジンのものではなく、テストボタンなどの GUI 応答用のテスト
        エンジンのインスタンスであり、これは ThreadID 0 として管理するものです。インデックス 0 以外（エンジンがマルチスレッド化された場合、インデックス 0 に
        付随するインデックスも除く）のインスタンスは実際に使用するエンジンとして準備するもので、それぞれのインデックス番号がそのまま ThreadID として対応します。
        これら SubThreadFunctionsClass のインスタンス内の処理が要している時間に応じてバックログを取り出すシグナルを発行する TaskMonitoringThreadClass
        の初期化も行い、このインスタンスもバックグラウンドスレッドに移動します。このクラスのインスタンスは self.TaskMonitoring 属性に設定し、同インスタンスが
        属するスレッドのインスタンスは self.TaskMonitoringThread 属性に設定します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            AppInstance: AppClass のインスタンス。MainThreadFunctionsClass が操作する AppClass のインスタンスを指定。

        Returns:
            なし。
        """
        # QObject の初期化（AppClass に必要な関数をまとめたクラスなため、parent（親要素）として AppClass のインスタンスを設定）
        super(MainThreadFunctionsClass, self).__init__(parent = AppInstance)

        # クラス（self）属性を定義
        self.App = AppInstance  # AppClass のインスタンスを定義
        self.LogManager, self.LF = LogManagerClass.GetInstance()  # LogManagerClass のシングルトンインスタンスと OS 依存改行文字を取得
        """
ここでは、関数が複数の要素を含むタプルを返すと分かっているため、関数の返り値を代入する先をあらかじめタプルが含む要素の数だけ用意しておきます。このようにすること
で、関数が返す複数の要素を含むタプルを自動的にアンパックすることができ、タプルの要素はそれぞれタプル内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
        """
        self.SubFunctions = []  # SubThreadFunctionsClass のインスタンスを管理するリストを定義
        # SubThreadFunctionsClass のインスタンス用の QThread のインスタンス（バックグラウンドスレッド）を管理するリストを定義
        self.SubFunctionsThread = []
        self.LogManager.InsertLOG("Engine クラス：インスタンス作成開始", self.App.一般)
        # 0 から 5 までのイテレーション（バックグラウンドスレッド六つ分）
        for ThreadID in range(6):  # エンジンをマルチスレッド化する場合は range の設定値を変更する
            SubFunctions = SubThreadFunctionsClass(ThreadID, self.App)  # SubThreadFunctionsClass のインスタンスを作成
            SubThread = QThread()  # SubThreadFunctionsClass のインスタンス用の QThread のインスタンス（バックグラウンドスレッド）を作成
            SubFunctions.moveToThread(SubThread)  # SubThreadFunctionsClass のインスタンスで行われる処理を QThread のインスタンスに移動
            # SubThreadFunctionsClass のシグナルを対応する関数に接続
            SubFunctions.TaskCompletedSignal_1.connect(self.SubThreadProcessHandler)
            SubThread.start()  # SubThreadFunctionsClass のインスタンスの処理を実行する QThread のインスタンスのイベントループを開始
            self.SubFunctions.append(SubFunctions)  # SubThreadFunctionsClass のインスタンスを self.SubFunctions リストに追加
            self.SubFunctionsThread.append(SubThread)  # QThread のインスタンスを self.SubFunctionsThread リストに追加
        self.LogManager.InsertLOG("Engine クラス：インスタンス作成完了", self.App.一般)
        self.TaskMonitoring = TaskMonitoringThreadClass()  # TaskMonitoringThreadClass のインスタンスを作成
        SubThread = QThread()  # TaskMonitoringThreadClass のインスタンス用の QThread のインスタンス（バックグラウンドスレッド）を作成
        self.TaskMonitoring.moveToThread(SubThread)  # TaskMonitoringThreadClass のインスタンスで行われる処理を QThread のインスタンスに移動
        # TaskMonitoringThreadClass のシグナルを対応する関数に接続
        self.TaskMonitoring.InsertBackLogSignal.connect(self.LogManager.InsertBackLOG)
        SubThread.start()  # TaskMonitoringThreadClass のインスタンスの処理を実行する QThread のインスタンスのイベントループを開始
        self.TaskMonitoringThread = SubThread  # QThread のインスタンスをクラス（self）属性として定義
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    ###################################
    # ### クラス内から呼ばれるサブクラス ###
    ###################################

    # スクロールエリアを持つカスタムダイアログを定義
    class CustomDialogClass(QDialog):  # QDialog を継承
        """ この部分を「クラスの docstring」と言います。
        このクラスは、アプリケーションウィンドウ self.App を親ウィンドウとして持つ「スクロールエリアを持つカスタムダイアログ」を定義します。スクロールエリアを
        持つカスタムダイアログは、アプリケーションのメインフレーム「接続先編集」タブの「データパスをテスト」ボタンの結果の表示などに使用します。このダイアログが
        必要となるのは、特定の処理をテストした結果であるデータ構造体の内容を確認するケースなど、ダイアログに多くの情報を表示する必要がある場合です。なお、この
        ダイアログでデータ構造体の内容を確認するには、関数 self.MessageStructure() によって、事前にデータ構造体を文字列（str）に変換する必要があります。
        また、ダイアログの表示は関数 self.Dialog() を使用することで行えます。将来的には、他のテスト結果の確認や実際の運用時の情報表示など、幅広い用途で使用
        可能です。
        """
        # CustomDialogClass を初期化する関数（コンストラクタ）
        def __init__(self, Parent, Title = "", Text = ""):
            """ この部分を「関数の docstring」と言います。
            CustomDialogClass を初期化し、スクロールエリアを持つカスタムダイアログを作成する関数。

            この初期化関数は、QDialog のサブクラスとして CustomDialogClass を初期化し、スクロールエリアを持つカスタムダイアログを作成します。具体的には、
            ダイアログにスクロールエリア（QScrollArea）を配置し、このスクロールエリアにテキストエリア（QTextEdit）を配置します。ウィンドウタイトルとして使用
            するテキストとテキストエリアに表示するテキストを引数として受け取り、これらを所定の箇所に設定後、閉じるボタンの配置を行います。

            Parameters:
                "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
                Parent (widget): このダイアログの親ウィジェット（アプリケーションウィンドウを想定）。
                Title (str): ダイアログのタイトル。デフォルトは空文字列。
                Text (str): テキストエリアに表示するテキスト。デフォルトは空文字列。

            Returns:
                なし。
            """
            # QDialog の初期化（parent（親要素）としてアプリケーションウィンドウを設定）
            super(MainThreadFunctionsClass.CustomDialogClass, self).__init__(Parent)

            self.setWindowTitle(Title)  # ウィンドウタイトルを設定

            self.setFixedWidth(int(self.parentWidget().width() * 0.5))  # ダイアログの横幅を設定
            self.setFixedHeight(int(self.parentWidget().height() * 0.5))  # ダイアログの縦幅を設定
            self.setMaximumWidth(int(self.parentWidget().width() * 0.9))  # ダイアログの横幅の最大値を設定
            self.setMaximumHeight(int(self.parentWidget().height() * 0.9))  # ダイアログの縦幅の最大値を設定

            # ダイアログにレイアウトを定義（ダイアログの内容を管理するレイアウトマネージャ）し、クラス（self）属性に設定
            self.Dialog_layout = QVBoxLayout(self)  # 垂直レイアウトのインスタンスを作成

            # スクロールエリアを作成し、クラス（self）属性に設定
            self.ScrollArea = QScrollArea(self)  # QScrollArea のインスタンスを作成
            self.ScrollArea.setWidgetResizable(True)  # スクロールエリア内のウィジェットのサイズ変更を許可し、それに応じエリアを調整するよう設定
            self.Dialog_layout.addWidget(self.ScrollArea)  # インスタンスをダイアログのレイアウトに追加

            # スクロールエリア内のウィジェットを作成及びレイアウトを定義し、クラス（self）属性に設定
            self.Contents = QWidget()  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.ScrollArea.setWidget(self.Contents)  # インスタンスをスクロールエリアのウィジェットとして設定
            self.Contents_layout = QVBoxLayout(self.Contents)  # 垂直レイアウトのインスタンスを作成
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # スクロールエリアにテキストエリア（QTextEdit）を追加し、クラス（self）属性に設定
            self.TextEdit = QTextEdit()  # QTextEdit のインスタンスを作成
            self.TextEdit.setReadOnly(True)  # 編集モードを編集不可に設定
            self.TextEdit.setPlainText(Text)  # テキストを設定（リッチテキストは使用不可）
            self.Contents_layout.addWidget(self.TextEdit)  # インスタンスをスクロールエリア内のウィジェットのレイアウトに追加

            # ボタンのコンテナを作成及びレイアウトを定義し、クラス（self）属性に設定
            self.Btn_cntnr = QWidget()  # QWidget のインスタンスを作成（特定の文脈に属さないため QWidget を選択）
            self.Dialog_layout.addWidget(self.Btn_cntnr)  # インスタンスをダイアログのレイアウトに追加
            self.Btn_layout = QHBoxLayout(self.Btn_cntnr)  # 水平レイアウトのインスタンスを作成
            """ 「特定の文脈に属さない」とは、これが単にウィジェットの配置に必要なだけで、アクセシビリティに関する文脈的な意味を持たないことを意味します。 """

            # ボタンを追加し、クラス（self）属性に設定
            self.Btn = QPushButton("閉じる")  # QPushButton のインスタンスを作成
            self.Btn.setFixedWidth(100)  # QPushButton の幅を設定
            self.Btn.clicked.connect(self.accept)  # シグナル clicked を QDialog クラスのメソッド accept() に接続
            self.Btn_layout.addWidget(self.Btn)  # インスタンスをボタンのコンテナのレイアウトに追加
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    ################################
    # ### クラス内外から呼ばれる関数 ###
    ################################

    # カスタムダイアログを表示する関数
    def Dialog(self, Title, Text):
        """ この部分を「関数の docstring」と言います。
        カスタムダイアログを表示する関数。

        この関数は、指定されたタイトルとテキストを持つカスタムダイアログを作成し、表示します。ダイアログは MainThreadFunctionsClass.CustomDialogClass を
        使用して作成し、このインスタンスをメソッド exec_() で実行します。QDialog クラスを継承しているこのインスタンスがダイアログとして表示される際、
        ダイアログウィンドウはモーダルウィンドウとして表示されます。これは、QDialog クラスがデフォルトでモーダルウィンドウを表示する仕様のためです。モーダル
        ウィンドウとは、ユーザーがそのウィンドウに対して何らかの対応、つまり閉じるボタンや OK ボタンを押すなどしない限り、アプリケーションの他の GUI に対する
        操作をブロックするウィンドウのことを言います。GUI に関連する処理はメインスレッドで行われなければならない原則上、モーダルウィンドウが表示されている間は
        メインスレッドの後続の処理は全て待機状態になります。ただし、バックグラウンドスレッドについてはこの限りではありません。バックグラウンドスレッドが行って
        いる処理が GUI からの入力待ちの状態にならない限り、バックグラウンドスレッドの処理は継続的に実行され続けます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Title (str): ダイアログのタイトル。
            Text (str): ダイアログに表示するテキスト。

        Returns:
            なし。
        """
        Dialog = MainThreadFunctionsClass.CustomDialogClass(self.App, Title, Text)  # カスタムダイアログインスタンスの作成
        Dialog.exec_()  # ダイアログの実行
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    ##############################
    # ### クラス内から呼ばれる関数 ###
    ##############################

    # ウィジェットのタイプに応じて値を取得する関数
    def GetWidgetVal(self, WidgetName = None, Widget = None):
        """ この部分を「関数の docstring」と言います。
        ウィジェットのタイプに応じて値を取得する関数。

        この関数は、様々なタイプの Qt ウィジェットから値を取得します。ウィジェットタイプはアルファベット順に並べられており、将来的に新たなウィジェットタイプに
        対応する場合も考慮されています。関数はウィジェットの名前（WidgetName）またはウィジェットオブジェクトの参照（Widget）のいずれかを引数として受け取り
        ます。GUI からの値取得処理をアプリケーション全体で可能な限りこの関数に集約することで、将来的にフレームワークの移行が必要になった場合に移行にかかるコスト
        を抑えることができます。
        処理の各過程に対応するログが LogManagerClass によって ProcessLog_0 に記録されます。この関数では、ログの記録を通常とは異なる関数 RecordLOG() に
        よって行います。これは、この関数が for ループ内で呼び出されるシナリオが想定され、その場合、不必要に多くの値取得ログを出力することになるためです。関数
        RecordLOG() はログを直接ログテキストエリアに挿入せず、一度 LogManagerClass の ProcessLog 属性に保持します。これにより、この関数の呼び出し元では、
        ループ処理後にログをどのように扱うかを別途判断することができます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            WidgetName (str, optional): 値を取得するウィジェットの名前。デフォルトは None。
            Widget (QWidget, optional): 値を取得するウィジェットオブジェクトの参照。デフォルトは None。

        Returns:
            Any: ウィジェットから取得した値。未対応のウィジェットタイプの場合は None。

        Usage:
            Value = GetWidgetVal(WidgetName = "myLineEdit")
            または
            Value = GetWidgetVal(Widget = myLineEditObject)
        """
        if WidgetName is not None:  # ウィジェット参照の解決（WidgetName が指定されている場合）
            try:  # エラーを検出するブロック
                Widget = getattr(self.App, WidgetName, None)  # AppClass（self.App）属性の WidgetName 属性からウィジェットの参照を取得
                self.LogManager.RecordLOG("ウィジェットオブジェクト取得", self.App.一般)
            except Exception as e:  # ウィジェット取得失敗時
                self.LogManager.RecordLOG("ウィジェットオブジェクト取得失敗「{0}」".format(str(e)), self.App.一般)
        elif Widget is not None:  # ウィジェット参照の解決（Widget が指定されている場合）
            Widget = Widget  # Widget（参照）をそのまま使用
        else:  # WidgetName も Widget も指定されていない（None）場合
            return  # 処理を終了

        if isinstance(Widget, QCheckBox):  # QCheckBox の場合
            Value = Widget.isChecked()  # チェック状態の取得
            self.LogManager.RecordLOG("チェックボックスの値取得完了", self.App.一般)
        elif isinstance(Widget, QComboBox):  # QComboBox の場合
            Value = Widget.currentText()  # 現在選択されているテキストの取得
            self.LogManager.RecordLOG("コンボボックスの値取得完了", self.App.一般)
        elif isinstance(Widget, QDateEdit):  # QDateEdit の場合
            Value = Widget.date().toString(Qt.ISODate)  # 日付の取得
            self.LogManager.RecordLOG("日付エディットの値取得完了", self.App.一般)
        elif isinstance(Widget, QDateTimeEdit):  # QDateTimeEdit の場合
            Value = Widget.dateTime().toString(Qt.ISODate)  # 日時の取得
            self.LogManager.RecordLOG("日時エディットの値取得完了", self.App.一般)
        elif isinstance(Widget, QDoubleSpinBox):  # QDoubleSpinBox の場合
            Value = Widget.value()  # 浮動小数点数（float）の取得
            self.LogManager.RecordLOG("ダブルスピンボックスの値取得完了", self.App.一般)
        elif isinstance(Widget, QLineEdit):  # QLineEdit の場合
            Value = Widget.text().strip()  # テキストを取得して両端の空白文字を除去
            self.LogManager.RecordLOG("ラインエディットの値取得完了", self.App.一般)
        elif isinstance(Widget, QProgressBar):  # QProgressBar の場合
            Value = Widget.value()  # 進捗値の取得
            self.LogManager.RecordLOG("プログレスバーの値取得完了", self.App.一般)
        elif isinstance(Widget, QRadioButton):  # QRadioButton の場合
            Value = Widget.isChecked()  # チェック状態の取得
            self.LogManager.RecordLOG("ラジオボタンの値取得完了", self.App.一般)
        elif isinstance(Widget, QSlider):  # QSlider の場合
            Value = Widget.value()  # スライダー値の取得
            self.LogManager.RecordLOG("スライダーの値取得完了", self.App.一般)
        elif isinstance(Widget, QSpinBox):  # QSpinBox の場合
            Value = Widget.value()  # 整数値（int）の取得
            self.LogManager.RecordLOG("スピンボックスの値取得完了", self.App.一般)
        elif isinstance(Widget, QTextEdit):  # QTextEdit の場合
            Value = Widget.toPlainText().strip()  # プレーンテキストを取得して両端の空白文字を除去
            self.LogManager.RecordLOG("テキストエディットの値取得完了", self.App.一般)
        elif isinstance(Widget, QTimeEdit):  # QTimeEdit の場合
            Value = Widget.time().toString(Qt.ISODate)  # 時間の取得
            self.LogManager.RecordLOG("時間エディットの値取得完了", self.App.一般)
        else:  # 対応していないウィジェットタイプの場合
            Value = None  # 値を None に設定
            self.LogManager.RecordLOG("未対応のウィジェットタイプ：{0}".format(str(type(Widget).__name__)), self.App.一般)

        return Value  # 取得値を返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # ウィジェットのタイプに応じて値を設定する関数
    def SetWidgetVal(self, WidgetName = None, Widget = None, Value = None):
        """ この部分を「関数の docstring」と言います。
        ウィジェットのタイプに応じて値を設定する関数。

        この関数は、様々なタイプの Qt ウィジェットに対して値を設定します。ウィジェットタイプはアルファベット順に並べられており、将来的に新たなウィジェットタイプ
        に対応する場合も考慮されています。関数はウィジェットの名前（WidgetName）またはウィジェットオブジェクトの参照（Widget）のいずれかを引数として受け取り
        ます。GUI への値設定処理をアプリケーション全体で可能な限りこの関数に集約することで、将来的にフレームワークの移行が必要になった場合に移行にかかるコストを
        抑えることができます。
        処理の各過程に対応するログが LogManagerClass によって ProcessLog_0 に記録されます。この関数では、ログの記録を通常とは異なる関数 RecordLOG()
        によって行います。これは、この関数が for ループ内で呼び出されるシナリオが想定され、その場合、不必要に多くの値取得ログを出力することになるためです。関数
        RecordLOG() はログを直接ログテキストエリアに挿入せず、一度 LogManagerClass の ProcessLog 属性に保持します。これにより、この関数の呼び出し元では、
        ループ処理後にログをどのように扱うかを別途判断することができます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            WidgetName (str, optional): 値を設定するウィジェットの名前。デフォルトは None。
            Widget (QWidget, optional): 値を設定するウィジェットの参照。デフォルトは None。
            Value (Any): ウィジェットに設定する値。デフォルトは None。

        Returns:
            なし。

        Usage:
            SetWidgetVal(WidgetName = "myLineEdit", Value = "Any")
            または
            SetWidgetVal(Widget = myLineEditObject, Value = "Any")
        """
        if WidgetName is not None:  # ウィジェット参照の解決（WidgetName が指定されている場合）
            try:  # エラーを検出するブロック
                Widget = getattr(self.App, WidgetName, None)  # AppClass（self.App）属性の WidgetName 属性からウィジェットの参照を取得
                self.LogManager.RecordLOG("ウィジェットオブジェクト取得", self.App.一般)
            except Exception as e:  # ウィジェットオブジェクト取得失敗時
                self.LogManager.RecordLOG("ウィジェットオブジェクト取得失敗「{0}」".format(str(e)), self.App.一般)
        elif Widget is not None:  # ウィジェット参照の解決（Widget が指定されている場合）
            Widget = Widget  # Widget（参照）をそのまま使用
        else:  # WidgetName も Widget も指定されていない（None）場合
            return  # 処理を終了

        if isinstance(Widget, QCheckBox):  # Widget が QCheckBox の場合
            Widget.setChecked(Value)  # チェック状態を設定
        elif isinstance(Widget, QComboBox):  # Widget が QComboBox の場合
            Index = Widget.findText(Value)  # Value に対応するインデックスを検索
            if Index >= 0:  # インデックスが見つかった場合
                Widget.setCurrentIndex(Index)  # 現在選択されているインデックスを該当インデックスに設定
        elif isinstance(Widget, QDateEdit):  # Widget が QDateEdit の場合
            if isinstance(Value, QDate):  # Value が QDate 型の場合
                Widget.setDate(Value)  # 日付を設定
        elif isinstance(Widget, QDateTimeEdit):  # Widget が QDateTimeEdit の場合
            if isinstance(Value, QDateTime):  # Value が QDateTime 型の場合
                Widget.setDateTime(Value)  # 日時を設定
        elif isinstance(Widget, QDoubleSpinBox):  # Widget が QDoubleSpinBox の場合
            Widget.setValue(Value)  # 浮動小数点数（float）を設定
        elif isinstance(Widget, QLabel):  # Widget が QLabel の場合
            Widget.setText(Value)  # テキストを設定
        elif isinstance(Widget, QLineEdit):  # Widget が QLineEdit の場合
            Widget.setText(Value)  # テキストを設定
        elif isinstance(Widget, QProgressBar):  # Widget が QProgressBar の場合
            Widget.setValue(Value)  # 進捗値を設定
        elif isinstance(Widget, QPushButton):  # Widget が QPushButton の場合
            Widget.setText(Value)  # ボタンのテキストを設定
        elif isinstance(Widget, QRadioButton):  # Widget が QRadioButton の場合
            Widget.setChecked(Value)  # チェック状態を設定
        elif isinstance(Widget, QSlider):  # Widget が QSlider の場合
            Widget.setValue(Value)  # スライダー値を設定
        elif isinstance(Widget, QSpinBox):  # Widget が QSpinBox の場合
            Widget.setValue(Value)  # 整数値（int）を設定
        elif isinstance(Widget, QTextEdit):  # Widget が QTextEdit の場合
            if "<" in Value and ">" in Value:  # Value に HTML タグが含まれる場合
                Widget.setHtml(Value)  # HTML としてテキストを設定
            else:
                Widget.setPlainText(Value)  # プレーンテキストとして設定
        elif isinstance(Widget, QTimeEdit):  # Widget が QTimeEdit の場合
            if isinstance(Value, QTime):  # Value が QTime 型の場合
                Widget.setTime(Value)  # 時間を設定
        else:  # 他のウィジェットタイプに対応する場合はここに追加
            pass  # 何も行わない

        self.LogManager.RecordLOG("値のセット完了", self.App.一般)
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 数量入力欄に全角の値が入力された場合に半角に変換する関数
    def FullToHalfWidthCharacter(self, Amount):
        """ この部分を「関数の docstring」と言います。
        数量入力欄に全角の値が入力された場合に半角に変換する関数。

        この関数は、入力された文字列（str）中の全角数字とピリオドを半角に変換します。主に数量入力欄で入力された値に対する使用を想定しています。数量の入力が必要
        な箇所で全角文字での入力が行われると、プログラムはその文字列（str）を数値型（int or float）として取り扱うことができません。このため、全角文字で数量の
        入力が行われた場合は、それを適切に半角文字に置き換え、数値型（int or float）に変換可能な文字列（str）とする処理が必要です。一方で、半角文字での入力が
        必要な箇所で全角文字が入力された場合に、半角文字で入力するように促すダイアログを表示する方法も考えられますが、こちらはユーザーに再入力を求めることに
        なります。この観点から、再入力を求めるよりも、プログラム内で自動的に置き換えるアプローチの方が、より良いユーザーエクスペリエンスを提供することに寄与
        します。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Amount (str): 変換対象の文字列。

        Returns:
            str: 全角文字を半角に変換した文字列。
        """
        TransTable = str.maketrans("０１２３４５６７８９．", "0123456789.")  # 文字列変換テーブルの作成
        return Amount.translate(TransTable)  # 文字列変換テーブルを使用して変換した文字列（str）を返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 構造化された Python データを JSON 形式を模した文字列（str）に変換する関数
    def MessageStructure(self, StructuredData, Indent = 0):
        """ この部分を「関数の docstring」と言います。
        構造化された Python データを JSON 形式を模した文字列（str）に変換する関数。

        この関数は、Python データを JSON 形式を模した文字列に直接変換します。この関数は関数 json.dumps() を使用せずに、Python データの値やデータ型を直接的
        な文字列や記号を使用して表現します。関数 json.dumps() を使用すると、Python データの値やデータ型が完全に JSON 形式に適合する文字列に変換されてしまい、
        これは、Python データの内容を正確に確認する必要があるデバッグシーンなどには適していません。従って、この関数のアプローチは、デバッグシーンなどデータの
        内容を正確に確認する必要がある際に特に有用です。ただし、この関数が出力する文字列は JSON 形式の標準に厳密に従うものではありません。値やデータ型の変換を
        特異な形で行うため、JSON パーサによる解析には適していません。この関数が出力する文字列は、デバッグやダイアログ表示用に特別に設計されています。この関数は、
        メインフレーム「接続先編集」タブの「データパスをテスト」ボタンが押された際の、API レスポンスの JSON サンプルデータから値を抽出した結果の確認などに使用
        されます。

        関数 json.dumps() にはない、この関数の変換ポリシーは以下の通りです：
        - None は "None" という文字列（str）に変換します。
        - ブール値 True と False は "True" と "False" という文字列（str）に変換します。
        - 数値型（整数及び浮動小数点数、int or float）は、その数値をそのまま文字列（str）にします。
        - 文字列（str）はそのまま文字列として扱います。引用符で囲むことはしません。
        - 辞書はブレース "{}" で表現し、各要素は「"キー": 値」の形式で要素毎に改行します。キーは文字列（str）として引用符で囲みます。
        - リストはブラケット "[]" で表現し、その中の要素はカンマで区切ります。
        - タプルはパレン "()" で表現し、その中の要素はカンマで区切ります。
        - セットは辞書と同様に "{}" で表現し、その中の要素はカンマで区切ります。この関数内のコメントでは区別のため、同記号をカーリーブレースと表記します。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            StructuredData (dict or list or tuple or set): 解析する Python データ構造体（辞書、リスト、タプル、セットなど）。
            Indent (int, optional): 現在のインデントレベル（初期値は 0）。このパラメータは、この関数が自身を再起的に呼び出す際に使用します。

        Returns:
            str: 解析結果の文字列。
        """
        Message = ""  # 変数を初期化

        if isinstance(StructuredData, dict):  # 辞書の処理の場合
            Message += "{" + self.LF  # 開始ブレースと改行を追加

            for Key, Value in StructuredData.items():  # 辞書の要素を処理するためのイテレーション
                Message += "  " * (Indent + 1) + "\"{0}\": ".format(str(Key))  # キーをダブルクォーテーションで囲む
                Message += self.MessageStructure(Value, Indent + 1) + self.LF  # 各要素を再帰的に処理
                """
この関数は、Python データの構造を探索し、それを JSON 形式を模した文字列（str）に変換する探索者のような役割を果たします。ここで、Python のデータ構造体を一つの
大きなダンジョンと見立てます。このダンジョンには、辞書、リスト、タプル、セットなど、さまざまな「部屋」が存在します。それぞれの部屋は複数の要素を持ち得るデータ型を
表し、探索者（この関数）がそれらの部屋を一つ一つ探索し尽くします。辞書型の部屋では、キーと値のペアがその部屋の「宝物」となります。この探索者は、各宝物に注目し、
値がさらに複雑な構造を持つ場合、つまり別の部屋への入り口がある場合は、さらにその部屋に入って探索を続けます。全ての宝物を調べ尽くした後、元の部屋に戻る、つまり
イテレーションを終了することで、その辞書の部屋の探索を完了します。リストやタプルの部屋では、探索者は部屋の中を一つ一つの要素、つまり宝物の内容である値を確認
しながら進みます。要素が宝物ではなく新たな部屋への扉の場合、探索者はその部屋に入り、同様に探索を行います。この連続した探索を通じて、リストやタプルの全体像を把握
します。一つ一つの要素を調べ終えると､「元の部屋に戻る」という形で、イテレーションから抜けます。セットの部屋も似たような探索が行われますが、セットは宝物の所在、
つまり順番が不定なため、どの宝物を先に調べるかが毎回異なる可能性があります。それでも探索者は、見つけた全ての宝物を調査し、それぞれを記録します。単純なデータ型、
例えば数値（int or float）や文字列（str）は、ダンジョンの各部屋に配置されている宝物、つまり値で、探索者はこれらを記録するために探索を行います。この探索を通じて、
この関数は単なるデータ変換ツールではなく、プログラマーがデータの構造を完全に理解し、その内容を確認するための重要なリソースとなります。このアプローチにより、データ
の階層と構造を正確に把握しながら、それを分かりやすく表現することができます。この関数を利用することで、プログラマーはデータの迷宮を自信を持ってナビゲートできるよう
になり、プログラミングの過程で遭遇する複雑なデータ構造と効果的に対峙できます。このようにして、この関数はデータの探索と解明のための強力な、プログラミングの
旅先案内人の役割を果たします。
                """

            Message += "  " * Indent + "}"  # 辞書の最後の要素を処理した場合、終了ブレースを追加
        elif isinstance(StructuredData, list):  # リストの処理の場合
            Message += "["  # 開始ブラケットを追加

            for Index, Item in enumerate(StructuredData):  # リストの要素を処理するためのイテレーション
                if Index > 0:  # 処理対象の要素のインデックスが 1 以上の場合、カンマを追加
                    Message += ", "  # カンマを追加

                Message += self.MessageStructure(Item, Indent)  # 各要素を再帰的に処理

            Message += "]"  # リストの最後の要素を処理した場合、終了ブラケットを追加
        elif isinstance(StructuredData, tuple):  # タプルの処理の場合
            Message += "("  # 開始パレンを追加

            for Index, Item in enumerate(StructuredData):  # タプルの要素を処理するためのイテレーション
                if Index > 0:  # 処理対象の要素のインデックスが 1 以上の場合、カンマを追加
                    Message += ", "  # カンマを追加

                Message += self.MessageStructure(Item, Indent)  # 各要素を再帰的に処理

            Message += ")"  # タプルの最後の要素を処理した場合、終了パレンを追加
        elif isinstance(StructuredData, set):  # セットの処理
            Message += "{"  # 開始カーリーブレースを追加

            for Index, Item in enumerate(StructuredData):  # セットの要素を処理するためのイテレーション
                if Index > 0:  # 処理対象の要素のインデックスが 1 以上の場合、カンマを追加
                    Message += ", "  # カンマを追加

                Message += self.MessageStructure(Item, Indent)  # 各要素を再帰的に処理

            Message += "}"  # セットの最後の要素を処理した場合、終了カーリーブレースを追加
        else:  # 値の処理
            Message += "{0}".format(str(StructuredData))  # 値をそのまま結果に含める

        return Message  # 解析を完了して作成した文字列（str）を返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # macOS でシステム変更に必要な管理者権限を要求する関数
    def requestPERMISSION_ofMac(self):
        """ この部分を「関数の docstring」と言います。
        macOS でシステム変更に必要な管理者権限を要求する関数。

        この関数は、"osascript" を使用して、管理者権限を要求するダイアログを表示します。このアプリケーションでは基本的にシステムに対する変更は行いませんが、
        API キーや API シークレットなどの敏感情報を取り扱う必要があるため、これらに対する表示や変更、削除といった特定の操作を実行する際にユーザーがシステムの
        変更権限を持っているかを確認することで、敏感情報に対する漏洩リスクの低減を図ります。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            bool: 管理者権限が付与された場合、True。そうでなければ False。
        """
        try:  # エラーを検出するブロック
            subprocess.run(  # osascript を実行して権限を要求
                ["osascript", "-e", 'do shell script "echo ユーザー認証通過" with administrator privileges'],
                check = True)  # macOS の AppleScript を使用して管理者権限でシェルスクリプトを実行し、subprocess.run のエラーをチェック
            """
このコード部分では、関数 subprocess.run() を使用して、Python から AppleScript を呼び出し、その AppleScript を通じて「echo ユーザー認証通過」という
コマンドを管理者権限で実行するシェルスクリプトを起動しています。このアプリケーションでは、コーディングルールとしてシングルクォーテーションよりもダブル
クォーテーションを優先して使用するように定めていますが、AppleScript 内でシェルコマンドの文字列をダブルクォーテーションで囲む必要があるため、ここでは外側の
Python 文字列にはシングルクォーテーションを使用しています。このように Python コード内でのクォーテーションの使い分けを正しく行うことで、AppleScript での
コマンド実行時にダブルクォーテーションが適切に扱われるようにしています。
            """
            return True  # スクリプトが成功した場合、True を返す
        except subprocess.CalledProcessError as e:  # CalledProcessError が発生した場合
            self.LogManager.InsertLOG("管理者権限の確認に失敗しました。「{0}」".format(str(e)), self.App.一般)
            return False  # スクリプトが失敗した場合、False を返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # Linux でシステム変更に必要な管理者権限を要求する関数
    def requestPERMISSION_ofLinux(self):
        """ この部分を「関数の docstring」と言います。
        Linux でシステム変更に必要な管理者権限を要求する関数。

        この関数は、"sudo" を使用して、管理者権限を要求するダイアログを表示します。このアプリケーションでは基本的にシステムに対する変更は行いませんが、
        API キーや API シークレットなどの敏感情報を取り扱う必要があるため、これらに対する表示や変更、削除といった特定の操作を実行する際にユーザーがシステムの
        変更権限を持っているかを確認することで、敏感情報に対する漏洩リスクの低減を図ります。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            bool: 管理者権限が付与された場合、True。そうでなければ False。
        """
        try:  # エラーを検出するブロック
            subprocess.run(  # sudo を実行して権限を要求
                ["sudo", "echo", "ユーザー認証通過"],  # 管理者権限で echo コマンドを実行
                check = True)  # subprocess.run のエラーをチェック
            return True  # スクリプトが成功した場合、True を返す
        except subprocess.CalledProcessError as e:  # CalledProcessError が発生した場合
            self.LogManager.InsertLOG("管理者権限の確認に失敗しました。「{0}」".format(str(e)), self.App.一般)
            return False  # スクリプトが失敗した場合、False を返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # Windows でシステム変更に必要な管理者権限を要求する関数
    def requestPERMISSION_ofWindows(self):
        """ この部分を「関数の docstring」と言います。
        Windows でシステム変更に必要な管理者権限を要求する関数。

        この関数は、"runas" を使用して、管理者権限を要求するダイアログを表示します。このアプリケーションでは基本的にシステムに対する変更は行いませんが、
        API キーや API シークレットなどの敏感情報を取り扱う必要があるため、これらに対する表示や変更、削除といった特定の操作を実行する際にユーザーがシステムの
        変更権限を持っているかを確認することで、敏感情報に対する漏洩リスクの低減を図ります。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            bool: 管理者権限が付与された場合、True。そうでなければ False。
        """
        try:  # エラーを検出するブロック
            subprocess.run(  # runas を実行して権限を要求
                ["runas", "/user:Administrator", "cmd /c echo ユーザー認証通過"],  # 管理者権限で echo コマンドを実行
                check = True)  # subprocess.run のエラーをチェック
            return True  # スクリプトが成功した場合、True を返す
        except subprocess.CalledProcessError as e:  # CalledProcessError が発生した場合
            self.LogManager.InsertLOG("管理者権限の確認に失敗しました。「{0}」".format(str(e)), self.App.一般)
            return False  # スクリプトが失敗した場合、False を返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # ユーザーにパスワード入力を求める関数
    def AskPassword(self):
        """ この部分を「関数の docstring」と言います。
        ユーザーにパスワード入力を求める関数。

        この関数は、関数 self.requestPERMISSION_ofMac() を使用してシステム変更権限を要求します。権限が付与された場合、関数は True を返します。権限が付与
        されなかった場合、エラーメッセージを表示し、False を返します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            bool: 権限が付与された場合、True。そうでなければ False。
        """
        OSname = platform.system()  # アプリケーションが実行されている OS の名前を取得

        if OSname == "Darwin":  # macOS の場合
            if self.requestPERMISSION_ofMac():  # システム変更権限の要求
                return True  # 成功した場合、True を返す
            else:  # システム変更権限の要求が失敗した場合
                QMessageBox.critical(self.App, "エラー", "ユーザー認証に失敗しました。")  # ダイアログを表示
                return False  # 失敗した場合、False を返す
        elif OSname == "Linux":  # Linux の場合
            if self.requestPERMISSION_ofLinux():  # システム変更権限の要求
                return True  # 成功した場合、True を返す
            else:  # システム変更権限の要求が失敗した場合
                QMessageBox.critical(self.App, "エラー", "ユーザー認証に失敗しました。")  # ダイアログを表示
                return False  # 失敗した場合、False を返す
        elif OSname == "Windows":  # Windows の場合
            if self.requestPERMISSION_ofWindows():  # システム変更権限の要求
                return True  # 成功した場合、True を返す
            else:  # システム変更権限の要求が失敗した場合
                QMessageBox.critical(self.App, "エラー", "ユーザー認証に失敗しました。")  # ダイアログを表示
                return False  # 失敗した場合、False を返す
        else:  # 未知の OS の場合
            QMessageBox.critical(self.App, "エラー", "サポートされていない OS です。")  # ダイアログを表示
            return False  # 失敗した場合、False を返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # キャッシュファイルの読み込み中にエラーが発生して正しくデータを読み込めない場合のファイル再作成処理のファイル消去処理を行う関数
    def ErrorHandler_ofRemoveCacheFileOfRecreate(self, CallNum, LogSection, FilePath, ErrorBody = None):
        """ この部分を「関数の docstring」と言います。
        キャッシュファイルの読み込み中にエラーが発生して正しくデータを読み込めない場合のファイル再作成処理のファイル消去処理を行う関数。

        この関数は､「with open()」によってキャッシュファイルなどのファイルを展開し、その後の処理でエラーが発生した場合に、そのエラーを補足した呼び出し元の
        except ブロックで、ユーザーにファイルの再作成を行うかを問う処理と、その後のユーザーの選択に基づくファイル消去処理または何も行わない処理を行います。この
        関数はこれらの処理を行う際のエラーハンドリングを含み、処理に失敗する場合はエラーをシステムログに記録し、さらに、処理に失敗したことをユーザーに知らせる
        ダイアログの表示を行います。ファイル消去処理が成功した場合、それに伴って関連するファイルも消去する必要がある場合は、呼び出し元で先の CallNum = 1 での
        呼び出しに続けて 2 での呼び出しを行うことで、これを行うことができます。この場合の処理にも適切なエラーハンドリングが施されており、状況に応じた適切な
        システムログを記録し、適切な値を返します。
        処理の各過程に対応するログは LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            CallNum (int):
                動作モードを指定する整数値（1 または 2）。通常は 1 を指定。1 でのファイル消去に伴って同様に消去する必要があるファイルを消去する場合は 2。
            LogSection (str): 現在の処理内容を示す文字列｡「LogSection：ログ内容」の形式でシステムログを記録するためのもの。
            FilePath (str): キャッシュファイルのファイルパス。
            ErrorBody (Exception, optional):
                例外オブジェクト。具体的なエラーの型は実行時のコンテキストに依存。通常は "Exception" クラスまたはそのサブクラスのインスタンス。
                CallNum を 2 で呼び出す場合は指定不要。

        Returns:
            bool: 処理に成功した場合、True。そうでなければ False。
        """
        if CallNum == self.App.主:  # エラーを起こしたファイルを消去する場合
            self.LogManager.InsertLOG("{0}：キャッシュファイルの読み込み中にエラーが発生しました。エラー内容「{1}」".format(
                str(LogSection), str(ErrorBody)), self.App.一般)
            QMessageBox.critical(self.App, "エラー", "キャッシュファイルを正しく読み込むことができません。")  # ダイアログを表示
            Reply = QMessageBox.question(self.App,  # 選択肢を示すダイアログを表示
                "ファイル再作成", "ファイルを消去して新しいファイルを作成しますか？", QMessageBox.Yes | QMessageBox.No)
            if Reply == QMessageBox.Yes:  # ユーザーがファイル再作成を選択した場合
                try:  # エラーを検出するブロック
                    os.remove(FilePath)  # キャッシュファイルを消去
                    self.LogManager.InsertLOG("{0}：キャッシュファイル消去成功".format(str(LogSection)), self.App.一般)
                    QMessageBox.information(self.App, "ファイル消去成功", "エラーを引き起こしたファイルの消去に成功しました。")  # ダイアログを表示
                    return True  # 処理を終了して True を返す
                except Exception as e:  # 何らかのエラーが発生した場合
                    self.LogManager.InsertLOG("{0}：キャッシュファイル消去失敗「{1}」".format(str(LogSection), str(e)), self.App.一般)
                    QMessageBox.critical(self.App, "エラー", ("キャッシュファイルを消去できません。手動での消去を試みてください。"
                        "{0}ファイルパス：{1}").format(self.LF, str(FilePath)))  # ダイアログを表示
                    return False  # 処理を終了して False を返す
            elif Reply == QMessageBox.No:  # ユーザーがファイル再作成を選択しなかった場合、処理を終了
                return False  # 処理を終了して False を返す
        elif CallNum == self.App.副:  # エラーを起こしたファイルを消去したことに伴って関連ファイルを消去する必要がある場合
            self.LogManager.InsertLOG("{0}：関連ファイル消去開始".format(str(LogSection)), self.App.一般)
            if os.path.exists(FilePath):  # キャッシュファイルが存在する場合、消去処理を実行
                try:  # エラーを検出するブロック
                    os.remove(FilePath)  # 関連ファイルを消去
                    self.LogManager.InsertLOG("{0}：関連ファイル消去完了".format(str(LogSection)), self.App.一般)
                    QMessageBox.information(self.App, "関連ファイル消去成功", ("エラーを引き起こしたファイルの消去に伴って消去する必要が生じた関連"
                        "ファイルの消去に成功しました。"))  # ダイアログを表示
                    return True  # 処理を終了して True を返す
                except Exception as e:  # 何らかのエラーが発生した場合
                    self.LogManager.InsertLOG("{0}：関連ファイル消去失敗「{1}」".format(str(LogSection), str(e)), self.App.一般)
                    QMessageBox.critical(self.App, "エラー", ("関連ファイルを消去できません。手動での消去を試みてください。"
                        "{0}ファイルパス：{1}").format(self.LF, str(FilePath)))  # ダイアログを表示
                    return False  # 処理を終了して False を返す
            else:  # キャッシュファイルが存在しない場合、処理を終了
                return True  # 処理を終了して True を返す（消去処理を実行して成功した場合と同様）
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # キャッシュファイルへの書き込みまたは読み込み試行に伴って発生し得るエラーハンドリングを行う関数
    def ErrorHandler_ofOpenCache(self, LogSection, FilePath, Mode, WriteData = None, ObjectList = None, CallNum = None,
        FilePaths = None):
        """ この部分を「関数の docstring」と言います。
        キャッシュファイルへの書き込みまたは読み込み試行に伴って発生し得るエラーハンドリングを行う関数。

        この関数は、キャッシュファイルにデータを書き込む、または読み込む必要がある際に施すべきエラーハンドリングを包括する関数です。キャッシュファイルへの書き
        込みまたは読み込み時には、引数 FilePath の拡張子に基づいて適切な書き込みまたは読み込み方法を選択します。処理中に IOError または OSError が発生した
        場合、キャッシュファイルを再作成する処理の一部であるファイル消去処理シークエンスを開始します。このシークエンスには、実際にキャッシュファイルを再作成する
        必要があるかをユーザーに問うプロセスが含まれ、ユーザーの選択に基づいて消去処理を実行、または何もしません。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            LogSection (str): 現在の処理内容を示す文字列｡「LogSection：ログ内容」の形式でシステムログを記録するためのもの。
            FilePath (str): キャッシュファイルのファイルパス。
            Mode (str): キャッシュファイルの読み書きモードを指定する文字列｡「with open()」で指定するもの。
            WriteData (object, optional):
                キャッシュファイルに書き込むデータオブジェクト。読み込みの場合は None（デフォルト）。JSON データを書き込む場合、Python オブジェクト。
                バイト列（bytes）を書き込む場合、そのリスト。
            ObjectList (list, optional):
                キャッシュファイルから読み込むオブジェクトのリスト。バイト指定を行う場合、整数値（int）のリスト。デフォルトは None（全体読み込み）。
            CallNum (int, optional):
                この値を使用するのは、関数 self.ErrorHandler_ofRemoveCacheFileOfRecreate() を呼び出す必要が生じた場合。同関数の動作モードを指定する
                整数値（1 または 2）。通常は 1 を指定。1 でのファイル消去に伴って同様に消去する必要があるファイルを消去する場合は 2。デフォルトは None（1）。
            FilePaths (list, optional):
                FilePath に関連するキャッシュファイルのファイルパスのリスト。CallNum に 2 を指定する場合に使用。デフォルトは None。

        Returns:
            str or list or None or bool:
                書き込みが完了したことを示す文字列「書き込み完了（str）」。または読み込んだデータのリスト。
                読み込み時にキャッシュファイルが存在しない場合、None。
                書き込みまたは読み込みに失敗した場合、bool 値。ファイル消去が成功した場合、True。そうでなければ False。
        """
        if Mode[0] == "w" or os.path.exists(FilePath):  # 書き込みモードの場合、またはキャッシュファイルが存在する場合
            try:  # エラーを検出するブロック
                # グローバル関数でキャッシュファイルに書き込みまたは読み込み
                return FileOpener(self.LogManager, LogSection, FilePath, Mode, WriteData = WriteData, ObjectList = ObjectList)
            except json.JSONDecodeError as e:  # JSONDecodeError が発生した場合、ファイル再作成処理のファイル消去処理シークエンスを開始
                self.LogManager.InsertLOG("{0}：JSON 形式エラー発生".format(str(LogSection)), self.App.一般)
                # ファイル再作成処理のファイル消去処理の成否を返す
                return self.ErrorHandler_ofRemoveCacheFileOfRecreate(self.App.主, LogSection, FilePath, ErrorBody = e)
            except (IOError, OSError) as e:  # IOError または OSError が発生した場合、ファイル再作成処理のファイル消去処理シークエンスを開始
                if CallNum == None or CallNum == self.App.主:  # CallNum が None または 1 の場合
                    # ファイル再作成処理のファイル消去処理の成否を返す
                    return self.ErrorHandler_ofRemoveCacheFileOfRecreate(self.App.主, LogSection, FilePath, ErrorBody = e)
                elif CallNum == self.App.副:  # CallNum が 2 の場合
                    # ファイル再作成処理のファイル消去処理（初回）が成功した場合
                    if self.ErrorHandler_ofRemoveCacheFileOfRecreate(self.App.主, LogSection, FilePath, ErrorBody = e):
                        for FilePath in FilePaths:  # FilePaths からファイルパスを取り出すためのイテレーション
                            # ファイル再作成処理のファイル消去処理が失敗した場合、処理を終了
                            if not self.ErrorHandler_ofRemoveCacheFileOfRecreate(self.App.副, LogSection, FilePath):
                                return False  # 処理を終了して False を返す
                        else:  # ファイル再作成処理のファイル消去処理が全て成功した場合
                            return True  # 処理を終了して True を返す
                    else:  # ファイル再作成処理のファイル消去処理（初回）が失敗した場合
                        return False  # 処理を終了して False を返す
            except Exception as e:  # 何らかのエラーが発生した場合
                ModeStr = "書き込み" if Mode[0] == "w" else "読み込み"  # メッセージ表示用の読み書きモードを示す文字列（str）を作成
                self.LogManager.InsertLOG("{0}：予期しないエラー「{1}」".format(str(LogSection), str(e)), self.App.一般)
                QMessageBox.critical(self.App, "予期しないエラー", ("キャッシュファイルの{0}中に予期しないエラーが発生しました。"
                    "エラー内容「{1}」").format(str(ModeStr), str(e)))  # ダイアログを表示
                return False  # 処理を終了して False を返す
        else:  # キャッシュファイルが存在しない場合
            self.LogManager.InsertLOG("{0}：キャッシュファイルなし".format(str(LogSection)), self.App.一般)
            return None  # 処理を終了して None を返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # キャッシュファイルへの書き込みまたは読み込み試行の内書き込み処理においてファイル消去処理後のリトライ処理を含む関数
    def ErrorHandler_ofOpenCacheIncludeRetry(self, LogSection, FilePath, Mode, WriteData = None, ObjectList = None, CallNum = None,
        FilePaths = None):
        """ この部分を「関数の docstring」と言います。
        キャッシュファイルへの書き込みまたは読み込み試行の内書き込み処理においてファイル消去処理後のリトライ処理を含む関数。

        この関数は、関数 self.ErrorHandler_ofOpenCache() の呼び出し時に必要となる追加的なアプローチをカプセル化したものです。追加的なアプローチとは、
        キャッシュファイルへのデータの書き込み試行時にエラーが発生し、ファイル消去処理を実行した場合に、書き込み試行をしたデータを使用してファイルを再作成する
        ことです。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            LogSection (str): 現在の処理内容を示す文字列｡「LogSection：ログ内容」の形式でシステムログを記録するためのもの。
            FilePath (str): キャッシュファイルのファイルパス。
            Mode (str): キャッシュファイルの読み書きモードを指定する文字列｡「with open()」で指定するもの。
            WriteData (object, optional):
                キャッシュファイルに書き込むデータオブジェクト。読み込みの場合は None（デフォルト）。JSON データを書き込む場合、Python オブジェクト。
                バイト列（bytes）を書き込む場合、そのリスト。
            ObjectList (list, optional):
                キャッシュファイルから読み込むオブジェクトのリスト。バイト指定を行う場合、整数値（int）のリスト。デフォルトは None（全体読み込み）。
            CallNum (int, optional):
                この値を使用するのは、関数 self.ErrorHandler_ofRemoveCacheFileOfRecreate() を呼び出す必要が生じた場合。同関数の動作モードを指定する
                整数値（1 または 2）。通常は 1 を指定。1 でのファイル消去に伴って同様に消去する必要があるファイルを消去する場合は 2。デフォルトは None（1）。
            FilePaths (list, optional):
                FilePath に関連するキャッシュファイルのファイルパスのリスト。CallNum に 2 を指定する場合に使用。デフォルトは None。

        Returns:
            str or list or None or bool:
                書き込みが完了したことを示す文字列「書き込み完了（str）」。または読み込んだデータのリスト。
                読み込み時にキャッシュファイルが存在しない場合、None。
                書き込みまたは読み込みに失敗した場合、bool 値。ファイル消去が成功した場合、True。そうでなければ False。
        """
        # キャッシュファイルへの書き込みまたは読み込みをエラーハンドリング関数で実行
        Result = self.ErrorHandler_ofOpenCache(LogSection, FilePath, Mode, WriteData, ObjectList, CallNum, FilePaths)
        if Mode[0] == "w" and isinstance(Result, bool) and Result:  # 書き込みモードの場合、かつエラーのために行われたファイル消去処理が成功した場合
            Reply = QMessageBox.question(self.App,  # 選択肢を示すダイアログを表示
                "ファイル再作成", "ファイルへの書き込みを再試行しますか？", QMessageBox.Yes | QMessageBox.No)
            if Reply == QMessageBox.Yes:  # ユーザーがファイル再作成を選択した場合
                self.LogManager.InsertLOG("{0}：キャッシュファイル再作成開始".format(str(LogSection)), self.App.一般)
                # キャッシュファイルへの書き込みをエラーハンドリング関数で再実行
                NewResult = self.ErrorHandler_ofOpenCache(LogSection, FilePath, Mode, WriteData, ObjectList, CallNum, FilePaths)
                if NewResult == "書き込み完了":  # キャッシュファイルへの書き込みに成功した場合
                    self.LogManager.InsertLOG("{0}：キャッシュファイル再作成完了".format(str(LogSection)), self.App.一般)
                    QMessageBox.information(self.App, "ファイル再作成", ("ファイルへの書き込みの再試行に成功しました。{0}注意：元のファイルの内容が"
                        "欠損している可能性があり、これに起因する別のエラーが発生する可能性があります。").format(self.LF))  # ダイアログを表示
                    return NewResult  # 処理結果を返す
                else:  # キャッシュファイルへの書き込みに失敗した場合
                    self.LogManager.InsertLOG("{0}：キャッシュファイル再作成失敗".format(str(LogSection)), self.App.一般)
                    return NewResult  # 処理結果を返す
        return Result  # 処理結果を返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 選択された接続先の名前に基づいて接続先データを読み込む関数
    def LoadAccess(self, Selected_AccessName = None, CallNum = None, TabNum = None):
        """ この部分を「関数の docstring」と言います。
        選択された接続先の名前に基づいて接続先データを読み込む関数。

        この関数は、引数 Selected_AccessName が None の場合、接続先データのキャッシュファイルから接続先データを読み込みます。特定の接続先名が指定された
        場合、その接続先の詳細データを読み込み、引数 CallNum に基づいてウィジェットに値を設定、または待機辞書に値を格納します。ファイルが見つからない、または
        JSON 形式エラーが発生した場合、適切なエラーハンドリングを行い、必要に応じてキャッシュファイルを再作成します。Selected_AccessName として空文字列
        （str）が渡されることがありますが、この状況は先の Selected_AccessName が None の場合とは明確に区別します。この状況は「接続先編集」タブの
        「この接続先を削除」ボタンによって、全ての接続先が接続先リストから削除され、接続先リストのキャッシュファイル（JSON）が空の辞書となった場合に、接続先選択
        プルダウン（QComboBox）に空の self.App.AccessNames（この関数内で作成及び変更されるリスト）が設定され、それを検出した関数
        self.Trace_ExchangePull() によってもたらされます。従ってこの関数は、Selected_AccessName が空文字列（str）である場合をこの特定の状況であると解釈
        し、各種値の最終的な消去処理を実行します。この関数は、接続先の読み込みとエラーハンドリングを効果的に処理し、アプリケーションの安定性を保証します。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Selected_AccessName (str, optional):
                読み込む接続先の名前。デフォルトは None。全ての接続先名の接続先データを適切な属性に読み込む場合、デフォルト値。
            CallNum (int, optional): 呼び出しの種類を指定する整数値（1 または 2）。デフォルトは None。接続先名を指定しない場合、デフォルト値。
            TabNum (int, optional): タブの番号を指定する整数値。デフォルトは None。接続先名を指定しない場合、及び "CallNum = 1" の場合、デフォルト値。

        Returns:
            なし。
        """
        self.LogManager.InsertLOG("接続先：読み込み開始", self.App.一般)
        try:  # エラーを検出するブロック
            if Selected_AccessName is None:  # Selected_AccessName が None（デフォルト値）の場合、接続先データの読み込み
                """
このブロックは、接続先データのキャッシュファイルから接続先データを読み込み、AppClass（self.App）属性の対応する属性に読み込んだ接続先データを保存するためのもの
です。この関数でこのブロックが実行される場合、このブロック以外の処理は行われません（エラーハンドリングは機能します）。アプリケーションの他の部分で接続先データを
読み込む際は、"self.LoadAccess()" を実行します。このとき、引数は必要ありません。ただし、この関数は必ずメインスレッドで動作する関数から呼び出される必要が
あります。これは、この関数内で GUI 操作を伴う処理を行っているためです。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """
                with open(ACCESS_CACHE, "r") as File:  # 接続先データのキャッシュファイルを読み込みモードで展開
                    AccessData = json.load(File)  # 接続先データを読み込み
                """
この with ステートメントを実行する前に、メソッド open() に渡すファイルパス、この場合は ACCESS_CACHE が実際に存在しているかを確認するための条件式、
「if os.path.exists(ACCESS_CACHE):」を設けることが通例ですが、ここではこれを行いません。これは、この関数では ACCESS_CACHE が存在しない場合の
FileNotFoundError が発生した場合の対策、つまり新しい「接続先データのキャッシュファイル」を作成する処理を、except ブロックで行っているためです。仮にここに
ACCESS_CACHE が実際に存在しているかを確認するための条件式を置いた場合、新しいキャッシュファイルの作成が行われず、アプリケーションは正しく起動しなくなります。
                """

                # AppClass（self.App）属性の AccessData 属性と AccessNames 属性に読み込んだ接続先データを設定
                setattr(self.App, "AccessData", AccessData)  # データが空の辞書の場合（ユーザーが削除した）でも、そのまま設定
                AccessNames = list(self.App.AccessData.keys())  # データが空の辞書の場合（ユーザーが削除した）でも、空のリストを取得
                setattr(self.App, "AccessNames", AccessNames)  # リストが空でもそのまま設定

                if AccessData:  # 接続先データが存在する場合のログ記録
                    self.LogManager.InsertLOG("接続先：データ読み込み完了", self.App.一般)
                    self.LogManager.InsertLOG("接続先：リスト読み込み完了", self.App.一般)
                else:  # 接続先データが存在しない場合のログ記録
                    self.LogManager.InsertLOG("接続先：データがありません", self.App.一般)
            # 接続先の読み込み（データが空の辞書の場合（ユーザーが削除した）、Selected_AccessName として空文字列（str）が渡される）
            elif Selected_AccessName in self.App.AccessData:  # データが空の辞書の場合（ユーザーが削除した）、空文字列（str）で評価（False）
                """
このブロックは、この関数によって既に読み込まれた接続先データから Selected_AccessName に対応するデータを抽出し、GUI ウィジェットまたは待機辞書に設定または保存
するためのものです。この関数でこのブロックが実行される場合、このブロック以外の処理は行われません（エラーハンドリングは機能します）。抽出された接続先データは、
CallNum が 1 の場合に GUI ウィジェットに設定され、2 の場合に待機辞書に保存されます。CallNum を 2 で呼び出す場合、適切な TabNum を指定する必要があります。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """
                Details = self.App.AccessData[Selected_AccessName]  # Selected_AccessName に対応する接続先データを取得

                if CallNum == self.App.EditAccess:  # EditAccess_Pull のための呼び出し
                    """
このブロックは、アプリケーションのメインフレーム「接続先編集」タブの編集メニュー「接続先選択」プルダウンの選択項目が変更された場合（ユーザーが選択項目を変更したか、
編集メニューの削除ボタンなどの操作によって選択項目をプログラム的に変更した場合）に、選択された接続先名に基づいてその接続先の接続先データを GUI ウィジェットに反映
するためのものです。この関数でこのブロックが実行される場合、このブロック以外の処理は行われません（エラーハンドリングは機能します）。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                    """
                    Widget = self.App.ConnectionEntries["接続先名"]  # AppClass（self.App）属性から "接続先名" に対応するウィジェットの参照を取得
                    self.SetWidgetVal(Widget = Widget, Value = Selected_AccessName)  # ウィジェットに Selected_AccessName を設定

                    # 接続先データの読み込み及びウィジェットへの値の設定を行うためのイテレーション
                    # （[1:] は二番目の項目からイテレーションを開始するためのスライス（一番目は先に処理した接続先名））
                    for PresetIndex, InternalName, DisplayName, DataAddress in self.App.Connections[1:]:
                        if any(Check in DisplayName for Check in {"データパスをテスト",}):  # "データパスをテスト" ボタンをスキップするための条件式
                            continue  # 次のイテレーションを行う指示

                        if not any(Check in DisplayName for Check in {"JSON サンプル：",}):  # 通常の接続先データを取得するための条件式
                            Value = GetDataVal(Data = Details, DataPath = DataAddress)  # Details から DataAddress に従って Value を取得
                        else:  # JSON サンプルデータ（通常の接続先データ以外）を取得するためのブロック
                            EndpointName = InternalName.replace("_sample", "")  # InternalName の接尾辞を除去して EndpointName を取得
                            Value = Details["endpoints"][EndpointName]["sample"]  # Details から JSON サンプルデータを取得
                            Value = json.dumps(Value, sort_keys = False, indent = 2)  # JSON サンプルデータを整形
                            """
関数 json.dumps() の dumps の末尾の "s" は、string（文字列）のイニシャルです。これを付けない関数 json.dump() は、データをファイルに書き込む際に使用します。
                            """

                        # InternalName に対応するウィジェットに取得値を設定
                        # AppClass（self.App）属性から InternalName に対応するウィジェットの参照を取得
                        Widget = self.App.ConnectionEntries[InternalName]
                        self.SetWidgetVal(Widget = Widget, Value = Value)  # ウィジェットに Value を設定

                    # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
                    self.LogManager.InsertProcessedLOG(self.App.一般)
                elif CallNum == self.App.Exchange and TabNum is not None:  # Exchange_Pull のための呼び出し
                    """
このブロックは、アプリケーションのメインフレーム「設定」タブの「接続先選択」プルダウン（各接続先タブ）の選択項目が変更された場合（ユーザーが選択項目を変更したか、
メインフレーム「接続先編集」タブの編集メニューのボタン操作によって選択項目をプログラム的に変更した場合）に、選択された接続先名に基づいてその接続先の接続先データを
待機辞書（AppClass（self.App）属性の ConnectionsStandby 属性）に反映するためのものです。待機辞書とは、メインフレーム「設定」タブから Engine をスタートする
際に Engine 用の辞書としてコピーされる、実際の API 通信に使用する接続先データを保持する辞書のことを指します。この関数でこのブロックが実行される場合、この
ブロック以外の処理は行われません（エラーハンドリングは機能します）。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                    """
                    StandbyDict_attr = "ConnectionsStandby_{0}".format(str(TabNum))  # TabNum に対応する属性名を設定
                    """ "attr" は attribute（属性）の略を指し、プログラミングの文脈において一般的に使われます。 """
                    # AppClass（self.App）属性の ConnectionsStandby 属性（辞書）に接続先名として Selected_AccessName を保存
                    getattr(self.App, StandbyDict_attr, None)["接続先名"] = Selected_AccessName

                    # 接続先データの読み込み及び ConnectionsStandby 属性（辞書）への値の設定を行うためのイテレーション
                    # （[1:] は二番目の項目からイテレーションを開始するためのスライス（一番目は先に処理した接続先名））
                    for PresetIndex, InternalName, DisplayName, DataAddress in self.App.Connections[1:]:
                        # JSON サンプルまたは "データパスをテスト" ボタンをスキップするための条件式
                        if any(Check in DisplayName for Check in {"JSON サンプル：", "データパスをテスト",}):
                            continue  # 次のイテレーションを行う指示

                        Value = GetDataVal(Data = Details, DataPath = DataAddress)  # Details から DataAddress に従って Value を取得
                        # AppClass（self.App）属性の ConnectionsStandby 属性（辞書）に InternalName をキーとして Value を保存
                        getattr(self.App, StandbyDict_attr, None)[InternalName] = Value

                self.LogManager.InsertLOG("接続先：読み込み完了", self.App.一般)
            # データが空の辞書の場合（ユーザーが削除した）、GUI ウィジェットの各種値をクリア（EditAccess_Pull のための呼び出し）
            elif Selected_AccessName == "" and len(self.App.AccessNames) == 0 and CallNum == self.App.EditAccess:
                """
このブロックは、アプリケーションのメインフレーム「接続先編集」タブの編集メニュー「この接続先を削除」ボタンによって接続先データから全ての接続先（接続先名）が削除
された場合に、GUI ウィジェットに残っている「データ上は既に削除された、過去に入力された値」をクリアするためのものです。このブロックの条件式の
len(self.App.AccessNames) == 0 の部分で「データが空の辞書かどうか」を評価していますが、self.App.AccessNames 自体は辞書ではなく、接続先名のリストです。
しかし、このリストに対する変更は接続先データの辞書に対する変更と連動しており、辞書から接続先（接続先名）が削除されれば、同様にリストからも削除されます。従って、
このリストの範囲長（要素数）が 0 の場合、接続先データの辞書が空であることを意味し、条件式は目的の状況を特定することができます。この関数でこのブロックが実行される
場合、このブロック以外の処理は行われません（エラーハンドリングは機能します）。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """
                # GUI ウィジェットの値をクリアするためのイテレーション
                for PresetIndex, InternalName, DisplayName, DataAddress in self.App.Connections:
                    if any(Check in DisplayName for Check in {"データパスをテスト",}):  # "データパスをテスト" ボタンをスキップするための条件式
                        continue  # 次のイテレーションを行う指示

                    # AppClass（self.App）属性の InternalName に対応する GUI ウィジェットに空文字列（""、str）を設定（クリア）
                    self.SetWidgetVal(Widget = self.App.ConnectionEntries[InternalName], Value = "")

                # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
                self.LogManager.InsertProcessedLOG(self.App.一般)
            # データが空の辞書の場合（ユーザーが削除した）、ConnectionsStandby 属性（辞書）をクリア（Exchange_Pull のための呼び出し）
            elif Selected_AccessName == "" and len(self.App.AccessNames) == 0 and CallNum == self.App.Exchange:
                """
このブロックは、CallNum 以外は直前の条件式と評価する条件が同じであり、これはこのブロックが実行される条件が直前の条件式と同じであることを意味します。それにも
関わらずあえて明示的に CallNum に基づいてブロックを分けているのには、この関数には CallNum が 1 の場合（EditAccess_Pull のための呼び出し）と 2 の場合
（Exchange_Pull のための呼び出し）を区別して取り扱う責務があり、CallNum 以外の条件が同じだからと勝手に両方を一度に操作する権限を与えられていないためです。この
ように、関数内で一貫して CallNum に基づいて処理を分けることは関数の利用目的を明確にし、呼び出し元で必要に応じて必要な処理だけを行うことを可能にし、関数の再利用性
を高めることに寄与します。この関数でこのブロックが実行される場合、このブロック以外の処理は行われません（エラーハンドリングは機能します）。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """
                # TabNum に対応する属性名を設定及び AppClass（self.App）属性の対応する属性に空の辞書（{}）を設定（クリア）
                setattr(self.App, "ConnectionsStandby_{0}".format(str(TabNum)), {})
        except FileNotFoundError:  # FileNotFoundError が発生した場合
            self.LogManager.InsertLOG("接続先：キャッシュファイルなし", self.App.一般)
            self.LogManager.InsertLOG("接続先：キャッシュファイル作成開始", self.App.一般)
            try:  # エラーを検出するブロック
                # 接続先データのキャッシュファイルを新規作成
                with open(ACCESS_CACHE, "w") as File:  # 接続先データのキャッシュファイルを書き込みモードで展開
                    # AppClass（self.App）属性のデフォルトの接続先データ DefConnections 属性を JSON データとして書き込み
                    json.dump(self.App.DefConnections, File, indent = 4)

                self.LogManager.InsertLOG("接続先：キャッシュファイル作成完了", self.App.一般)
            except Exception as e:  # 何らかのエラーが発生した場合、ログにエラーを記録
                self.LogManager.InsertLOG("接続先：キャッシュファイル作成失敗「{0}」".format(str(e)), self.App.一般)
                return  # 処理の終了

            self.LoadAccess()  # 再帰呼び出しによって接続先データのキャッシュファイルの読み込みを再試行

            # 接続先データのキャッシュファイルを読み込み後、元の呼び出し時に引数が渡されていた場合、引数を使用して元の処理を再試行
            if Selected_AccessName is not None or CallNum is not None or TabNum is not None:
                """
この関数では、接続先データのキャッシュファイルを直接取り扱うのは呼び出し時に引数として何も渡されていない場合のみであり、その場合にしか FileNotFoundError が発生
することはありません。しかし、将来の拡張を容易にするため、エラーハンドリング部分では現状必要ない想定も行います。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """
                self.LoadAccess(Selected_AccessName, CallNum, TabNum)

            return  # 処理の終了
        except json.JSONDecodeError:  # JSONDecodeError が発生した場合
            # JSON 形式エラーの処理とファイル再作成の確認
            QMessageBox.critical(self.App, "エラー", "接続先データのファイル形式が正しくありません。")  # ダイアログを表示
            Reply = QMessageBox.question(self.App,  # 選択肢を示すダイアログを表示
                "ファイル再作成", "ファイルを消去して新しいファイルを作成しますか？", QMessageBox.Yes | QMessageBox.No)
            if Reply == QMessageBox.Yes:  # ユーザーがファイル再作成を選択した場合
                try:  # エラーを検出するブロック
                    os.remove(ACCESS_CACHE)  # 既存の接続先データのキャッシュファイルを消去
                    self.LogManager.InsertLOG("接続先：キャッシュファイル消去完了", self.App.一般)
                    # 再帰呼び出しによって FileNotFoundError ブロックを実行し、接続先データのキャッシュファイルを新規作成及び読み込みを再試行
                    """
この関数では、接続先データのキャッシュファイルを直接取り扱うのは呼び出し時に引数として何も渡されていない場合のみであり、その場合にしか JSONDecodeError が発生
することはありません。しかし、将来の拡張を容易にするため、エラーハンドリング部分では現状必要ない想定も行います。従って、例え引数がデフォルト値であっても、この再帰
呼び出し部分では明示的にその引数を渡し、FileNotFoundError ブロックのエラーハンドリングが全て完全に機能するようにします。これは、FileNotFoundError ブロック
で、元の呼び出し時に引数が渡されていたかどうかをチェックする部分を再利用することを意味します。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                    """
                    self.LoadAccess(Selected_AccessName, CallNum, TabNum)
                    return  # 処理の終了
                except Exception as e:  # 何らかのエラーが発生した場合、ログにエラーを記録
                    self.LogManager.InsertLOG("接続先：キャッシュファイル消去失敗「{0}」".format(str(e)), self.App.一般)
                    return  # 処理の終了
        except Exception as e:  # 何らかのエラーが発生した場合、ログにエラーを記録
            self.LogManager.InsertLOG("接続先：読み込み失敗「{0}」".format(str(e)), self.App.一般)

    # キャッシュファイルから API キー及び API シークレットを読み込む関数
    def LoadAPIkeys(self, TabNum):
        """ この部分を「関数の docstring」と言います。
        キャッシュファイルから API キー及び API シークレットを読み込む関数。

        この関数は、メインフレーム「設定」タブの「接続先」タブを識別するための引数 TabNum に対応する､「接続先選択」プルダウンで選択中の接続先の API キー及び
        API シークレットをキャッシュファイルから読み込みます。キャッシュファイルが存在する場合、API キー及び API シークレットを暗号化された状態のまま読み込み、
        self.App の対応する属性に bytes 型として保存します。読み込みに失敗した場合、エラーをシステムログに記録し、処理を終了します。読み込んだ各種キー情報に
        基づき、キャッシュファイルが有効な状態かどうかを示すフラグも更新します。キャッシュファイルが存在しない場合、API キー及び API シークレットの読み込みは
        行わず、TabNum に対応するフラグを無効の状態に設定します。この状況「キャッシュファイルが存在しない」場合も、システムログにその旨を記録します。これにより、
        ユーザーはキャッシュファイルの不在が原因で API の各種キーが利用できないことを把握できます。
        処理の各過程に対応するログは LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            TabNum (int): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。ユーザーが現在操作しているタブを指す。

        Returns:
            なし。
        """
        self.LogManager.InsertLOG("API キー：キャッシュファイル読み込み開始", self.App.一般)
        # 変数を初期化
        Error = False  # キャッシュファイルの読み込み時にエラーが発生した場合に有効にするフラグ変数

        # TabNum に対応する属性名の設定と対応する AppClass（self.App）属性の取得
        # ConnectionsStandby 属性から待機辞書の参照を取得
        StandbyDict = getattr(self.App, "ConnectionsStandby_{0}".format(str(TabNum)), None)
        CacheIsEnabled_ofAPI_attr = "CacheIsEnabled_ofAPI_{0}".format(str(TabNum))  # API のキャッシュが有効な状態かどうかを示すフラグの属性名
        """
"attr" は attribute（属性）の略を指し、プログラミングの文脈において一般的に使われます。待機辞書とは、メインフレーム「設定」タブから Engine をスタートする際に
Engine 用の辞書としてコピーされる、実際の API 通信に使用する接続先データを保持する辞書のことを指します。
        """

        # キャッシュファイルの読み込みをエラーハンドリング関数で実行
        Cache = self.ErrorHandler_ofOpenCacheIncludeRetry("API キー", API_KEYS_CACHE, "r")
        if isinstance(Cache, list):  # キャッシュファイルの読み込みが正常に完了した場合
            Cache = Cache[0]  # リスト形式で返されたデータから読み込まれたデータを取得
        elif Cache is None:  # キャッシュファイルが存在しないことを示す None が返された場合
            return  # 処理を終了
        elif isinstance(Cache, bool):  # キャッシュファイルの読み込み時にエラーが発生した場合
            Error = True  # キャッシュファイルの読み込み時にエラーが発生した場合に有効にするフラグを有効化
        """
ここでは、関数 self.ErrorHandler_ofOpenCacheIncludeRetry() が返す可能性のある bool 値（ファイル消去処理を行った結果を示す）の内容に関わらず、結果が
bool 値の場合はキャッシュファイルの読み込み時にエラーが発生した場合に有効にするフラグを有効にしています。これは、ファイル消去処理を行わなければならない状況では、
消去が成功しても失敗しても、この関数の責務である「API キー及び API シークレットの読み込み」を行う後続の通常の処理を行えないためです。
        """

        if not Error:  # キャッシュの読み込み時にエラーが発生していない場合
            # 待機辞書の接続先名に応じた API キー及び API シークレットの取り出し（キーが保存されていない場合、空文字列（str））
            APIkey_EncryptedStr = Cache.get(StandbyDict["接続先名"], {}).get("APIkey", "")
            APIsecret_EncryptedStr = Cache.get(StandbyDict["接続先名"], {}).get("APIsecret", "")
            # 取り出した API キー及び API シークレットを Base64 形式から元のバイナリ形式（bytes）にデコード（空文字列（str）の場合、bytes 型の空文字列）
            APIkey_EncryptedBytes = base64.b64decode(APIkey_EncryptedStr) if not APIkey_EncryptedStr == "" else b""
            APIsecret_EncryptedBytes = base64.b64decode(APIsecret_EncryptedStr) if not APIsecret_EncryptedStr == "" else b""
            """
Base64 形式のデータの取り扱い方は少し難解なため、以下に Q&A 形式で解説します。この解説は、この文脈での関数 base64.b64decode() に焦点を当てたものです。

Q1: 関数 base64.b64decode() はどのようなデータを受け入れることができますか？
A1: この関数は、bytes 型または bytes 型に変換可能な文字列型（str）を引数として受け取ります。

Q2: 文字列型（str）を渡す場合、その文字列はどのように扱われますか？
A2: 文字列型（str）が渡された場合、この関数は内部でそれを bytes 型に変換してからデコードを行います。この関数は UTF-8 または ASCII 文字列をサポートしており、
文字列型（str）の変換には通常、UTF-8 エンコーディングが使用されます。ただし実際には Base64 形式のデータは ASCII 文字セットに準拠しているため、どちらの
エンコーディングが使用されていても問題はありません。

Q3: 関数 encode("utf-8") を使う必要はありますか？
A3: このコードの文脈では base64.b64encode().decode("utf-8") で「元のデータを Base64 形式に変換後、文字列型（str）に変換した JSON 形式のデータ」を
読み込んでいます。JSON 形式は文字列型（str）であり、これはそのまま関数 base64.b64decode() に渡すことができます。

Q4: この関数の返り値はどのような形式ですか？
A4: この関数はデコードされたバイナリ形式（bytes）のデータを返します。これは元のデータの形式です（base64.b64encode().decode("utf-8") する前の形式）。

---------------------------------------------------------------------------------------------------------------------------------------

このアプリケーションでは、API キー及び API シークレットは必要な場合（キーを表示する場合や、HTTP ライブラリが bytes 型以外の型を要求する場合）を除いて、常に
bytes 型で保持します。また、これは暗号化された状態のものであり、キーを表示する場合と Engine で使用する場合以外では復号化されることはありません。これは、これら
敏感情報の漏洩リスクを最小限にするためのセキュリティ措置です。Engine でこれら敏感情報を使用する場合、Engine は数秒間隔という高い頻度でこれらを使用しますが、この
アプリケーションではその都度復号化を行い、ここでも漏洩リスクを最小限にする措置を取ります。この、都度復号化を行う措置は CPU の負荷を増大させるリスクを伴いますが、
セキュリティ上の懸念を払拭するためには欠かすことのできない措置です。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

            # API キー及び API シークレットを TabNum に対応する属性名の AppClass（self.App）属性に保存
            setattr(self.App, "APIkey_EncryptedBytes_{0}".format(str(TabNum)), APIkey_EncryptedBytes)
            setattr(self.App, "APIsecret_EncryptedBytes_{0}".format(str(TabNum)), APIsecret_EncryptedBytes)

            # 取り出した値が bytes 型の空文字列でなく、有効な値の場合
            if not APIkey_EncryptedBytes == b"" and not APIsecret_EncryptedBytes == b"":
                setattr(self.App, CacheIsEnabled_ofAPI_attr, True)  # API のキャッシュが有効な状態かどうかを示すフラグを有効化
                self.LogManager.InsertLOG("{0} API キーキャッシュ：{1}".format(str(StandbyDict["接続先名"]), str(True)), self.App.一般)
            else:  # 取り出した値が bytes 型の空文字列で、無効な値の場合
                setattr(self.App, CacheIsEnabled_ofAPI_attr, False)  # API のキャッシュが有効な状態かどうかを示すフラグを無効化
                self.LogManager.InsertLOG("{0} API キーキャッシュ：{1}".format(str(StandbyDict["接続先名"]), str(False)), self.App.一般)

            self.CreateLabels_ofAPIkeys(TabNum)  # API キー及び API シークレットのラベル（QLabel）を更新
            self.LogManager.InsertLOG("API キー：キャッシュファイル読み込み完了", self.App.一般)
        else:  # キャッシュの読み込み時にエラーが発生した場合
            self.LogManager.InsertLOG("API キー：キャッシュファイル読み込み失敗", self.App.一般)

    # 既存の暗号化キーの読み込み、または存在しない場合に新しいキーを作成する関数
    def CreateOrLoadEncryptionKey(self):
        """ この部分を「関数の docstring」と言います。
        既存の暗号化キーの読み込み、または存在しない場合に新しいキーを作成する関数。

        この関数は、暗号化キーと CBC モードの初期化ベクトルが既に存在する場合、それらをファイルから読み込み、暗号化キーの属性（self.App.EncryptionKey）と
        CBC モードの初期化ベクトルの属性（self.App.IV_ofEncryption）に設定します。存在しない場合は、新たにこれらを作成してファイルに保存し、同属性に設定
        します。いずれの処理もシステムログに記録します。例外が発生した場合、エラーをシステムログに記録し、None を同属性に設定します。これは同属性の初期化時の値
        と同じです。この関数は処理後の結果確認処理も含んでおり、処理に成功した場合は True を、失敗した場合は False を返します。失敗した場合はその旨のログを
        システムログに記録する処理も同時に行います。この関数の呼び出し元では、この値を利用することで処理の失敗時に速やかに処理を中断することができます。
        処理の各過程に対応するログは LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            bool: 処理に成功した場合、True。そうでなければ False。
        """
        Error = False  # 暗号化キーの読み込みに失敗したことを示すフラグ変数を初期化
        if self.App.EncryptionKey is None:  # 暗号化キーが読み込まれていない場合
            try:  # エラーを検出するブロック
                self.LogManager.InsertLOG("暗号化キー作成または読み込み開始", self.App.一般)
                if os.path.exists(ENCRYPTION_KEY):  # 暗号化キーのキャッシュファイルが存在する場合、その内容を読み込み
                    with open(ENCRYPTION_KEY, "rb") as File:  # 暗号化キーのキャッシュファイルをバイナリ読み込みモード = bytes 型で展開
                        Key = File.read(32)  # 暗号化キーの読み込み（最初の 32 バイト、256 ビットキー）
                        IV = File.read(16)  # CBC モードの初期化ベクトルの読み込み（次の 16 バイト、128 ビット IV）

                    self.App.EncryptionKey = Key  # 暗号化キー専用の属性に暗号化キーを保存
                    self.App.IV_ofEncryption = IV  # CBC モードの初期化ベクトル専用の属性に CBC モードの初期化ベクトルを保存
                    self.LogManager.InsertLOG("暗号化キー読み込み完了", self.App.一般)
                else:  # 暗号化キーのキャッシュファイルが存在しない場合、暗号化キーを作成及び保存
                    Key = os.urandom(32)  # ランダムなキーを作成（256 ビットキー、暗号化キー）
                    IV = os.urandom(16)   # ランダムなキーを作成（128 ビット IV、CBC モードの初期化ベクトル）
                    with open(ENCRYPTION_KEY, "wb") as File:  # 暗号化キーのキャッシュファイルをバイナリ書き込みモード = bytes 型で作成
                        File.write(Key)  # 暗号化キーを保存（256 ビットキー）
                        File.write(IV)  # CBC モードの初期化ベクトルを保存（128 ビット IV）

                    self.App.EncryptionKey = Key  # 暗号化キー専用の属性に暗号化キーを保存
                    self.App.IV_ofEncryption = IV  # CBC モードの初期化ベクトル専用の属性に CBC モードの初期化ベクトルを保存
                    self.LogManager.InsertLOG("暗号化キー作成完了", self.App.一般)
            except (IOError, OSError) as e:  # IOError または OSError が発生した場合、ファイル再作成処理のファイル消去処理シークエンスを開始
                # ファイル再作成処理のファイル消去処理が成功した場合
                if self.ErrorHandler_ofRemoveCacheFileOfRecreate(self.App.主, "暗号化キー", ENCRYPTION_KEY, e):
                    if self.CreateOrLoadEncryptionKey():  # 自身を再帰的に呼び出して新しい暗号化キーを作成及び保存
                        # 暗号化キーの再作成に伴い復号化できなくなった全ての API キー及び API シークレットをファイルシステム及び属性から消去
                        self.LogManager.InsertLOG("暗号化キーの消去に伴い復号化できなくなったデータを消去", self.App.一般)
                        # ファイル再作成処理のファイル消去処理が成功した場合
                        if self.ErrorHandler_ofRemoveCacheFileOfRecreate(self.App.副, "API キー", API_KEYS_CACHE):
                            # メインフレーム「設定」タブの各「接続先」タブのためのイテレーション
                            for TabNum in range(1, self.App.Settings_TabCount + 1):
                                setattr(self.App, "APIkey_EncryptedBytes_{0}".format(str(TabNum)), b"")  # 読み込み済みの API キーを初期化
                                # 読み込み済みの API シークレットを初期化
                                setattr(self.App, "APIsecret_EncryptedBytes_{0}".format(str(TabNum)), b"")
                            pass  # この関数では具体的な各種 API キーのファイル再作成処理は行わない
                            Error = True  # 暗号化キーの読み込みに失敗したことを示すフラグを有効化
                        else:  # ファイル再作成処理のファイル消去処理が失敗した場合
                            self.LogManager.InsertLOG("暗号化キーの消去に伴い復号化できなくなったデータの消去失敗", self.App.一般)
                            QMessageBox.critical(self.App, "エラー", ("暗号化キーの消去に伴い復号化できなくなったデータを含むファイルの消去に失敗"
                                "しました。手動での消去を試みてください。{0}ファイルパス：{1}".format(
                                    self.LF, str(API_KEYS_CACHE))))  # ダイアログを表示
                else:  # ファイル再作成処理のファイル消去処理が失敗した場合
                    Error = True  # 暗号化キーの読み込みに失敗したことを示すフラグを有効化
            except Exception as e:  # 何らかのエラーが発生した場合
                self.LogManager.InsertLOG("暗号化キー：予期しないエラー「{0}」".format(str(e)), self.App.一般)
                QMessageBox.critical(self.App, "予期しないエラー", ("暗号化キーのキャッシュファイル操作中に予期しないエラーが発生しました。"
                    "エラー内容「{0}」".format(str(e))))  # ダイアログを表示
                self.App.EncryptionKey = None  # 暗号化キー専用の属性に None を設定（アプリケーション初期化時の値）
                self.App.IV_ofEncryption = None  # CBC モードの初期化ベクトル専用の属性に None を設定（アプリケーション初期化時の値）

        if self.App.EncryptionKey is not None and self.App.IV_ofEncryption is not None:  # 暗号化キー等が初期値でない場合（処理成功）
            return True  # 処理を終了して True を返す（処理に成功したことを示す）
        # 暗号化キー等が初期値の場合（処理失敗）または暗号化キーの読み込みに失敗したことを示すフラグが有効な場合
        elif self.App.EncryptionKey is None or Error:
            self.LogManager.InsertLOG("暗号化キー利用不可。内部エラーのため、開発者に連絡してください。", self.App.一般)
            return False  # 処理を終了して False を返す（処理に失敗したことを示す）
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # API キー及び API シークレットのラベルを作成する関数
    def CreateLabels_ofAPIkeys(self, TabNum):
        """ この部分を「関数の docstring」と言います。
        API キー及び API シークレットのラベルを作成する関数。

        この関数は、メインフレーム「設定」タブの「接続先」タブを識別するための引数 TabNum に基づいて、API キー及び API シークレットのラベルを更新します。
        ラベルのテキストは、キャッシュの有効性、各種キーの表示設定、及び暗号化キーの有効性に基づいて設定します。キャッシュが無効である場合、または各種キーの表示
        が無効である場合、ラベルをそれぞれ「なし」または「*******」と設定します。各種キーの表示が有効であり、かつ暗号化キーが有効な場合、暗号化された API キー
        及び API シークレットを復号化し、ラベルに設定します。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            TabNum (int): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。ユーザーが現在操作しているタブを指す。

        Returns:
            なし。
        """
        self.LogManager.InsertLOG("各種キー表示更新開始", self.App.一般)
        # TabNum に対応する属性名の設定と対応する AppClass（self.App）属性の取得
        # API のキャッシュが有効な状態かどうかを示すフラグ属性から値を取得
        CacheIsEnabled_ofAPI = getattr(self.App, "CacheIsEnabled_ofAPI_{0}".format(str(TabNum)), None)
        # 「キーを表示／伏せる」ボタンを切り替えるためのフラグ属性から値を取得
        ShowKeys = getattr(self.App, "ShowKeys_{0}".format(str(TabNum)), None)
        # API キーのラベル（QLabel）と API シークレットのラベル（QLabel）の各属性から参照を取得
        APIkey_Label = getattr(self.App, "APIkey_Label_{0}".format(str(TabNum)), None)
        APIsecret_Label = getattr(self.App, "APIsecret_Label_{0}".format(str(TabNum)), None)

        # API キーのラベル（QLabel）と API シークレットのラベル（QLabel）を設定
        if not CacheIsEnabled_ofAPI:  # 接続先名に対応するキャッシュが存在しない場合
            self.SetWidgetVal(Widget = APIkey_Label, Value = "API Key: なし")
            self.SetWidgetVal(Widget = APIsecret_Label, Value = "API Secret: なし")
        elif not ShowKeys:  # 接続先名に対応するキャッシュが存在し、ShowKeys フラグが無効な場合
            self.SetWidgetVal(Widget = APIkey_Label, Value = "API Key: ********")
            self.SetWidgetVal(Widget = APIsecret_Label, Value = "API Secret: ********")
        else:  # 接続先名に対応するキャッシュが存在し、ShowKeys フラグが有効（キーを表示）な場合
            """
先の条件「if not CacheIsEnabled_ofAPI:」に該当しない場合、キャッシュが存在することを意味し､「elif not ShowKeys:」に該当しない場合、ShowKeys フラグが
有効（キーを表示）であることを意味するため、このブロックで追加の条件確認を行う必要はありません。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """
            if self.App.EncryptionKey is not None:  # 暗号化キーが存在することを確認
                """ 暗号化キーは ShowKeys フラグを有効にする「キーを表示／伏せる」ボタンの関数 self.ShowKeysBtn() によって読み込まれます。 """
                # TabNum に対応する属性名を設定及び AppClass（self.App）属性の対応する属性から暗号化された API キー及び API シークレットを取得
                APIkey_EncryptedBytes = getattr(self.App, "APIkey_EncryptedBytes_{0}".format(str(TabNum)), None)
                APIsecret_EncryptedBytes = getattr(self.App, "APIsecret_EncryptedBytes_{0}".format(str(TabNum)), None)
                try:  # エラーを検出するブロック
                    # 暗号化された API キー及び API シークレットを復号化及び bytes 型から str 型にデコード
                    APIkey_DecryptedStr = ErrorHandler_ofEncryptOrDecrypt(self.LogManager, self.App, APIkey_EncryptedBytes,
                        "API キー", Decrypt = True, ReturnStr = True)
                    APIsecret_DecryptedStr = ErrorHandler_ofEncryptOrDecrypt(self.LogManager, self.App, APIsecret_EncryptedBytes,
                        "API シークレット", Decrypt = True, ReturnStr = True)
                    if not APIkey_DecryptedStr or not APIsecret_DecryptedStr:  # キーのどちらかが復号化に失敗している場合、その旨を表示
                        APIkey_DecryptedStr = APIsecret_DecryptedStr = "復号化失敗"

                    # API キーのラベル（QLabel）と API シークレットのラベル（QLabel）に復号化した str 型の API キー及び API シークレットを設定（表示）
                    self.SetWidgetVal(Widget = APIkey_Label, Value = "API Key: {0}".format(str(APIkey_DecryptedStr)))
                    self.SetWidgetVal(Widget = APIsecret_Label, Value = "API Secret: {0}".format(str(APIsecret_DecryptedStr)))
                finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                    APIkey_DecryptedStr = None  # 使用完了した復号化データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    APIsecret_DecryptedStr = None  # 使用完了した復号化データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる

        # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
        self.LogManager.InsertProcessedLOG(self.App.一般)
        self.LogManager.InsertLOG("各種キー表示更新完了", self.App.一般)

    # 暗号化キーをファイルシステムから消去する関数
    def DeleteEncryptionKey(self):
        """ この部分を「関数の docstring」と言います。
        暗号化キーをファイルシステムから消去する関数。

        この関数は、指定されたファイルパスにある暗号化キーのキャッシュファイルを検索し、存在する場合はそれを消去します。暗号化キーのキャッシュファイルが存在
        しない場合、システムログにその旨を記録します。また、処理中に何らかの例外が発生した場合、エラーをシステムログに記録します。
        処理の各過程に対応するログは LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        try:  # エラーを検出するブロック
            self.LogManager.InsertLOG("暗号化キーの消去開始", self.App.一般)
            if os.path.exists(ENCRYPTION_KEY):  # 暗号化キーのキャッシュファイルが存在する場合、その内容を読み込み
                os.remove(ENCRYPTION_KEY)  # 暗号化キーのキャッシュファイルを消去
                self.App.EncryptionKey = None  # AppClass（self.App）属性の暗号化キーを消去（初期化）
                self.App.IV_ofEncryption = None  # AppClass（self.App）属性の CBC モードの初期化ベクトルを消去（初期化）
                self.LogManager.InsertLOG("暗号化キーの消去完了", self.App.一般)
            else:  # 暗号化キーのキャッシュファイルが存在しない場合、その旨をログに記録
                self.LogManager.InsertLOG("暗号化キーのファイルが存在しません", self.App.一般)
        except Exception as e:  # 何らかのエラーが発生した場合、ログにエラーを記録
            self.LogManager.InsertLOG("暗号化キーの消去：処理失敗「{0}」".format(str(e)), self.App.一般)
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 渡された API キー及び API シークレットを暗号化し、キャッシュファイルに保存する関数
    def EncryptAndSaveKeys(self, TabNum, New_APIkey, New_APIsecret):
        """ この部分を「関数の docstring」と言います。
        渡された API キー及び API シークレットを暗号化し、キャッシュファイルに保存する関数。

        この関数は、引数として渡された API キー及び API シークレットを暗号化し、その結果を AppClass（self.App）属性に保存します。暗号化の成否に応じて、適切
        なシステムログを記録します。それぞれ暗号化に成功した場合、暗号化した各種キーをメインフレーム「設定」タブの「接続先」タブを識別するための引数 TabNum
        によって特定する「選択中の接続先名」をキーとする辞書として構造化した上でキャッシュファイルに保存します。
        処理の各過程に対応するログは LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            TabNum (int): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。ユーザーが現在操作しているタブを指す。
            New_APIkey (str): 新しい API キー。
            New_APIsecret (str): 新しい API シークレット。

        Returns:
            bool: キャッシュファイルへの書き込みに成功した場合、True。そうでなければ False。
        """
        Cache = {}  # 辞書を初期化

        # TabNum に対応する属性名を設定
        APIkey_EncryptedBytes_attr = "APIkey_EncryptedBytes_{0}".format(str(TabNum))  # 暗号化した bytes 型の API キーを保持する属性
        # 暗号化した bytes 型の API シークレットを保持する属性
        APIsecret_EncryptedBytes_attr = "APIsecret_EncryptedBytes_{0}".format(str(TabNum))
        """ "attr" は attribute（属性）の略を指し、プログラミングの文脈において一般的に使われます。 """

        try:  # エラーを検出するブロック
            # API キー及び API シークレットを暗号化（以降のコメントの処理は全て関数 ErrorHandler_ofEncryptOrDecrypt() が実行）
            # 及び暗号化した API キー及び API シークレットを AppClass（self.App）属性に保存
            """
この関数が呼び出されるのは、メインフレーム「設定」タブの「キーを登録／キーを変更」ボタンが押された場合です。bytes 型の API キー及び API シークレットは関数
self.LoadAPIkeys() でも読み込まれ、AppClass（self.App）属性の「暗号化された bytes 型の各種キーを保持する属性」に保存されますが、そちらはメインフレーム
「設定」タブの「接続先選択」プルダウンの選択項目が変更された場合に、新たに選択された接続先名に対応する各種キーを読み込んだ際に行われるものです。従って、
「接続先選択」プルダウンで選択中の接続先名の各種キーを新たに登録または変更した場合は、この関数で同属性に各種キーを保存する必要があります。これを行わなければ、各種
キーを保存後に「接続先選択」プルダウンで当該接続先名を再選択しない限り、保存された各種キーは同属性に保存されないことになります。従って、この関数で同属性に各種キー
を保存する処理は、良好なユーザーエクスペリエンスを確保するために必要なものです。
            """
            # 及び暗号化した API キー及び API シークレットを JSON 形式で保存するため Base64 エンコード及び bytes 型から str 型に変換
            """
AES 暗号化された直後の API キー及び API シークレットは、JSON 形式での保存に適していないバイナリ形式（bytes）となっています。このため、ここでは JSON 形式で
保存するために各種キーを Base64 エンコードし、文字列型（str）にしています。キャッシュファイルからこれらのキーを読み込む際には、Base64 形式の文字列を関数
base64.b64decode() に渡してデコードすることで、元の AES 暗号化された直後の状態、即ちバイナリ形式（bytes）に戻すことができます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """
            APIkey_EncryptedStr = ErrorHandler_ofEncryptOrDecrypt(self.LogManager, self.App, New_APIkey, "API キー",
                Encrypt = True, SaveAttr = APIkey_EncryptedBytes_attr, RequireBase64 = True, ReturnStr = True)
            APIsecret_EncryptedStr = ErrorHandler_ofEncryptOrDecrypt(self.LogManager, self.App, New_APIsecret, "API シークレット",
                Encrypt = True, SaveAttr = APIsecret_EncryptedBytes_attr, RequireBase64 = True, ReturnStr = True)
            if not APIkey_EncryptedStr or not APIsecret_EncryptedStr:  # キーのどちらかが暗号化に失敗している場合、処理を終了
                return False  # 処理を終了して False を返す
        finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
            New_APIkey = None  # 使用完了した平文データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            New_APIsecret = None  # 使用完了した平文データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる

        self.LogManager.InsertLOG("各種キーのファイル書き込み開始", self.App.一般)
        # キャッシュファイルの読み込みをエラーハンドリング関数で実行
        Result = self.ErrorHandler_ofOpenCacheIncludeRetry("各種キー", API_KEYS_CACHE, "r")
        if isinstance(Result, list):  # キャッシュファイルの読み込みが正常に完了した場合
            Cache = Result[0]  # リスト形式で返されたデータから読み込まれたデータを取得
        # キャッシュファイルの読み込み時にエラーが発生した場合、かつファイル消去処理が行われなかったかファイル消去処理に失敗している場合
        elif isinstance(Result, bool) and not Result:
            return False  # 処理を終了して False を返す
        """
ここでは、関数 self.ErrorHandler_ofOpenCacheIncludeRetry() が返す可能性のある None（キャッシュファイルが存在しないことを示す）と True（ファイル消去処理
が成功したことを示す）を条件式で明示的に取り扱っていません。これは、これらの値が返された場合、この関数は初期化済みのローカル変数 Cache を使用して引き続き「暗号化
した API キー及び API シークレットを保存」する処理を続行できるためです。
        """

        # TabNum に対応する属性名を設定及び AppClass（self.App）属性の対応する属性から接続先データの待機辞書の参照を取得
        StandbyDict = getattr(self.App, "ConnectionsStandby_{0}".format(str(TabNum)), None)

        # 暗号化した API キー及び API シークレットを待機辞書の接続先名をキーとする辞書として構造化し、各種キーを新規保存または上書き保存
        Cache[StandbyDict["接続先名"]] = {"APIkey": APIkey_EncryptedStr, "APIsecret": APIsecret_EncryptedStr,}
        """
この部分で、接続先名をキーとして API キー及び API シークレットをキャッシュデータに保存することで、複数の接続先名の各種キーを一つのキャッシュファイルで管理する
ことが可能になります。キャッシュデータに既に待機辞書の接続先名と同じ接続先名の各種キーが保存されている場合、ここで上書きし、新しいものに置き換えます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
        """

        # キャッシュファイルへの書き込みをエラーハンドリング関数で実行
        Result = self.ErrorHandler_ofOpenCacheIncludeRetry("各種キー", API_KEYS_CACHE, "w", WriteData = Cache)
        if Result == "書き込み完了":  # キャッシュファイルへの書き込みに成功した場合
            setattr(self.App, "CacheIsEnabled_ofAPI_{0}".format(str(TabNum)), True)  # API のキャッシュが有効な状態かどうかを示すフラグを有効化
            self.LogManager.InsertLOG("{0} API キーキャッシュ：{1}".format(str(StandbyDict["接続先名"]), str(True)), self.App.一般)
            self.LogManager.InsertLOG("各種キーのファイル書き込み完了", self.App.一般)
            return True  # キャッシュファイルへの書き込みに成功したことを示す値を返す
        elif isinstance(Result, bool):  # キャッシュファイルへの書き込みに失敗した場合、かつ再試行が行われなかったか再試行も失敗している場合
            return False  # キャッシュファイルへの書き込みに失敗したことを示す値を返す
        """
ここでは、関数 self.ErrorHandler_ofOpenCacheIncludeRetry() が返す可能性のある None（キャッシュファイルが存在しないことを示す）を条件式で明示的に取り
扱っていません。これは、キャッシュファイルへの書き込み時にはファイルが存在しているかに関わらず書き込み処理を行うためです。
        """

    # 選択中の接続先の API キー及び API シークレットを登録／変更する関数
    def ManageKeysBtn(self, CallNum, TabNum):
        """ この部分を「関数の docstring」と言います。
        選択中の接続先の API キー及び API シークレットを登録／変更する関数。

        この関数は、メインフレーム「設定」タブの「接続先」タブを識別するための引数 TabNum に対応する､「接続先選択」プルダウンで選択中の接続先の各種 API キーの
        登録／変更ボタンが押された時、またはボタンの状態を更新する必要がある時に呼び出されます。これらの呼び出し種別は引数 CallNum によって判断します（前者は
        1、後者は 2）。また、この関数はキャッシュデータの有無に応じて適切に各種 API キーの登録または変更処理、またはボタンの状態及びボタンテキストの更新処理を
        行います。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            CallNum (int): 当該ボタンが押されたのか、またはそのボタンの状態を変更するのかを識別する整数値（1 または 2）。
            TabNum (int): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。ユーザーが現在操作しているタブを指す。

        Returns:
            なし。
        """
        # TabNum に対応する属性名の設定と対応する AppClass（self.App）属性の取得
        # 接続先名に対応するキャッシュが存在することを示すフラグ属性の値を取得
        CacheIsEnabled_ofAPI = getattr(self.App, "CacheIsEnabled_ofAPI_{0}".format(str(TabNum)), None)
        # API キー及び API シークレットを登録／変更するボタンの参照を取得
        ManageKeysBtn = getattr(self.App, "ManageKeysBtn_{0}".format(str(TabNum)), None)

        if CallNum == self.App.主:  # ボタンが押された場合
            self.LogManager.InsertLOG("API キー登録／変更処理開始", self.App.一般)
            if not CacheIsEnabled_ofAPI:  # 接続先名に対応するキャッシュデータが存在しない場合
                # API キー及び API シークレットを登録または変更する関数をキーの登録モードで呼び出し
                self.RegisterOrChangeKeys(TabNum, Register = True)
                self.CreateLabels_ofAPIkeys(TabNum)  # API キー及び API シークレットのラベル（QLabel）を更新
                self.SetWidgetVal(Widget = ManageKeysBtn, Value = "キーを変更")  # "キーを登録" したのでボタンテキストを "キーを変更" に変更
                # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
                self.LogManager.InsertProcessedLOG(self.App.一般)
                # 他のボタンの状態を対応する状態に更新
                self.APIkeys_BtnResponder(CallNum = self.App.副, InternalName = "ShowKeysBtn", TabNum = TabNum)
                self.APIkeys_BtnResponder(CallNum = self.App.副, InternalName = "TestAccessBtn", TabNum = TabNum)
                self.APIkeys_BtnResponder(CallNum = self.App.副, InternalName = "ClearKeysBtn", TabNum = TabNum)
            else:  # 接続先名に対応するキャッシュデータが存在する場合
                # API キー及び API シークレットを登録または変更する関数をキーの変更モードで呼び出し
                self.RegisterOrChangeKeys(TabNum, Change = True)
                self.CreateLabels_ofAPIkeys(TabNum)  # API キー及び API シークレットのラベル（QLabel）を更新

            self.LogManager.InsertLOG("API キー登録／変更処理完了", self.App.一般)
        elif CallNum == self.App.副:  # ボタンの状態を変更する場合
            self.LogManager.InsertLOG("API キー登録／変更ボタン：状態更新開始", self.App.一般)
            if not CacheIsEnabled_ofAPI:  # 接続先名に対応するキャッシュデータが存在しない場合
                self.SetWidgetVal(Widget = ManageKeysBtn, Value = "キーを登録")  # ボタンテキストを "キーを登録" に変更
            else:  # 接続先名に対応するキャッシュデータが存在する場合
                self.SetWidgetVal(Widget = ManageKeysBtn, Value = "キーを変更")  # ボタンテキストを "キーを変更" に変更

            # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
            self.LogManager.InsertProcessedLOG(self.App.一般)
            self.LogManager.InsertLOG("API キー登録／変更ボタン：状態更新完了", self.App.一般)
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # API キー及び API シークレットを登録または変更する関数
    def RegisterOrChangeKeys(self, TabNum, Register = False, Change = False):
        """ この部分を「関数の docstring」と言います。
        API キー及び API シークレットを登録または変更する関数。

        この関数は、メインフレーム「設定」タブの「接続先」タブを識別するための引数 TabNum に対応する､「接続先選択」プルダウンで選択中の接続先の API キー及び
        API シークレットを登録または変更します。登録または変更の処理モードの選択は引数 Register と Change によって行い、キーの登録または変更の処理を一元的に
        行うことができます。キーの変更の場合、実際に処理を行う前にユーザーはシステム管理者としての権限確認を通過する必要があります。権限確認に成功し、ユーザーが
        新しい各種キーを入力した場合、それらキーは処理の過程で暗号化し、アプリケーションの設定及びキャッシュファイルに保存します。この関数はアプリケーションの
        セキュリティに直接関わる重要な処理を行うため、適切なエラーハンドリングとユーザー認証が不可欠です。また、この処理は暗号化キーの安全な管理を前提としており、
        その取り扱いには最大限の注意を要します。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            TabNum (int): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。ユーザーが現在操作しているタブを指す。
            Register (bool, optional): 新しいキーの登録処理を行う場合は True、そうでない場合は False（デフォルト）。
            Change (bool, optional): 既存のキーの変更処理を行う場合は True、そうでない場合は False（デフォルト）。

        Returns:
            bool:
                処理に成功した場合、True。そうでなければ False。
                成功の条件には、ユーザーによる入力の完了、各種 API キーの正常な暗号化、及び設定とキャッシュファイルへの保存が含まれる。
                ユーザーのシステム管理者権限の確認の失敗、ユーザーによる処理のキャンセル、暗号化キーの読み込み失敗などが失敗の理由となり得る。
        """
        if Register:  # キーの登録の場合のログ記録
            self.LogManager.InsertLOG("各種キーの登録開始", self.App.一般)
        elif Change:  # キーの変更の場合のログ記録及びシステム管理者権限の確認
            self.LogManager.InsertLOG("各種キーの変更開始", self.App.一般)
            if not self.AskPassword():  # システム管理者権限の確認が取れなかった場合、処理を終了
                self.LogManager.InsertLOG("システム管理者権限の確認失敗", self.App.一般)
                return False  # 処理を終了して False を返す
            """
API キー及び API シークレットの取り扱いはセキュリティに直結する処理なため、重要な処理を行う前にユーザーがシステム管理者権限を持っていることを確認することで、不正
なユーザーの操作による敏感情報の漏洩リスクの低減を図ります。
            """

        if not self.CreateOrLoadEncryptionKey():  # 暗号化キーの作成または読み込み及び存在確認（エラーが発生した場合、処理を終了）
            return False  # 処理を終了して False を返す

        try:  # エラーを検出するブロック
            if Register:  # キーの登録の場合、新しい API キー及び API シークレットの入力
                New_APIkey, Ok = QInputDialog.getText(  # テキスト入力欄を持つダイアログを表示して入力を求める
                    self.App, "API キーの登録", "新しい API キーを入力してください。")
                if not Ok or not New_APIkey:  # ユーザーがキャンセルした場合
                    return False  # 処理を終了して False を返す

                New_APIsecret, Ok = QInputDialog.getText(  # テキスト入力欄を持つダイアログを表示して入力を求める
                    self.App, "API シークレットの登録", "新しい API シークレットを入力してください。")
                if not Ok or not New_APIsecret:  # ユーザーがキャンセルした場合
                    return False  # 処理を終了して False を返す
            elif Change:  # キーの変更の場合、新しい API キー及び API シークレットの入力
                # TabNum に対応する属性名を設定及び AppClass（self.App）属性の対応する属性から暗号化された API キー（bytes）を取得
                APIkey_EncryptedBytes = getattr(self.App, "APIkey_EncryptedBytes_{0}".format(str(TabNum)), None)
                # 取得した暗号化された API キー（bytes）を復号化して文字列型（str）の API キーを取得
                APIkey_DecryptedStr = ErrorHandler_ofEncryptOrDecrypt(self.LogManager, self.App, APIkey_EncryptedBytes,
                    "API キー", Decrypt = True, ReturnStr = True)
                if not APIkey_DecryptedStr:  # API キーの復号化に失敗している場合、処理を終了
                    return False  # 処理を終了して False を返す
                # API キーの入力（復号化した API キーを入力欄に表示）
                New_APIkey, Ok = QInputDialog.getText(  # テキスト入力欄を持つダイアログを表示して入力を求める
                    self.App, "API キーの変更", "新しい API キーを入力してください。", text = APIkey_DecryptedStr)
                if not Ok or not New_APIkey:  # ユーザーがキャンセルした場合
                    return False  # 処理を終了して False を返す

                # TabNum に対応する属性名を設定及び AppClass（self.App）属性の対応する属性から暗号化された API シークレット（bytes）を取得
                APIsecret_EncryptedBytes = getattr(self.App, "APIsecret_EncryptedBytes_{0}".format(str(TabNum)), None)
                # 取得した暗号化された API シークレット（bytes）を復号化して文字列型（str）の API シークレットを取得
                APIsecret_DecryptedStr = ErrorHandler_ofEncryptOrDecrypt(self.LogManager, self.App, APIsecret_EncryptedBytes,
                    "API シークレット", Decrypt = True, ReturnStr = True)
                if not APIsecret_DecryptedStr:  # API シークレットの復号化に失敗している場合、処理を終了
                    return False  # 処理を終了して False を返す
                # API シークレットの入力（復号化した API シークレットを入力欄に表示）
                New_APIsecret, Ok = QInputDialog.getText(  # テキスト入力欄を持つダイアログを表示して入力を求める
                    self.App, "API シークレットの変更", "新しい API シークレットを入力してください。", text = APIsecret_DecryptedStr)
                if not Ok or not New_APIsecret:  # ユーザーがキャンセルした場合
                    return False  # 処理を終了して False を返す

            # 新しい各種 API キーの暗号化と属性への保存及びキャッシュファイルへの保存
            Result = self.EncryptAndSaveKeys(TabNum, New_APIkey, New_APIsecret)
        finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
            New_APIkey = None  # 使用完了した平文データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            New_APIsecret = None  # 使用完了した平文データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            APIkey_DecryptedStr = None  # 使用完了した復号化データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            APIsecret_DecryptedStr = None  # 使用完了した復号化データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる

        if Result and Register:  # 暗号化及び保存が成功した場合（キーの登録の場合）のログ記録
            self.LogManager.InsertLOG("各種キーの登録完了", self.App.一般)
        elif Result and Change:  # 暗号化及び保存が成功した場合（キーの変更の場合）のログ記録
            self.LogManager.InsertLOG("各種キーの変更完了", self.App.一般)
        elif not Result and Register:  # 暗号化及び保存のいずれかが失敗した場合（キーの登録の場合）のログ記録
            self.LogManager.InsertLOG("各種キーの登録失敗", self.App.一般)
        elif not Result and Change:  # 暗号化及び保存のいずれかが失敗した場合（キーの変更の場合）のログ記録
            self.LogManager.InsertLOG("各種キーの変更失敗", self.App.一般)

        return Result  # 処理結果を返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 選択中の接続先の API キー及び API シークレットを表示／非表示にする関数
    def ShowKeysBtn(self, CallNum, TabNum):
        """ この部分を「関数の docstring」と言います。
        選択中の接続先の API キー及び API シークレットを表示／非表示にする関数。

        この関数は、メインフレーム「設定」タブの「接続先」タブを識別するための引数 TabNum に対応する､「接続先選択」プルダウンで選択中の接続先の各種 API キーの
        表示／非表示の切り替えボタンが押された時、またはボタンの状態を更新する必要がある時に呼び出されます。これらの呼び出し種別は引数 CallNum によって判断
        します（前者は 1、後者は 2）。また、この関数はキャッシュデータの有無に応じて適切にボタンの状態及びボタンテキストの更新処理を行います。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            CallNum (int): 当該ボタンが押されたのか、またはそのボタンの状態を変更するのかを識別する整数値（1 または 2）。
            TabNum (int): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。ユーザーが現在操作しているタブを指す。

        Returns:
            なし。
        """
        # TabNum に対応する属性名の設定と対応する AppClass（self.App）属性の取得
        # 接続先名に対応するキャッシュが存在することを示すフラグ属性の値を取得
        CacheIsEnabled_ofAPI = getattr(self.App, "CacheIsEnabled_ofAPI_{0}".format(str(TabNum)), None)
        # API キー及び API シークレットを表示／伏せるボタンを切り替えるためのフラグの属性名を設定
        ShowKeys_attr = "ShowKeys_{0}".format(str(TabNum))
        """ "attr" は attribute（属性）の略を指し、プログラミングの文脈において一般的に使われます。 """
        # API キー及び API シークレットを表示／伏せるボタンを切り替えるためのフラグ属性から値を取得
        ShowKeys = getattr(self.App, ShowKeys_attr, None)
        # API キー及び API シークレットを表示／伏せるボタンの参照を取得
        ShowKeysBtn = getattr(self.App, "ShowKeysBtn_{0}".format(str(TabNum)), None)

        if CallNum == self.App.主:  # ボタンが押された場合
            self.LogManager.InsertLOG("キー表示／非表示切り替え処理開始", self.App.一般)
            if CacheIsEnabled_ofAPI:  # 接続先名に対応するキャッシュデータが存在する場合
                if not ShowKeys:  # 各種 API キーが非表示の場合、表示処理を行う
                    if not self.AskPassword():  # システム管理者権限の確認が取れなかった場合、処理を終了
                        self.LogManager.InsertLOG("システム管理者権限の確認失敗", self.App.一般)
                        return  # 処理を終了
                    """
API キー及び API シークレットの取り扱いはセキュリティに直結する処理なため、重要な処理を行う前にユーザーがシステム管理者権限を持っていることを確認することで、不正
なユーザーの操作による敏感情報の漏洩リスクの低減を図ります。
                    """

                    if not self.CreateOrLoadEncryptionKey():  # 暗号化キーの作成または読み込み及び存在確認（エラーが発生した場合、処理を終了）
                        return  # 処理を終了

                    setattr(self.App, ShowKeys_attr, True)  # 各種 API キーを表示するようフラグを設定
                    self.CreateLabels_ofAPIkeys(TabNum)  # API キー及び API シークレットのラベル（QLabel）を更新
                    self.SetWidgetVal(Widget = ShowKeysBtn, Value = "キーを伏せる")  # "キーを表示" したのでボタンテキストを "キーを伏せる" に変更
                else:  # 各種 API キーを表示中の場合、非表示処理を行う
                    setattr(self.App, ShowKeys_attr, False)  # 各種 API キーを非表示にするようフラグを設定
                    self.CreateLabels_ofAPIkeys(TabNum)  # API キー及び API シークレットのラベル（QLabel）を更新
                    self.SetWidgetVal(Widget = ShowKeysBtn, Value = "キーを表示")  # "キーを伏せる" したのでボタンテキストを "キーを表示" に変更

            # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
            self.LogManager.InsertProcessedLOG(self.App.一般)
            self.LogManager.InsertLOG("キー表示／非表示切り替え処理完了", self.App.一般)
        elif CallNum == self.App.副:  # ボタンの状態を変更する場合
            self.LogManager.InsertLOG("キー表示／非表示ボタン：状態更新開始", self.App.一般)

            if CacheIsEnabled_ofAPI:  # 接続先名に対応するキャッシュデータが存在する場合
                ShowKeysBtn.setEnabled(True)  # API キー及び API シークレットを表示／伏せるボタンを有効化

                if not ShowKeys:  # API キー及び API シークレットを表示／伏せるボタンを切り替えるためのフラグが各種キーが非表示であることを示している場合
                    self.SetWidgetVal(Widget = ShowKeysBtn, Value = "キーを表示")  # ボタンテキストを "キーを表示" に変更
                else:  # API キー及び API シークレットを表示／伏せるボタンを切り替えるためのフラグが各種キーを表示中であることを示している場合
                    self.SetWidgetVal(Widget = ShowKeysBtn, Value = "キーを伏せる")  # ボタンテキストを "キーを伏せる" に変更
            else:  # 接続先名に対応するキャッシュデータが存在しない場合
                ShowKeysBtn.setEnabled(False)  # API キー及び API シークレットを表示／伏せるボタンを無効化
                self.SetWidgetVal(Widget = ShowKeysBtn, Value = "キーなし")  # ボタンテキストを "キーなし" に変更

            # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
            self.LogManager.InsertProcessedLOG(self.App.一般)
            self.LogManager.InsertLOG("キー表示／非表示ボタン：状態更新完了", self.App.一般)
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 選択中の接続先に対して API の接続テストを行う関数
    def TestAccessBtn(self, CallNum, TabNum):
        """ この部分を「関数の docstring」と言います。
        選択中の接続先に対して API の接続テストを行う関数。

        この関数は、メインフレーム「設定」タブの「接続先」タブを識別するための引数 TabNum に対応する､「接続先選択」プルダウンで選択中の接続先の接続テストボタン
        が押された時、またはボタンの状態を更新する必要がある時に呼び出されます。これらの呼び出し種別は引数 CallNum によって判断します（前者は 1、後者は 2）。
        また、この関数はキャッシュデータの有無に応じて適切に接続テスト処理、またはボタンの状態の更新処理を行います。接続テストを行う場合、この関数はエンドポイント
        として「マーケットの一覧取得」を使用します。接続に成功した場合、取得したマーケットの一覧（プロダクトコードの一覧）情報を通貨ペアプルダウンに設定し、取得
        した情報の再利用を行います。通貨ペアプルダウンの内容を更新後､「通貨ペア取得」ボタンの表示状態を更新します。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            CallNum (int): 当該ボタンが押されたのか、またはそのボタンの状態を変更するのかを識別する整数値（1 または 2）。
            TabNum (int): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。ユーザーが現在操作しているタブを指す。

        Returns:
            なし。
        """
        if CallNum == self.App.主:  # ボタンが押された場合
            self.LogManager.InsertLOG("HTTP API の接続テストを開始", self.App.一般)
            # TabNum に対応する属性名を設定及び AppClass（self.App）属性の対応する属性から暗号化された各種 API キー（bytes）を取得
            APIkey_EncryptedBytes = getattr(self.App, "APIkey_EncryptedBytes_{0}".format(str(TabNum)), None)
            APIsecret_EncryptedBytes = getattr(self.App, "APIsecret_EncryptedBytes_{0}".format(str(TabNum)), None)

            if APIkey_EncryptedBytes == b"" or APIsecret_EncryptedBytes == b"":  # API キー及び API シークレットが設定されていない場合
                QMessageBox.critical(self.App, "エラー", "API キーまたは API シークレットが設定されていません。")  # ダイアログを表示
                self.LogManager.InsertLOG("API キーまたは API シークレット未設定", self.App.一般)
                return False  # 処理を終了して False を返す

            if not self.CreateOrLoadEncryptionKey():  # 暗号化キーの作成または読み込み及び存在確認（エラーが発生した場合、処理を終了）
                return False  # 処理を終了して False を返す

            Response = None  # 接続テストの実行

            if Response and Response.status_code == 200:  # レスポンスのステータスコードが正常値の場合
                QMessageBox.information(self.App, "接続テスト", "接続に成功しました。")  # ダイアログを表示
                self.LogManager.InsertLOG("接続成功", self.App.一般)
                return True  # 処理を終了して True を返す
            else:  # レスポンスのステータスコードが異常値の場合
                QMessageBox.information(self.App, "接続テスト", "接続に失敗しました。")  # ダイアログを表示
                self.LogManager.InsertLOG("接続失敗", self.App.一般)
                return False  # 処理を終了して False を返す
        elif CallNum == self.App.副:  # ボタンの状態を変更する場合
            self.LogManager.InsertLOG("接続テストボタン：状態更新開始", self.App.一般)
            # TabNum に対応する属性名を設定及び AppClass（self.App）属性の対応する属性から値を取得
            # 接続先名に対応するキャッシュが存在することを示すフラグ属性の値を取得
            CacheIsEnabled_ofAPI = getattr(self.App, "CacheIsEnabled_ofAPI_{0}".format(str(TabNum)), None)
            TestAccessBtn = getattr(self.App, "TestAccessBtn_{0}".format(str(TabNum)), None)  # 接続テストボタンの参照を取得

            if CacheIsEnabled_ofAPI:  # 接続先名に対応するキャッシュデータが存在する場合
                TestAccessBtn.setEnabled(True)  # API の接続テストを行うボタンを有効化
            else:  # 接続先名に対応するキャッシュデータが存在しない場合
                TestAccessBtn.setEnabled(False)  # API の接続テストを行うボタンを無効化

            self.LogManager.InsertLOG("接続テストボタン：状態更新完了", self.App.一般)
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 選択中の接続先の API キー及び API シークレットを削除する関数
    def ClearKeysBtn(self, CallNum, TabNum):
        """ この部分を「関数の docstring」と言います。
        選択中の接続先の API キー及び API シークレットを削除する関数。

        この関数は、メインフレーム「設定」タブの「接続先」タブを識別するための引数 TabNum に対応する､「接続先選択」プルダウンで選択中の接続先の各種 API キーを
        削除するボタンが押された時、またはボタンの状態を更新する必要がある時に呼び出されます。これらの呼び出し種別は引数 CallNum によって判断します（前者は 1、
        後者は 2）。また、この関数はキャッシュデータの有無に応じて適切に各種 API キーを削除する処理、またはボタンの状態の更新処理を行います。削除処理を行った
        結果キャッシュファイルが空になった場合には、暗号化キーの消去処理も実行します。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            CallNum (int): 当該ボタンが押されたのか、またはそのボタンの状態を変更するのかを識別する整数値（1 または 2）。
            TabNum (int): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。ユーザーが現在操作しているタブを指す。

        Returns:
            なし。
        """
        # TabNum に対応する､「接続先選択」プルダウンで選択中の接続先の API のキャッシュが有効な状態かどうかを示すフラグの属性名を設定
        CacheIsEnabled_ofAPI_attr = "CacheIsEnabled_ofAPI_{0}".format(str(TabNum))
        """ "attr" は attribute（属性）の略を指し、プログラミングの文脈において一般的に使われます。 """

        if CallNum == self.App.主:  # ボタンが押された場合
            self.LogManager.InsertLOG("API キー及び API シークレットの削除開始", self.App.一般)
            if not self.AskPassword():  # システム管理者権限の確認が取れなかった場合、処理を終了
                self.LogManager.InsertLOG("システム管理者権限の確認失敗", self.App.一般)
                return  # 処理を終了
            """
API キー及び API シークレットの取り扱いはセキュリティに直結する処理なため、重要な処理を行う前にユーザーがシステム管理者権限を持っていることを確認することで、不正
なユーザーの操作による敏感情報の漏洩リスクの低減を図ります。
            """

            if os.path.exists(API_KEYS_CACHE):  # 各種 API キーのキャッシュファイルが存在する場合、その内容を読み込み
                # TabNum に対応する属性名を設定及び AppClass（self.App）属性の対応する属性から接続先データの待機辞書の参照を取得
                StandbyDict = getattr(self.App, "ConnectionsStandby_{0}".format(str(TabNum)), None)

                try:  # エラーを検出するブロック
                    with open(API_KEYS_CACHE, "r+") as File:  # 各種 API キーのキャッシュファイルを読み書きモードで展開
                        Cache = json.load(File)  # 各種 API キーのキャッシュファイルの内容を読み込み（辞書）
                        if StandbyDict["接続先名"] in Cache:  # 待機辞書の接続先名がキャッシュデータに存在するか確認
                            del Cache[StandbyDict["接続先名"]]  # 待機辞書の接続先名をキーとする各種 API キーをキャッシュデータから削除

                            if Cache:  # キャッシュデータに他のキー情報が存在する場合
                                File.seek(0)  # ファイルポインタをファイルの先頭に移動
                                File.truncate()  # ファイルの内容をクリア
                                json.dump(Cache, File)  # 更新したキャッシュデータをファイルに書き込み
                            else:  # キャッシュデータに他のキー情報が存在しない場合
                                File.seek(0)  # ファイルポインタをファイルの先頭に移動
                                File.truncate()  # ファイルの内容をクリア
                                json.dump({}, File)  # 空のキャッシュデータをファイルに書き込み
                                self.DeleteEncryptionKey()  # 暗号化キーを消去

                            # キャッシュファイルから削除した API キー及び API シークレットと同一のキー情報を持つ AppClass（self.App）属性をクリア
                            setattr(self.App, "APIkey_EncryptedBytes_{0}".format(str(TabNum)), b"")  # 初期値（bytes）を設定してクリア
                            setattr(self.App, "APIsecret_EncryptedBytes_{0}".format(str(TabNum)), b"")  # 初期値（bytes）を設定してクリア
                            setattr(self.App, CacheIsEnabled_ofAPI_attr, False)  # API のキャッシュが有効な状態かどうかを示すフラグを無効化

                            self.LogManager.InsertLOG("{0} API キーキャッシュ：{1}".format(
                                str(StandbyDict["接続先名"]), str(False)), self.App.一般)
                            QMessageBox.information(self.App, "キャッシュ（API キー）削除", "各種キーを削除しました。")  # ダイアログを表示
                            self.LogManager.InsertLOG("API キー及び API シークレットの削除完了", self.App.一般)
                except (IOError, OSError) as e:  # IOError または OSError が発生した場合、ファイル再作成処理のファイル消去処理シークエンスを開始
                    # ファイル再作成処理のファイル消去処理
                    self.ErrorHandler_ofRemoveCacheFileOfRecreate(self.App.主, "各種キー", API_KEYS_CACHE, e)
                except Exception as e:  # 何らかのエラーが発生した場合
                    self.LogManager.InsertLOG("キャッシュファイルの処理中にエラーが発生しました。エラー内容「{0}」".format(str(e)), self.App.一般)
                    QMessageBox.critical(self.App, "予期しないエラー", ("各種 API キーのキャッシュファイル操作中に予期しないエラーが発生しました。"
                        "エラー内容「{0}」".format(str(e))))  # ダイアログを表示
                    return  # 処理を終了
            else:  # キャッシュファイルが存在しない場合
                QMessageBox.information(self.App, "各種 API キー削除", "各種 API キーのキャッシュファイルが存在しません。")  # ダイアログを表示
                self.LogManager.InsertLOG("API キー及び API シークレットの記録なし", self.App.一般)

            self.CreateLabels_ofAPIkeys(TabNum)  # API キー及び API シークレットのラベル（QLabel）を更新
            # 他のボタンの状態を対応する状態に更新
            self.APIkeys_BtnResponder(CallNum = self.App.副, InternalName = "ShowKeysBtn", TabNum = TabNum)
            self.APIkeys_BtnResponder(CallNum = self.App.副, InternalName = "ManageKeysBtn", TabNum = TabNum)
            self.APIkeys_BtnResponder(CallNum = self.App.副, InternalName = "TestAccessBtn", TabNum = TabNum)
        elif CallNum == self.App.副:  # ボタンの状態を変更する場合
            self.LogManager.InsertLOG("キー削除ボタン：状態更新開始", self.App.一般)
            # API のキャッシュが有効な状態かどうかを示すフラグの値を取得
            CacheIsEnabled_ofAPI = getattr(self.App, CacheIsEnabled_ofAPI_attr, None)
            # API キー及び API シークレットを削除するボタンの参照を取得
            ClearKeysBtn = getattr(self.App, "ClearKeysBtn_{0}".format(str(TabNum)), None)

            if CacheIsEnabled_ofAPI:  # 接続先名に対応するキャッシュデータが存在する場合
                ClearKeysBtn.setEnabled(True)  # API キー及び API シークレットを削除するボタンを有効化
            else:  # 接続先名に対応するキャッシュデータが存在しない場合
                ClearKeysBtn.setEnabled(False)  # API キー及び API シークレットを削除するボタンを無効化

            self.LogManager.InsertLOG("キー削除ボタン：状態更新完了", self.App.一般)
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    ##############################
    # ### クラス外から呼ばれる関数 ###
    ##############################

    # メインフレーム「設定」タブでユーザーが設定した値（設定）を保存する関数
    def SaveProcessor(self):
        """ この部分を「関数の docstring」と言います。
        メインフレーム「設定」タブでユーザーが設定した値（設定）を保存する関数。

        この関数は、アプリケーションの設定項目の値を取得し、JSON ファイルとして保存します。設定項目とは、アプリケーションが AppClass（self.App）で設定の保存
        対象として設定している、メインフレーム「設定」タブのインタラクティブな各種 GUI ウィジェットのことを指します。どの GUI ウィジェットの値を設定項目に
        含めるかは、AppClass（self.App）属性の SettingNames 属性の値を調整することで設定可能です。SettingNames 属性には、設定項目に含める GUI
        ウィジェットの属性名を定義します。このとき、属性名の末尾に付与している "_" を伴う接尾辞、メインフレーム「設定」タブの「接続先」タブを識別する整数値を
        定義に含める必要はありません。接尾辞は、設定保存対象の GUI ウィジェットのシグナルにこの関数を接続する関数 self.ConnectsSaveProcessor() によって
        補完されます。また実際の設定の保存処理は、アプリケーションの初期化（起動）が完了していることを前提条件として行います。これには、AppClass（self.App）
        属性の AppInitialized 属性（アプリケーションの初期化が完了しているかを示すフラグ）を用います。また、例えばプルダウンメニュー（QComboBox）のリストを
        一度消去して新しいリストを設定する場合など、この関数の処理を行うべき適切なタイミングでない場合にシグナルが発行されてこの関数が呼び出されることがあります。
        これは、それがどのようなコンテキストであれ、GUI ウィジェットの値が変更された場合には必ずシグナルが発行されるという PyQt フレームワークの仕様によるもの
        です。この関数は、そのような不適切なタイミングでの呼び出しを AppClass（self.App）属性の SaveProhibited 属性によって識別します。ただしこの識別は、
        GUI ウィジェットの値をプログラムが操作する箇所で SaveProhibited 属性（この関数の処理を不許可にするフラグ）が正しく取り扱われることを前提に機能します。
        またこの関数では、シグナル発行元の GUI ウィジェットが継承している QObject クラスが持つメソッド sender().objectName() を使用してシグナルの発行元を
        特定します。このため、設定保存対象の GUI ウィジェットの定義時には、メソッド setObjectName() を使用してオブジェクト名が設定されている必要があります。
        メソッド setObjectName() は PyQt フレームワークの全ての GUI ウィジェットで使用可能です。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        if self.App.AppInitialized and not self.App.SaveProhibited:  # 設定を保存する適切なタイミングかを判断する条件式
            Settings = {}  # 辞書を初期化

            self.LogManager.LogSeparator(self.App.一般)
            self.LogManager.InsertLOG("設定：保存開始", self.App.一般)
            # キャッシュファイルの読み込みをエラーハンドリング関数で実行
            Result = self.ErrorHandler_ofOpenCacheIncludeRetry("設定", SETTINGS_CACHE, "r")
            if isinstance(Result, list):  # キャッシュファイルの読み込みが正常に完了した場合
                Settings = Result[0]  # リスト形式で返されたデータから読み込まれたデータを取得
            # キャッシュファイルの読み込み時にエラーが発生した場合、かつファイル消去処理が行われなかったかファイル消去処理に失敗している場合
            elif isinstance(Result, bool) and not Result:
                return  # 処理を終了
            """
ここでは、関数 self.ErrorHandler_ofOpenCacheIncludeRetry() が返す可能性のある None（キャッシュファイルが存在しないことを示す）と True（ファイル消去処理
が成功したことを示す）を条件式で明示的に取り扱っていません。これは、これらの値が返された場合、この関数は初期化済みのローカル変数 Settings を使用して引き続き
「変更された設定値を保存」する処理を続行できるためです。
            """

            WidgetName = self.App.sender().objectName()  # 値が変更された GUI ウィジェットの名前を取得
            # 取得した名前を使用して値を取得及び名前をキーとして値を設定辞書に保存
            Settings[WidgetName] = self.GetWidgetVal(WidgetName = WidgetName)
            """
この部分で、GUI ウィジェットの名前をキーとしてそのウィジェットの現在の値を設定辞書に保存することで、複数の GUI ウィジェットの値を一つのキャッシュファイルで管理
することが可能になります。設定辞書に既に取得した GUI ウィジェットの名前と同じ名前がキーとして存在している場合、ここで上書きし、新しい値に置き換えます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

            # キャッシュファイルへの書き込みをエラーハンドリング関数で実行
            Result = self.ErrorHandler_ofOpenCacheIncludeRetry("設定", SETTINGS_CACHE, "w", WriteData = Settings)
            if Result == "書き込み完了":  # キャッシュファイルへの書き込みに成功した場合のログ記録
                self.LogManager.InsertLOG("設定：保存完了", self.App.一般)
            # キャッシュファイルへの書き込みに失敗した場合、かつ再試行が行われなかったか再試行も失敗している場合のログ記録
            elif isinstance(Result, bool):
                self.LogManager.InsertLOG("設定：保存失敗", self.App.一般)
            """
ここでは、関数 self.ErrorHandler_ofOpenCacheIncludeRetry() が返す可能性のある None（キャッシュファイルが存在しないことを示す）を条件式で明示的に取り
扱っていません。これは、キャッシュファイルへの書き込み時にはファイルが存在しているかに関わらず書き込み処理を行うためです。
            """
            self.LogManager.LogSeparator(self.App.一般)
        elif self.App.SaveProhibited:  # 設定を保存する適切なタイミングでない場合、その状況をログに記録
            self.LogManager.InsertLOG("設定：保存指示待機", self.App.一般)

    # 設定保存関数をシグナルに接続する関数
    def ConnectsSaveProcessor(self):
        """ この部分を「関数の docstring」と言います。
        設定保存関数をシグナルに接続する関数。

        この関数は、メインフレーム「設定」タブの「接続先」タブに配置されている、アプリケーションが設定の保存対象として設定しているインタラクティブな各種 GUI
        ウィジェットのシグナルに、設定保存関数 self.SaveProcessor() を接続します。この接続によって、ウィジェットの値が変更された際に設定が自動的に保存される
        ようにします。シグナルへの設定保存関数の接続は、AppClass（self.App）で定義されている SettingNames 属性を使用して行います。この属性に定義されている
        設定保存対象の GUI ウィジェットの名前には、メインフレーム「設定」タブの「接続先」タブを識別するためのタブ番号を含む接尾辞が付与されていませんが、この
        関数ではメインフレーム「設定」タブの全ての「接続先」タブに対して設定保存関数の接続処理を行うため、関数内で順次接尾辞を付与することが可能です。逆に、
        接尾辞が付与されていると、この関数は処理を正しく行うことができません。また、将来の拡張可能性を保証するため、この関数は実際には使用されていない GUI
        ウィジェットのタイプチェックと、それに対する接続処理も備えています。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        for TabNum in range(1, self.App.Settings_TabCount + 1):  # メインフレーム「設定」タブの各「接続先」タブのためのイテレーション
            self.LogManager.InsertLOG("設定：保存準備開始 {0}".format(str(TabNum)), self.App.一般)
            # AppClass（self.App）属性の SettingNames 属性で定義されている
            # 各種 GUI ウィジェットの名前を取得しシグナルに設定保存関数を接続するためのイテレーション
            for SettingName in self.App.SettingNames:
                # 取得したウィジェット名にメインフレーム「設定」タブの各「接続先」タブを識別するタブ番号 TabNum の接尾辞を付与
                WidgetName = "{0}_{1}".format(str(SettingName), str(TabNum))
                if hasattr(self.App, WidgetName):  # 接尾辞を補完したウィジェット名が AppClass（self.App）属性に存在することを確認
                    Widget = getattr(self.App, WidgetName, None)  # 接尾辞を補完したウィジェット名を使用して対応するウィジェットの参照を取得
                    if isinstance(Widget, QCheckBox):  # QCheckBox の状態変化を監視する場合
                        Widget.stateChanged.connect(lambda Checked, W = Widget: self.SaveProcessor())  # チェック状態の変化に応じるよう接続
                    elif isinstance(Widget, QComboBox):  # QComboBox の選択変化を監視する場合
                        # 選択インデックスの変化に応じるよう接続
                        Widget.currentIndexChanged.connect(lambda Index, W = Widget: self.SaveProcessor())
                    elif isinstance(Widget, QDateEdit):  # QDateEdit の日付変化を監視する場合
                        Widget.dateChanged.connect(lambda Date, W = Widget: self.SaveProcessor())  # 日付の変化に応じるよう接続
                    elif isinstance(Widget, QDateTimeEdit):  # QDateTimeEdit の日付時刻変化を監視する場合
                        # 日付と時刻の変化に応じるよう接続
                        Widget.dateTimeChanged.connect(lambda Datetime, W = Widget: self.SaveProcessor())
                    elif isinstance(Widget, QDoubleSpinBox):  # QDoubleSpinBox の値変化を監視する場合
                        # 浮動小数点数（float）の変化に応じるよう接続
                        Widget.valueChanged.connect(lambda Value, W = Widget: self.SaveProcessor())
                    elif isinstance(Widget, QLineEdit):  # QLineEdit のテキスト変化を監視する場合
                        Widget.textChanged.connect(lambda Text, W = Widget: self.SaveProcessor())  # テキスト内容の変化に応じるよう接続
                    elif isinstance(Widget, QRadioButton):  # QRadioButton の選択状態変化を監視する場合
                        Widget.toggled.connect(lambda State, W = Widget: self.SaveProcessor())  # 選択状態の変化に応じるよう接続
                    elif isinstance(Widget, QSlider):  # QSlider の値変化を監視する場合
                        Widget.valueChanged.connect(lambda Value, W = Widget: self.SaveProcessor())  # スライダーの値の変化に応じるよう接続
                    elif isinstance(Widget, QSpinBox):  # QSpinBox の値変化を監視する場合
                        Widget.valueChanged.connect(lambda Value, W = Widget: self.SaveProcessor())  # 整数値（int）の変化に応じるよう接続
                    elif isinstance(Widget, QTextEdit):  # QTextEdit のテキスト変化を監視する場合
                        Widget.textChanged.connect(lambda W = Widget: self.SaveProcessor())  # テキスト内容の変化に応じるよう接続
                    elif isinstance(Widget, QTimeEdit):  # QTimeEdit の時刻変化を監視する場合
                        Widget.timeChanged.connect(lambda Time, W = Widget: self.SaveProcessor())  # 時刻の変化に応じるよう接続
                    else:  # 他のウィジェットタイプに対応する場合はここに追加
                        pass  # 何も行わない
                    """
ここでは、シグナルへの設定保存関数の接続箇所全てでラムダ関数を使用しています。ここでのラムダ関数の役割は、各シグナルが発行される際に設定保存関数（スロット）に
デフォルトで渡すよう定義されている値、引数を無視して同関数を呼び出すことです。設定保存関数は引数を取らないため、このデフォルトの挙動を無視する必要があります。
シグナルがデフォルトで関数（スロット）に引数を渡すのは PyQt フレームワークの仕様によるものですが、このアプリケーションには特定のフレームワークやライブラリに依存
する設計を極力避ける設計方針があります。これは将来における使用するフレームワークやライブラリの変更可能性を考慮した、メンテナンス性の向上策です。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                    """

            self.LogManager.InsertLOG("設定：保存準備完了 {0}".format(str(TabNum)), self.App.一般)

    # 設定のキャッシュファイルから設定を読み込む関数
    def LoadProcessor(self):
        """ この部分を「関数の docstring」と言います。
        設定のキャッシュファイルから設定を読み込む関数。

        この関数は、設定のキャッシュファイル（JSON 形式）から設定値を読み込み、メインフレーム「設定」タブの「接続先」タブ内の各設定項目（GUI ウィジェット）に値
        を反映します。この関数はアプリケーションの初期化時（起動時）に呼び出され、初期化完了時に前回アプリケーションに設定されていた各種設定を復元します。これに
        より、ユーザーは迅速にアプリケーションの使用を再開でき、ユーザーエクスペリエンスの向上に寄与します。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        Settings = {}  # 辞書を初期化

        self.LogManager.InsertLOG("設定：読み込み開始", self.App.一般)
        # キャッシュファイルの読み込みをエラーハンドリング関数で実行
        Result = self.ErrorHandler_ofOpenCacheIncludeRetry("設定", SETTINGS_CACHE, "r")
        if isinstance(Result, list):  # キャッシュファイルの読み込みが正常に完了した場合
            Settings = Result[0]  # リスト形式で返されたデータから読み込まれたデータを取得

            # メインフレーム「設定」タブの各「接続先」タブの設定項目に設定値を設定するためのイテレーション
            for WidgetName, SettingValue in Settings.items():
                if hasattr(self.App, WidgetName):  # 設定項目（ウィジェット名）が AppClass（self.App）属性に存在することを確認
                    self.SetWidgetVal(WidgetName = WidgetName, Value = SettingValue)  # 設定項目（ウィジェット名）に設定値を設定

            # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
            self.LogManager.InsertProcessedLOG(self.App.一般)
            self.LogManager.InsertLOG("設定：読み込み完了", self.App.一般)
        elif isinstance(Result, bool):  # キャッシュファイルの読み込み時にエラーが発生した場合のログ記録
            self.LogManager.InsertLOG("設定：読み込み失敗", self.App.一般)
        """
ここでは、関数 self.ErrorHandler_ofOpenCacheIncludeRetry() が返す可能性のある None（キャッシュファイルが存在しないことを示す）と bool 値（ファイル消去
処理を行った結果を示す）の内容を条件式で明示的に取り扱っていません。None の場合、読み込むべき設定値が存在しないため、この関数は即座に処理を終了します。bool 値の
場合、その内容によらずキャッシュファイルの読み込みが正常に行えなかったことを示しているため、こちらも読み込むべき設定値が存在しないためにこの関数は即座に処理を終了
します。ただし、こちらの場合はその際に適切なログの記録を行います。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
        """

    # メインフレーム「接続先編集」タブと「設定」タブの接続先選択プルダウンを初期化する関数
    def Init_ExchangePull(self, PullWidget, TabNum = None):
        """ この部分を「関数の docstring」と言います。
        メインフレーム「接続先編集」タブと「設定」タブの接続先選択プルダウン（EditAccess_Pull、Exchange_Pull）を初期化する関数。

        この関数は、メインフレーム「接続先編集」タブの編集メニューと「設定」タブの両タブにおける接続先選択プルダウン（EditAccess_Pull、Exchange_Pull）の
        初期化、初期化に伴う接続先データの読み込み、GUI の更新などを行います。メインフレーム「設定」タブの「接続先」タブを識別するための引数 TabNum が指定
        されず、デフォルト値 None のままである場合､「接続先編集」タブの編集メニューにおける接続先選択プルダウン（EditAccess_Pull）の処理を行います。反対に
        TabNum が指定されている場合､「設定」タブの「接続先」タブにおける接続先選択プルダウン（Exchange_Pull）の処理を行います。この関数は「接続先編集」タブ
        での接続先リストや接続先データの変更を「設定」タブにも反映させるための再帰処理を含みます。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。この関数では、この関数が呼び出されるイベントの処理中にさらにイベント
        が発生し（この関数内）、イベントハンドラが呼び出されて処理が複雑になることがあるため、ログ記録箇所を通常より多く設定しています。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            PullWidget (widget): 処理対象の接続先選択プルダウンのウィジェットの参照。
            TabNum (int, optional): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。

        Returns:
            なし。
        """
        if TabNum is None:  # メインフレーム「接続先編集」タブからの呼び出しの場合
            self.LogManager.InsertLOG("接続先編集メニュー：設定開始", self.App.一般)
            self.LoadAccess()  # 接続先データと接続先リストを取得または更新
        else:  # メインフレーム「設定」タブの接続先選択プルダウン（各接続先タブ）のための再帰呼び出しの場合
            self.LogManager.InsertLOG("接続先メニュー {0}：設定開始".format(str(TabNum)), self.App.一般)
            if self.App.AppInitialized:  # アプリケーションの初期化に伴う呼び出しでない場合
                CurrentText = self.GetWidgetVal(Widget = PullWidget)  # ユーザーが動的に選択した項目を一時的に記録
                # CurrentText を専用の AppClass（self.App）属性の Selected_AccessName 属性に一時的に保存
                setattr(self.App, "Selected_AccessName_{0}".format(str(TabNum)), CurrentText)
                self.LogManager.InsertLOG("接続先メニュー {0}：現在の選択値を記録「{1}」".format(str(TabNum), str(CurrentText)), self.App.一般)

            self.App.SaveProhibited = True  # これから変更する値を設定値として保存することを不許可に設定（不許可 = True を設定）
        """
ここでは、メインフレーム「設定」タブの「接続先」タブを識別するための引数 TabNum の内容に基づいて、二つのパターンに処理を分けています。この方法での処理の分岐は、
この関数の一連の処理の各所で行っています。従って、以後同じ条件分岐が登場しますが、それらの条件分岐についての理解はここで解説する内容に基づいてください。まず
TabNum がデフォルト値、つまり None の場合ですが、この場合、この関数はメインフレーム「接続先編集」タブの編集メニューの接続先選択プルダウン EditAccess_Pull
の状態を更新するために呼び出されたと解釈します。次に TabNum が None でない場合、つまり整数値（int）が指定されている場合ですが、この場合、この関数はメイン
フレーム「設定」タブの「接続先」タブの接続先選択プルダウン Exchange_Pull の状態を更新するために呼び出されたと解釈します。このアプリケーションでは、こちらの場合
のこの関数の呼び出しはこの関数自身のみが行います。従ってこの関数は、アプリケーションの初期化時と、メインフレーム「接続先編集」タブの編集メニューの各種ボタンによる
操作時に、メインフレーム「設定」タブの「接続先」タブの接続先選択プルダウン Exchange_Pull の内容と状態、及びそれに基づいてアプリケーション内で保持するデータの
最適化を行う責務を持ちます。これらの責務をこの関数が持ち、そのためのこの関数の呼び出しをこの関数自身のみが行うことには、二つの接続先選択プルダウンが密接に関連して
おり、メインフレーム「接続先編集」タブの編集メニューの接続先選択プルダウン EditAccess_Pull の更新を行うことは、もう一方の接続先選択プルダウン Exchange_Pull
の更新を行うことと同義であるという理由があります。この理由から、この関数はメインフレーム「接続先編集」タブの編集メニューの接続先選択プルダウン EditAccess_Pull
の更新を行う処理の最終段階で、自身の再帰呼び出しを行い、メインフレーム「設定」タブの「接続先」タブの接続先選択プルダウン Exchange_Pull の更新処理を行います。
従ってこの関数の処理順序は、常に「if TabNum is None:」ブロックの処理を行った後に、同条件式の else 節の処理を行う、という流れになります。

---------------------------------------------------------------------------------------------------------------------------------------

ここでは、else 節で self.App.SaveProhibited 属性を有効化、True に設定しています。これは、後続のプルダウンメニュー（QComboBox）のリストを一度消去して新しい
リストを設定する処理で、同ウィジェットのシグナルに接続されている設定保存関数が処理を行わないようにするためです。この箇所のように、実際には必要のないタイミングで
シグナルが発行されて設定保存関数が呼び出されることがあります。これは、それがどのようなコンテキストであれ、GUI ウィジェットの値が変更された場合には必ずシグナルが
発行されるという PyQt フレームワークの仕様によるものです。このアプリケーションでは、このような不適切なタイミングでの呼び出しを self.App.SaveProhibited 属性
によって識別します。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
        """

        PullWidget.clear()  # 接続先選択プルダウンの接続先リストを消去

        if TabNum is None:  # メインフレーム「接続先編集」タブからの呼び出しの場合のログ記録
            self.LogManager.InsertLOG("接続先編集メニュー：リスト消去完了", self.App.一般)
        else:  # メインフレーム「設定」タブの接続先選択プルダウン（各接続先タブ）のための再帰呼び出しの場合のログ記録
            self.LogManager.InsertLOG("接続先メニュー {0}：リスト消去完了".format(str(TabNum)), self.App.一般)

        PullWidget.addItems(self.App.AccessNames)  # 接続先選択プルダウンに取得または更新された接続先リストを設定
        # （ここで設定する接続先リストは、この関数の処理の開始時に呼び出した関数 self.LoadAccess() によって取得または更新されたもの）

        if TabNum is None:  # メインフレーム「接続先編集」タブからの呼び出しの場合のログ記録
            self.LogManager.InsertLOG("接続先編集メニュー：リスト読み込み完了", self.App.一般)
        else:  # メインフレーム「設定」タブの接続先選択プルダウン（各接続先タブ）のための再帰呼び出しの場合のログ記録とフラグの変更
            self.LogManager.InsertLOG("接続先メニュー {0}：リスト読み込み完了".format(str(TabNum)), self.App.一般)
            self.App.SaveProhibited = False  # これから変更する値を設定値として保存することを許可に設定（不許可 = True を解除）

        self.Trace_ExchangePull(PullWidget, TabNum = TabNum)  # 状況に合わせて GUI とアプリケーション内で保持するデータ（待機辞書）を更新

        if TabNum is None:  # メインフレーム「接続先編集」タブからの呼び出しの場合
            self.LogManager.InsertLOG("接続先編集メニュー：設定完了", self.App.一般)
            # メインフレーム「接続先編集」タブでの変更内容をメインフレーム「設定」タブの接続先選択プルダウン（各接続先タブ）と
            # アプリケーション内で保持するデータ（待機辞書）に反映
            self.LogManager.InsertLOG("接続先メニュー：各タブの設定開始", self.App.一般)
            for TabNum in range(1, self.App.Settings_TabCount + 1):  # メインフレーム「設定」タブの各「接続先」タブのためのイテレーション
                # TabNum に対応する接続先選択プルダウンの参照を取得
                Exchange_Pull = getattr(self.App, "Exchange_Pull_{0}".format(str(TabNum)), None)
                self.Init_ExchangePull(Exchange_Pull, TabNum = TabNum)  # 取得した参照と作成した TabNum を使用して自身を再帰的に呼び出し

            # メインフレーム「設定」タブの接続先選択プルダウン（各接続先タブ）のための処理完了に伴い必要なくなった TabNum をデフォルト値で上書き
            TabNum = None
        else:  # メインフレーム「設定」タブの接続先選択プルダウン（各接続先タブ）のための再帰呼び出しの場合のログ記録
            self.LogManager.InsertLOG("接続先メニュー {0}：設定完了".format(str(TabNum)), self.App.一般)

        # メインフレーム「接続先編集」タブからの呼び出しの場合、特定のボタン操作によるログ記録の終了処理
        if TabNum is None and self.App.BtnCmd in {"保存", "削除", "全消去"}:
            self.LogManager.LogSeparator(self.App.一般)

    # メインフレーム「接続先編集」タブと「設定」タブの接続先選択プルダウンの状態変化をトレースする関数
    def Trace_ExchangePull(self, PullWidget, Trace = False, TabNum = None):
        """ この部分を「関数の docstring」と言います。
        メインフレーム「接続先編集」タブと「設定」タブの接続先選択プルダウン（EditAccess_Pull、Exchange_Pull）の状態変化をトレースする関数。

        この関数は、ユーザーがメインフレーム「接続先編集」タブの編集メニューにおける接続先選択プルダウン（EditAccess_Pull）またはメインフレーム「設定」タブの
        「接続先」タブにおける接続先選択プルダウン（Exchange_Pull）の選択項目を変更した際に、選択された接続先名に基づいて必要なデータを読み込みます。また、
        アプリケーション初期化時（起動時）や「接続先編集」タブの編集メニューのボタン操作後の処理も含みます。メインフレーム「設定」タブの「接続先」タブを識別する
        ための引数 TabNum が指定されず、デフォルト値 None のままである場合､「接続先編集」タブの編集メニューにおける接続先選択プルダウン（EditAccess_Pull）
        の処理を行います。反対に TabNum が指定されている場合､「設定」タブの「接続先」タブにおける接続先選択プルダウン（Exchange_Pull）の処理を行います。この
        関数は複数の複合的な可能な条件を網羅しているため、処理が非常に複雑になっています。このため、理解促進のためにコメントでの説明を詳細に記していますが、なお
        理解には困難が生じることが考えられます。もしこの関数を拡張などする必要が生じた場合は、理論実装だけではなく、緻密なテストとデバッグを行うことを強く推奨
        します。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。この関数では、この関数が呼び出されるイベントの処理中にさらにイベント
        が発生し（この関数内）、イベントハンドラが呼び出されて処理が複雑になることがあるため、ログ記録箇所を通常より多く設定しています。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            PullWidget (widget): 処理対象の接続先選択プルダウンのウィジェットの参照。
            Trace (bool, optional): プルダウンの選択項目変更による呼び出しかどうかを識別するフラグ。デフォルトは False。
            TabNum (int, optional): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。デフォルトは None。

        Returns:
            なし。
        """
        # 補助関数：メインフレーム「設定」タブからの、または同タブのための呼び出しの場合、
        # 接続先選択プルダウンで選択していた接続先名が接続先リストに存在すればそれを選択
        def ValidateAndSelectAccessName(PullWidget, TabNum):
            """ この部分を「関数の docstring」と言います。
            メインフレーム「設定」タブからの、または同タブのための呼び出しの場合、
            接続先選択プルダウンで選択していた接続先名が接続先リストに存在すればそれを選択し、選択した接続先名と処理結果を示すフラグを返す関数。

            この関数は、この関数の処理結果によらず、後続の処理で利用可能な接続先名と処理結果を示すフラグのタプルを返します。接続先選択プルダウンで選択していた
            接続先名が接続先リストに存在し、接続先選択プルダウンの選択項目をその接続先名に設定した場合、True フラグを返します。接続先選択プルダウンで選択して
            いた接続先名が接続先リストに存在しない場合、接続先選択プルダウンの選択項目は更新せず、False フラグを返します。また、アプリケーションの初期化処理
            （起動処理）の過程で呼び出された場合、またはメインフレーム「設定」タブのコンテキストではない場合も、False フラグを返します。この真偽値によらず、
            この関数は後続の処理で利用可能な接続先名を返します。

            Args:
                PullWidget (widget): 処理対象の接続先選択プルダウンのウィジェットの参照。
                TabNum (int): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。

            Returns:
                tuple of str, bool:
                    後続の処理で利用可能な接続先名と、接続先選択プルダウンの選択項目を更新したかどうかを示すフラグ。更新した場合、True。そうでなければ False。
                    アプリケーション初期化（起動）の場合、またはメインフレーム「設定」タブのコンテキストではない場合も False。
            """
            if self.App.AppInitialized and TabNum:  # メインフレーム「設定」タブからの、または同タブのための呼び出しの場合
                # 関数 self.Init_ExchangePull() で一時的に保存した、接続先選択プルダウンで選択していた接続先名を対応する属性から取得
                Selected_AccessName = getattr(self.App, "Selected_AccessName_{0}".format(str(TabNum)), None)
                if Selected_AccessName in self.App.AccessNames:  # 取得した接続先名が接続先リストに存在する場合
                    self.SetWidgetVal(Widget = PullWidget, Value = Selected_AccessName)  # 取得した接続先名を接続先選択プルダウンで再選択
                    # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
                    self.LogManager.InsertProcessedLOG(self.App.一般)
                    # 利用可能な接続先名として取得した（選択していた）接続先名と、これを再選択したことを示すフラグを返す
                    return Selected_AccessName, True

            # アプリケーション初期化（起動）、またはメインフレーム「設定」タブのコンテキストでない、または選択していた接続先名が接続先リストに存在しない場合
            # （：先の条件式に当てはまらない場合）
            # デフォルトの接続先が接続先リストに存在する場合はデフォルトの接続先名、そうでなければ接続先リストの最初の接続先名を取得
            Available_AccessName = self.App.DefAccess if self.App.DefAccess in self.App.AccessNames else PullWidget.itemText(0)
            return Available_AccessName, False  # 利用可能な接続先名として取得した接続先名と、先の条件が満たされなかったことを示すフラグを返す
            """
return ステートメントで複数の値を返す場合、Python ではそれらは自動的にタプル化されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

        # 補助関数：関数 self.LoadAccess() を CallNum = 2 で呼び出して待機辞書を読み込み、その辞書が有効な値を持っているかの確認情報を取得
        def LoadAccessCallNum2Handler(Selected_AccessName, TabNum):
            """ この部分を「関数の docstring」と言います。
            関数 self.LoadAccess() を CallNum = 2 で呼び出して待機辞書を読み込み、その辞書が有効な値を持っているかの確認情報を取得する関数。

            この関数は、メインフレーム「設定」タブの「接続先」タブの接続先選択プルダウン（Exchange_Pull）の選択項目が変更された際に、待機辞書を読み込む処理を
            行い、読み込まれた待機辞書が有効な値を持っているかを確認するための簡易的な情報として待機辞書のデータサイズ KB を取得して返します。

            Parameters:
                Selected_AccessName (str): 接続先データを読み込む接続先名。
                TabNum (int): メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。

            Returns:
                tuple of str, int: 接続先データを読み込んだ接続先の接続先名と、待機辞書のデータサイズ KB を表す整数値。
            """
            # 引数 Selected_AccessName に対応する接続先データを待機辞書として関数 self.LoadAccess() を使用して読み込み
            self.LoadAccess(Selected_AccessName, CallNum = self.App.Exchange, TabNum = TabNum)
            StandbyDict_attr = "ConnectionsStandby_{0}".format(str(TabNum))  # TabNum に対応する接続先データの属性名（待機辞書名）を設定（再現）
            """ "attr" は attribute（属性）の略を指し、プログラミングの文脈において一般的に使われます。 """
            # AppClass（self.App）属性の接続先データの属性名に対応する属性から待機辞書を取得
            StandbyDict = getattr(self.App, StandbyDict_attr, None)
            Selected_AccessName = StandbyDict["接続先名"] if StandbyDict else "None"  # 待機辞書に格納されている接続先名を取得
            StandbyDict_SizeOfKB = round(asizeof.asizeof(StandbyDict) / 1024, 2) if StandbyDict else 0  # 待機辞書のデータサイズ KB を取得
            """
待機辞書から接続先名とデータサイズを取得しているコード行では三項演算子「X = A if Z else B」を使用し、待機辞書 StandbyDict が False と評価される内容である
場合には、それぞれ "None"（str）と 0（int）が代入されるようにしています。これにより、KeyError（存在しないキーへのアクセス試行）の発生や不必要なデータサイズ
計算処理の発生を防ぎます。またデータサイズを取得している部分で除算に使用している 1024 という値は、1KB あたりのバイト数です。関数 asizeof.asizeof() から
返されるバイト数をこの値で除することで、KB（キロバイト）を計算しています。さらにこの計算をメソッド round() の第一引数で行い、第二引数に 2 を指定することで、
小数点以下第二位までを有効数字とする浮動小数点数を取得しています。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """
            # 取得した結果を返す（return ステートメントで複数の値を返す場合、Python ではそれらは自動的にタプル化される）
            return Selected_AccessName, StandbyDict_SizeOfKB

        """ self.Trace_ExchangePull() の記述 """
        Selected_AccessName = "None"  # 変数を初期化

        # アプリケーション初期化（起動）の場合、
        # またはメインフレーム「接続先編集」タブの「この接続先を削除」または「全ての接続先を消去及び復元」ボタンが押された場合
        if not Trace and (not self.App.AppInitialized or self.App.BtnCmd in {"削除", "全消去"}):
            if TabNum is None:  # メインフレーム「接続先編集」タブからの呼び出しの場合のログ記録
                if not self.App.AppInitialized:  # アプリケーション初期化（起動）の場合のログ記録
                    self.LogManager.InsertLOG("接続先編集メニュー：初期化処理分岐 1", self.App.一般)
                else:  # アプリケーション初期化（起動）でない場合のログ記録
                    self.LogManager.InsertLOG("接続先編集メニュー：初期化処理分岐 2", self.App.一般)
            else:  # メインフレーム「設定」タブの各「接続先」タブのための呼び出しの場合のログ記録
                if not self.App.AppInitialized:  # アプリケーション初期化（起動）の場合のログ記録
                    self.LogManager.InsertLOG("接続先メニュー {0}：初期化処理分岐 1".format(str(TabNum)), self.App.一般)
                else:  # アプリケーション初期化（起動）でない場合のログ記録
                    self.LogManager.InsertLOG("接続先メニュー {0}：初期化処理分岐 2".format(str(TabNum)), self.App.一般)

            # メインフレーム「設定」タブからの、または同タブのための呼び出しの場合、
            # 接続先選択プルダウンで選択していた接続先名が接続先リストに存在すればそれを選択し取得
            # 条件に該当しない場合、デフォルトの接続先が接続先リストに存在する場合はデフォルトの接続先名、そうでなければ接続先リストの最初の接続先名を取得
            # （：利用可能な接続先名、Available_AccessName）
            Available_AccessName, ValidateAndSelectAccessNameIsTrue = ValidateAndSelectAccessName(PullWidget, TabNum)
            """
ここでは、関数が複数の要素を含むタプルを返すと分かっているため、関数の返り値を代入する先をあらかじめタプルが含む要素の数だけ用意しておきます。このようにすること
で、関数が返す複数の要素を含むタプルを自動的にアンパックすることができ、タプルの要素はそれぞれタプル内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """
            # アプリケーション初期化（起動）の場合、またはメインフレーム「設定」タブの各「接続先」タブのための呼び出しでない場合、
            # または同タブの接続先選択プルダウンで選択していた接続先名が接続先リストに存在しない場合
            # （Available_AccessName が空文字列（str）となるのは､「この接続先を削除」ボタンによって接続先選択プルダウンの接続先リストが空になった場合）
            if not ValidateAndSelectAccessNameIsTrue and not Available_AccessName == "":
                if TabNum is None:  # メインフレーム「接続先編集」タブからの呼び出しの場合のログ記録
                    self.LogManager.InsertLOG("接続先編集メニュー：接続先の初期値を取得", self.App.一般)
                else:  # メインフレーム「設定」タブの各「接続先」タブのための呼び出しの場合のログ記録
                    self.LogManager.InsertLOG("接続先メニュー {0}：接続先の初期値を取得".format(str(TabNum)), self.App.一般)

                self.SetWidgetVal(Widget = PullWidget, Value = Available_AccessName)  # 取得した利用可能な接続先名を選択
                # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
                self.LogManager.InsertProcessedLOG(self.App.一般)

            # 接続先選択プルダウンで動的に選択した接続先名に応じて接続先データの読み込みを行うブロック群
            if TabNum is None:  # メインフレーム「接続先編集」タブからの呼び出しの場合
                self.LogManager.InsertLOG("接続先編集メニュー：接続先読み込み開始", self.App.一般)
                # 取得した利用可能な接続先名に対応する接続先データを読み込み
                self.LoadAccess(Selected_AccessName = Available_AccessName, CallNum = self.App.EditAccess)
                self.LogManager.InsertLOG("接続先編集メニュー：初期化完了", self.App.一般)
            # メインフレーム「設定」タブの各「接続先」タブのための呼び出しで、アプリケーション初期化（起動）か、
            # 接続先選択プルダウンで選択していた接続先名が接続先リストに存在しない場合
            elif not ValidateAndSelectAccessNameIsTrue:
                self.LogManager.InsertLOG("接続先メニュー {0}：接続先読み込み開始".format(str(TabNum)), self.App.一般)
                # 関数 self.LoadAccess() を CallNum = 2 で呼び出して待機辞書を読み込み、その辞書が有効な値を持っているかの確認情報を取得
                Selected_AccessName, StandbyDict_SizeOfKB = LoadAccessCallNum2Handler(Available_AccessName, TabNum)

                if not self.App.AppInitialized:  # アプリケーション初期化（起動）の場合のログ記録
                    self.LogManager.InsertLOG("接続先 {0} の接続先情報初期設定完了「接続先名：{1}、サイズ：{2}KB」".format(
                        str(TabNum), str(Selected_AccessName), str(StandbyDict_SizeOfKB)), self.App.一般)  # 待機辞書の情報をログに記録
                else:  # アプリケーション初期化（起動）でない場合のログ記録
                    self.LogManager.InsertLOG("接続先 {0} の接続先情報更新完了「接続先名：{1}、サイズ：{2}KB」".format(
                        str(TabNum), str(Selected_AccessName), str(StandbyDict_SizeOfKB)), self.App.一般)  # 待機辞書の情報をログに記録
            # メインフレーム「設定」タブの各「接続先」タブのための呼び出しで、接続先選択プルダウンで選択していた接続先名が接続先リストに存在する場合
            elif ValidateAndSelectAccessNameIsTrue:
                # ここに該当する場合、アプリケーション初期化（起動）でなく、self.App.BtnCmd が "削除" "全消去" のいずれかで、メインフレーム「設定」タブの
                # 各「接続先」タブのための呼び出し、かつ選択していた接続先名が接続先リストに存在するため、接続先データ（同じもの）の読み込みは行わない
                # （ただし選択に伴うイベントハンドラの呼び出しは行われる）
                self.LogManager.InsertLOG("接続先メニュー {0}：接続先再選択完了".format(str(TabNum)), self.App.一般)
        elif self.App.AppInitialized and Trace and self.App.BtnCmd == "":  # ユーザーが接続先選択プルダウンの選択項目を変更した場合
            Selected_AccessName = self.GetWidgetVal(Widget = PullWidget)  # 選択された接続先名を取得

            # 選択された接続先名に応じて接続先データの読み込みを行うブロック群
            if TabNum is None:  # メインフレーム「接続先編集」タブからの呼び出しの場合
                self.LogManager.InsertLOG("接続先編集メニュー：接続先情報更新完了", self.App.一般)
                self.LoadAccess(Selected_AccessName, CallNum = self.App.EditAccess)  # 選択された接続先名に対応する接続先データを読み込み
            else:  # メインフレーム「設定」タブの各「接続先」タブの接続先選択プルダウンからの呼び出しの場合
                # 関数 self.LoadAccess() を CallNum = 2 で呼び出して待機辞書を読み込み、その辞書が有効な値を持っているかの確認情報を取得
                Selected_AccessName, StandbyDict_SizeOfKB = LoadAccessCallNum2Handler(Selected_AccessName, TabNum)
                self.LogManager.InsertLOG("接続先 {0} の接続先情報更新完了「接続先名：{1}、サイズ：{2}KB」".format(
                    str(TabNum), str(Selected_AccessName), str(StandbyDict_SizeOfKB)), self.App.一般)  # 待機辞書の情報をログに記録
        elif not Trace and self.App.BtnCmd == "保存":  # メインフレーム「接続先編集」タブの「保存」ボタンが押された場合
            if TabNum is None:  # メインフレーム「接続先編集」タブからの呼び出しの場合のログ記録
                self.LogManager.InsertLOG("接続先編集メニュー：初期化処理分岐 2", self.App.一般)
            else:  # メインフレーム「設定」タブの各「接続先」タブのための呼び出しの場合のログ記録
                self.LogManager.InsertLOG("接続先メニュー {0}：初期化処理分岐 2".format(str(TabNum)), self.App.一般)

            Edited_AccessName = self.GetWidgetVal(Widget = self.App.ConnectionEntries["接続先名"])  # 保存された接続先名を取得

            if TabNum is None:  # メインフレーム「接続先編集」タブからの呼び出しの場合のログ記録
                self.LogManager.InsertLOG("接続先編集メニュー：新規または変更された接続先名を取得", self.App.一般)
            else:  # メインフレーム「設定」タブの各「接続先」タブのための呼び出しの場合のログ記録
                self.LogManager.InsertLOG("接続先メニュー {0}：新規または変更された接続先名を取得".format(str(TabNum)), self.App.一般)

            # 保存された接続先名に応じて接続先データの読み込みを行うブロック群
            if TabNum is None:  # メインフレーム「接続先編集」タブからの呼び出しの場合
                self.SetWidgetVal(Widget = PullWidget, Value = Edited_AccessName)  # 取得した保存された接続先名を選択
                # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
                self.LogManager.InsertProcessedLOG(self.App.一般)
                # メインフレーム「接続先編集」タブの「保存」ボタンが押された場合、「接続先編集」タブには保存されたデータが表示されているため、
                # 接続先データ（同じもの）の読み込みは行わない（ただし選択に伴うイベントハンドラの呼び出しは行われる）
                self.LogManager.InsertLOG("接続先編集メニュー：保存された接続先を選択", self.App.一般)
            else:  # メインフレーム「設定」タブの各「接続先」タブのための呼び出しの場合
                # 接続先選択プルダウンで選択していた接続先名が接続先リストに存在すればそれを選択し取得
                # 条件に該当しない場合、デフォルトの接続先が接続先リストに存在する場合はデフォルトの接続先名、そうでなければ接続先リストの最初の接続先名を取得
                # （：利用可能な接続先名、Available_AccessName）
                Available_AccessName, ValidateAndSelectAccessNameIsTrue = ValidateAndSelectAccessName(PullWidget, TabNum)

                # メインフレーム「設定」タブの各「接続先」タブの接続先選択プルダウンで選択していた接続先名が接続先リストに存在しない場合
                if not ValidateAndSelectAccessNameIsTrue:
                    self.SetWidgetVal(Widget = PullWidget, Value = Edited_AccessName)  # 取得した保存された接続先名を選択
                    # 関数 self.SetWidgetVal() によって蓄積された ProcessLog を、重複の省略処理を行ってからログテキストエリアに反映
                    self.LogManager.InsertProcessedLOG(self.App.一般)
                    self.LogManager.InsertLOG("接続先メニュー {0}：接続先読み込み開始".format(str(TabNum)), self.App.一般)
                    # 関数 self.LoadAccess() を CallNum = 2 で呼び出して待機辞書を読み込み、その辞書が有効な値を持っているかの確認情報を取得
                    Selected_AccessName, StandbyDict_SizeOfKB = LoadAccessCallNum2Handler(Edited_AccessName, TabNum)
                    self.LogManager.InsertLOG("接続先 {0} の接続先情報更新完了「接続先名：{1}、サイズ：{2}KB」".format(
                        str(TabNum), str(Selected_AccessName), str(StandbyDict_SizeOfKB)), self.App.一般)  # 待機辞書の情報をログに記録
                # メインフレーム「設定」タブの各「接続先」タブの接続先選択プルダウンで選択していた接続先名が接続先リストに存在する場合
                elif ValidateAndSelectAccessNameIsTrue:
                    self.LogManager.InsertLOG("接続先メニュー {0}：接続先読み込み開始".format(str(TabNum)), self.App.一般)
                    # 関数 self.LoadAccess() を CallNum = 2 で呼び出して待機辞書を読み込み、その辞書が有効な値を持っているかの確認情報を取得
                    Selected_AccessName, StandbyDict_SizeOfKB = LoadAccessCallNum2Handler(Available_AccessName, TabNum)
                    self.LogManager.InsertLOG("接続先 {0} の接続先情報更新完了「接続先名：{1}、サイズ：{2}KB」".format(
                        str(TabNum), str(Selected_AccessName), str(StandbyDict_SizeOfKB)), self.App.一般)  # 待機辞書の情報をログに記録

        # アプリケーション初期化（起動）の場合、
        # またはメインフレーム「接続先編集」タブの「この接続先を削除」または「全ての接続先を消去及び復元」ボタンが押された場合
        # またはユーザーが接続先選択プルダウンの選択項目を変更した場合、またはメインフレーム「接続先編集」タブの「保存」ボタンが押された場合
        # かつメインフレーム「設定」タブの各「接続先」タブのための呼び出しの場合
        if ((not Trace and (not self.App.AppInitialized or self.App.BtnCmd in {"削除", "全消去"})) or \
        (self.App.AppInitialized and Trace and self.App.BtnCmd == "") or (not Trace and self.App.BtnCmd == "保存")) and \
        TabNum is not None:
            """
この条件式は一部、より効率的な記述が可能ですが、ここではあえてこの条件式に到達するまでのこれまでの条件式の評価順序と同じ順序になるように条件式を記述します。
            """
            # メインフレーム「設定」タブの TabNum に対応する「接続先」タブで選択中の接続先名の各種 API キーを非表示にするようフラグを設定
            setattr(self.App, "ShowKeys_{0}".format(str(TabNum)), False)
            self.LoadAPIkeys(TabNum)  # メインフレーム「設定」タブの TabNum に対応する「接続先」タブで選択中の接続先名の各種 API キーを読み込み
            # メインフレーム「設定」タブの API キー設定関連ボタンのためのイテレーション
            for InternalName, Label, StyleName in self.App.APIkey_BtnLabels:
                # メインフレーム「設定」タブの TabNum に対応する「接続先」タブの API キー設定関連ボタンの状態を、
                # 選択中の接続先名の各種 API キーの有無に応じて更新
                # （選択中の接続先名は、これまでの条件式内で読み込んだ待機辞書に記録されているものを、
                # 関数 self.APIkeys_BtnResponder() が呼び出す各種関数が利用）
                self.APIkeys_BtnResponder(CallNum = self.App.副, InternalName = InternalName, TabNum = TabNum)
            if self.App.AppInitialized and Trace and self.App.BtnCmd == "":  # ユーザーが接続先選択プルダウンの選択項目を変更した場合
                self.LogManager.LogSeparator(self.App.一般)

    # メインフレーム「接続先編集」タブの編集メニュー「保存」ボタンに対応する、接続先を保存する関数
    def SaveAccess(self):
        """ この部分を「関数の docstring」と言います。
        メインフレーム「接続先編集」タブの編集メニュー「保存」ボタンに対応する、接続先を保存する関数。

        この関数は、メインフレーム「接続先編集」タブでユーザーが入力した接続先データを検証し、条件を満たしていれば JSON キャッシュファイルに保存します。保存内容
        には、接続先名、接続先の URL、エンドポイント、メソッド、パラメータ、データパスが含まれます。接続先データの検証とは、入力フィールドに一部未入力の項目が
        存在しないかを確認することを指し、未入力の項目が見つかった場合は JSON サンプルの入力フィールドを除く全ての入力フィールドを入力するように促すダイアログを
        表示します。保存先の JSON キャッシュファイルに既に同名の接続先名が存在する場合は、上書きの確認を行い、ユーザーの選択に基づいて処理を続行または中止
        します。保存の成否もダイアログによってユーザーに通知し、最後に関数 self.Init_ExchangePull() を呼び出すことによって関連する GUI ウィジェットと待機
        辞書を更新します。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        # 補助関数：取得したテキストが有効な値を持っているか確認
        def TextHasValidValues(Text):
            """ この部分を「関数の docstring」と言います。
            取得したテキストが有効な値を持っているか確認する関数。

            この関数は、この関数が呼び出されるコンテキストで取得されたテキスト（str）が False と評価される値でないかを確認し、False と評価される値の場合は、
            それをユーザーに知らせるためにシステムログの記録とダイアログの表示を行います。

            Args:
                Text (str): 呼び出し元で GUI ウィジェットから取得したテキスト。

            Returns:
                bool: テキストが有効な値の場合、True。そうでなければ False。
            """
            if not Text:  # 取得した値が無効なものの場合、警告を表示して False を返す
                self.LogManager.InsertLOG("接続先保存中止", self.App.一般)
                self.LogManager.LogSeparator(self.App.一般)
                QMessageBox.warning(self.App, "未入力の項目", "JSON サンプルを除く全ての入力欄を入力してください。")  # ダイアログを表示
                return False  # 処理を終了して False を返す
            return True  # 処理を終了して True を返す（取得した値が有効なものの場合）
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        """ self.SaveAccess() の記述 """
        self.App.BtnCmd = "保存"  # 後続の処理で処理の分岐を行うための属性にボタンコマンドを保存
        ValidValues = []  # リストを初期化
        ExistingData = {}  # 辞書を初期化

        self.LogManager.InsertLOG("接続先保存開始", self.App.一般)
        ValidValues.append(self.GetWidgetVal(Widget = self.App.ConnectionEntries["接続先名"]))  # 入力された接続先名を取得
        ValidValues.append(self.GetWidgetVal(Widget = self.App.ConnectionEntries["接続先URL"]))  # 入力された接続先 URL を取得
        """
ここでは、入力された値を取得する後続のイテレーションに先んじて二つの値を取得しています。これは、これらの値の入力欄として用意される GUI ウィジェット（QLineEdit）
の内部名が接尾辞を持たず、後続のイテレーション内の処理と整合しないためです。また、これらの値のキャッシュファイル内での保存位置が他の値とは異なるという特殊性も、
これらの値を先んじて処理する理由として挙げられます。
        """
        for Value in ValidValues:  # 取得した値の有効性を確認するためのイテレーション
            if not TextHasValidValues(Value):  # 取得した値が無効なものの場合、処理を終了
                return  # 処理を終了

        # 保存する接続先データのデータ構造（辞書）を定義
        New_AccessData = {"domain": ValidValues[1], "endpoints": {},}  # 初期構造を定義

        for PresetIndex, InternalName, DisplayName, DataAddress in self.App.Connections[2:]:  # 入力欄から値を取り出すためのイテレーション
            # 内部名に接尾辞 "_sample" または "_pathtest" が付いている GUI ウィジェット、
            # JSON サンプルの入力欄と「データパスをテスト」ボタンをスキップする条件式
            if any(Check in InternalName for Check in {"_sample", "_pathtest",}):
                continue  # 次のイテレーションを行う指示

            Value = self.GetWidgetVal(Widget = self.App.ConnectionEntries[InternalName])  # 入力欄から値を取得
            if not TextHasValidValues(Value):  # 取得した値が無効なものの場合、処理を終了
                return  # 処理を終了

            # "_" で始まる接尾辞を持つ内部名から必要な情報を取得
            # 内部名を "_" で分割してリストを取得し、エンドポイント名とその要素名を取得
            EndpointName, ElementName_ofEndpoint = InternalName.split("_")
            """
ここでは、メソッド split() が二つの要素を含むリストを返すと分かっているため、結果を代入する先をあらかじめリストが含む要素の数だけ用意しておきます。このようにする
ことで、メソッドが返す複数の要素を含むリストを自動的にアンパックすることができ、リストの要素はそれぞれリスト内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """
            # 保存する接続先データのデータ構造（辞書）の初期構造にエンドポイント名が存在しない場合
            if EndpointName not in New_AccessData["endpoints"]:
                New_AccessData["endpoints"].update(  # 保存する接続先データのデータ構造（辞書）のメソッド update() でデータ構造を追加
                    {EndpointName: {"path": None, "method": None, "params": None, "DataPaths": None,
                        "sample": None,},})  # 値として、型変更可能な None を設定
                """
辞書のメソッド update() は辞書内の特定のデータを更新するためのものです。ここでは､「保存する接続先データのデータ構造（辞書）の初期構造にエンドポイント名が存在
しない場合」に、接続先データを格納するためのデフォルトのデータ構造を追加しています。ここで行っているように、メソッド update() は複数のキーと値のペアを一括で辞書
に追加することができます。ここでは行っている処理を正確に表現するために "追加" と表現していますが、メソッド update() は辞書の既存のキーと値のペアを別のデータで
上書きすることもできます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """

            # 保存する接続先データのデータ構造（辞書）に取得した有効値を格納
            New_AccessData["endpoints"][EndpointName][ElementName_ofEndpoint] = Value

        # キャッシュファイルの読み込みをエラーハンドリング関数で実行
        Result = self.ErrorHandler_ofOpenCacheIncludeRetry("接続先保存", ACCESS_CACHE, "r")
        if isinstance(Result, list):  # キャッシュファイルの読み込みが正常に完了した場合
            ExistingData = Result[0]  # リスト形式で返されたデータから読み込まれたデータを取得
        # キャッシュファイルの読み込み時にエラーが発生した場合、かつファイル消去処理が行われなかったかファイル消去処理に失敗している場合
        elif isinstance(Result, bool) and not Result:
            return  # 処理を終了
        """
ここでは、関数 self.ErrorHandler_ofOpenCacheIncludeRetry() が返す可能性のある None（キャッシュファイルが存在しないことを示す）と True（ファイル消去処理
が成功したことを示す）を条件式で明示的に取り扱っていません。これは、これらの値が返された場合、この関数は初期化済みのローカル変数 ExistingData を使用して引き続き
「接続先データを保存」する処理を続行できるためです。
        """

        if ValidValues[0] in ExistingData:  # 接続先データのキャッシュファイルに既に同名の接続先が存在する場合、警告を表示
            Reply = QMessageBox.question(self.App,  # 選択肢を示すダイアログを表示
                "警告", "「{0}」は既に存在します。上書きしますか？".format(str(ValidValues[0])), QMessageBox.Yes | QMessageBox.No)
            if Reply == QMessageBox.No:  # ユーザーが上書きをキャンセルした場合、処理を終了
                self.LogManager.InsertLOG("接続先保存中止", self.App.一般)
                self.LogManager.LogSeparator(self.App.一般)
                return  # 処理を終了

        # 接続先データのキャッシュファイルに新しい接続先データを追加または更新
        ExistingData[ValidValues[0]] = New_AccessData

        # キャッシュファイルへの書き込みをエラーハンドリング関数で実行
        Result = self.ErrorHandler_ofOpenCacheIncludeRetry("接続先保存", ACCESS_CACHE, "w", WriteData = ExistingData)
        if Result == "書き込み完了":  # キャッシュファイルへの書き込みに成功した場合
            self.LogManager.InsertLOG("接続先保存完了", self.App.一般)
            QMessageBox.information(self.App, "成功", "接続先情報を保存しました。")  # ダイアログを表示
            self.Init_ExchangePull(self.App.EditAccess_Pull)  # 各種プルダウンメニューの選択肢を更新
        elif isinstance(Result, bool):  # キャッシュファイルへの書き込みに失敗した場合、かつ再試行が行われなかったか再試行も失敗している場合
            self.LogManager.InsertLOG("接続先保存失敗", self.App.一般)
            self.LogManager.LogSeparator(self.App.一般)
            QMessageBox.information(self.App, "失敗", "接続先情報を保存できませんでした。")  # ダイアログを表示
            return  # 処理を終了
        """
ここでは、関数 self.ErrorHandler_ofOpenCacheIncludeRetry() が返す可能性のある None（キャッシュファイルが存在しないことを示す）を条件式で明示的に取り
扱っていません。これは、キャッシュファイルへの書き込み時にはファイルが存在しているかに関わらず書き込み処理を行うためです。
        """

        self.App.BtnCmd = ""  # 処理分岐用属性のボタンコマンドをクリア

    # メインフレーム「接続先編集」タブの編集メニュー「この接続先を削除」ボタンに対応する、接続先を削除する関数
    def DeleteSelectedAccess(self):
        """ この部分を「関数の docstring」と言います。
        メインフレーム「接続先編集」タブの編集メニュー「この接続先を削除」ボタンに対応する、接続先を削除する関数。

        この関数は、メインフレーム「接続先編集」タブの編集メニューの接続先選択プルダウン（EditAccess_Pull）でユーザーが選択した接続先を、JSON キャッシュ
        ファイルから削除します。削除前にユーザーに削除の確認を行い、確認された場合にのみ削除を実行します。削除処理後、関数 self.Init_ExchangePull() を呼び
        出すことによって関連する GUI ウィジェットと待機辞書を更新します。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        self.App.BtnCmd = "削除"  # 後続の処理で処理の分岐を行うための属性にボタンコマンドを保存
        ExistingData = {}  # 辞書を初期化

        self.LogManager.InsertLOG("接続先削除開始", self.App.一般)
        # メインフレーム「接続先編集」タブの編集メニューの接続先選択プルダウンで選択中の接続先を取得
        Selected_AccessName = self.GetWidgetVal(Widget = self.App.EditAccess_Pull)

        QMessageBox.information(self.App,  # ダイアログを表示
            "注意", "「{0}」の API キーをアプリケーションに保存している場合は、そちらを先に削除してください。".format(str(Selected_AccessName)))

        # キャッシュファイルの読み込みをエラーハンドリング関数で実行
        Result = self.ErrorHandler_ofOpenCacheIncludeRetry("接続先削除", ACCESS_CACHE, "r")
        if isinstance(Result, list):  # キャッシュファイルの読み込みが正常に完了した場合
            ExistingData = Result[0]  # リスト形式で返されたデータから読み込まれたデータを取得
        # キャッシュファイルが存在しないことを示す None が返された場合、またはキャッシュファイルの読み込み時にエラーが発生した場合
        elif Result is None or isinstance(Result, bool):
            return  # 処理を終了
        """
ここでは、関数 self.ErrorHandler_ofOpenCacheIncludeRetry() が返す可能性のある bool 値（ファイル消去処理を行った結果を示す）の内容に関わらず、結果が
bool 値の場合は処理を終了します。これは、ファイル消去処理を行わなければならない状況では、消去が成功しても失敗しても、この関数の責務である「選択中の接続先の削除」
を行う後続の通常の処理を行えないためです。
        """

        # メインフレーム「接続先編集」タブの編集メニューの接続先選択プルダウンで選択中の接続先がファイルに存在するか確認
        if Selected_AccessName in ExistingData:
            # 削除前にユーザーに削除の確認を行う
            Reply = QMessageBox.question(self.App,  # 選択肢を示すダイアログを表示（デフォルトで No にフォーカス）
                "削除の確認", "「{0}」を削除しますか？".format(str(Selected_AccessName)), QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if Reply == QMessageBox.Yes:  # ユーザーが削除の確認を行った場合
                del ExistingData[Selected_AccessName]  # 読み込んだ接続先データのキャッシュファイルのデータから選択中の接続先を削除
                """
ここでは、読み込んだ接続先データのキャッシュファイルのデータに辞書のキーとして存在する、メインフレーム「接続先編集」タブの編集メニューの接続先選択プルダウンで選択
中の接続先名を del ステートメントによって削除しています。この処理により、キーに対応する値、この場合は接続先名に関連する全てのデータが読み込んだデータから削除され
ます。そして後続の処理でこの処理後のデータを接続先データのキャッシュファイルに書き戻すことで、この関数の目的が果たされます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """
            elif Reply == QMessageBox.No:  # ユーザーが削除の確認をキャンセルした場合
                self.LogManager.InsertLOG("接続先削除中止", self.App.一般)
                self.LogManager.LogSeparator(self.App.一般)
                QMessageBox.information(self.App, "キャンセル", "削除処理をキャンセルしました。")  # ダイアログを表示
                return  # 処理を終了
        else:  # メインフレーム「接続先編集」タブの編集メニューの接続先選択プルダウンで選択中の接続先がファイルに存在しない場合
            self.LogManager.InsertLOG("接続先削除：{0} 該当データなし".format(str(Selected_AccessName)), self.App.一般)
            self.LogManager.LogSeparator(self.App.一般)
            QMessageBox.warning(self.App, "警告", "「{0}」がキャッシュファイルに存在しません。".format(
                str(Selected_AccessName)))  # ダイアログを表示
            return  # 処理を終了

        # キャッシュファイルへの書き込みをエラーハンドリング関数で実行
        Result = self.ErrorHandler_ofOpenCacheIncludeRetry("接続先削除", ACCESS_CACHE, "w", WriteData = ExistingData)
        if Result == "書き込み完了":  # キャッシュファイルへの書き込みに成功した場合
            self.LogManager.InsertLOG("接続先削除完了", self.App.一般)
            # ダイアログを表示
            QMessageBox.information(self.App, "成功", "「{0}」をキャッシュファイルから削除しました。".format(str(Selected_AccessName)))
            self.Init_ExchangePull(self.App.EditAccess_Pull)  # 各種プルダウンメニューの選択肢を更新
        # キャッシュファイルへの書き込みに失敗した場合、かつファイル消去処理に成功して再試行が行われなかった場合
        elif isinstance(Result, bool) and Result:
            self.LogManager.InsertLOG("接続先削除完了", self.App.一般)
            self.Init_ExchangePull(self.App.EditAccess_Pull)  # 各種プルダウンメニューの選択肢を更新
        # キャッシュファイルへの書き込みに失敗した場合、かつファイル消去処理が行われなかったかファイル消去処理に失敗している場合
        elif isinstance(Result, bool) and not Result:
            self.LogManager.InsertLOG("接続先削除失敗", self.App.一般)
            self.LogManager.LogSeparator(self.App.一般)
        """
ここでは、関数 self.ErrorHandler_ofOpenCacheIncludeRetry() が返す可能性のある None（キャッシュファイルが存在しないことを示す）を条件式で明示的に取り
扱っていません。これは、キャッシュファイルへの書き込み時にはファイルが存在しているかに関わらず書き込み処理を行うためです。
        """

        self.App.BtnCmd = ""  # 処理分岐用属性のボタンコマンドをクリア

    # メインフレーム「接続先編集」タブの編集メニュー「全ての接続先を消去及び復元」ボタンに対応する、全ての接続先を消去する関数
    def DeleteAllAccess(self):
        """ この部分を「関数の docstring」と言います。
        メインフレーム「接続先編集」タブの編集メニュー「全ての接続先を消去及び復元」ボタンに対応する、全ての接続先を消去する関数。

        この関数は、メインフレーム「接続先編集」タブの編集メニュー「全ての接続先を消去及び復元」ボタンが押された際の処理を行います。実際に消去処理を行う前に、
        ダイアログを表示してユーザーに全ての接続先データを消去することの確認を行います。確認された場合、保存されている接続先データのキャッシュファイルを消去
        します。消去処理では、ファイル内容の削除ではなく、ファイル自体の消去を行います。ユーザーが消去処理をキャンセルした場合、処理をキャンセルしたことを通知
        するダイアログを表示し、ファイルの消去試行時に既にファイルが存在しない場合、失敗を通知するダイアログを表示します。消去処理後、関数
        self.Init_ExchangePull() を呼び出すことによって関連する GUI ウィジェットと待機辞書を更新します。このとき、同関数による処理の中で接続先データの
        キャッシュファイルが存在していないことが検知され、デフォルトで定義されている接続先データを含む新しいキャッシュファイルが作成されます。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        self.App.BtnCmd = "全消去"  # 後続の処理で処理の分岐を行うための属性にボタンコマンドを保存

        self.LogManager.InsertLOG("全接続先消去開始", self.App.一般)
        QMessageBox.information(self.App,  # ダイアログを表示
            "注意", "手動で追加した復元されない接続先の API キーをアプリケーションに保存している場合は、そちらを先に削除してください。")
        # ユーザーに全ての接続先データを消去することを確認
        Reply = QMessageBox.question(self.App,  # 選択肢を示すダイアログを表示（デフォルトで No にフォーカス）
            "消去の確認", "全ての接続先情報を消去しますか？", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if Reply == QMessageBox.Yes:  # ユーザーが消去の確認を行った場合
            if os.path.exists(ACCESS_CACHE):  # 接続先データのキャッシュファイルが存在する場合、消去処理を実行
                os.remove(ACCESS_CACHE)  # 接続先データのキャッシュファイルを消去
                self.LogManager.InsertLOG("全接続先消去完了", self.App.一般)
                QMessageBox.information(self.App, "成功", "全ての接続先を消去しました。")  # ダイアログを表示
            else:  # 接続先データのキャッシュファイルが存在しない場合
                self.LogManager.InsertLOG("全接続先消去：キャッシュファイルなし", self.App.一般)
                QMessageBox.information(self.App, "失敗", "接続先情報のキャッシュファイルが存在しません。")  # ダイアログを表示
        elif Reply == QMessageBox.No:  # ユーザーが消去の確認をキャンセルした場合
            self.LogManager.InsertLOG("全接続先消去中止", self.App.一般)
            self.LogManager.LogSeparator(self.App.一般)
            QMessageBox.information(self.App, "キャンセル", "消去処理をキャンセルしました。")  # ダイアログを表示
            return  # 処理を終了

        self.Init_ExchangePull(self.App.EditAccess_Pull)  # 各種プルダウンメニューの選択肢を更新
        self.App.BtnCmd = ""  # 処理分岐用属性のボタンコマンドをクリア
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # メインフレーム「接続先編集」タブで各種接続先の API が返す JSON データのサンプルに対して入力されたデータパスをテストする関数
    def PathTest(self, ReCall = False):
        """ この部分を「関数の docstring」と言います。
        メインフレーム「接続先編集」タブで各種接続先の API が返す JSON データのサンプルに対して入力されたデータパスをテストする関数。

        この関数は、メインフレーム「接続先編集」タブの「データパスをテスト」ボタンが押された際の処理を行います。データパスとは、各種接続先の API が返す JSON
        データからこのアプリケーションに必要なデータを取り出すためのパスを指します。API が返す JSON データは、接続先（取引所）によってデータの構造が異なります。
        このため、このアプリケーションではそれぞれの接続先からデータを取り出すためのデータパスを事前に定義し、これを用いてデータを抽出し、実際にアプリケーション
        が使用するデータ構造に正規化します。この関数は、このデータパスを各種接続先の API ドキュメントに記載されている JSON サンプルでテストするためのものです。
        このとき、実際に API に接続する処理は行わず、処理はアプリケーション内で完結します。テストはまず、どのエンドポイントの「データパスをテスト」ボタンが
        押されたのかを識別するために、ボタンのオブジェクト名を取得します。このオブジェクト名は、ボタンが定義される際にメソッド setObjectName() によって事前に
        定義されている必要があります。このとき、オブジェクト名は「エンドポイント名_pathtest」の形式を取る必要があります。この関数では、取得したオブジェクト名
        からエンドポイント名を特定し、テストに必要なデータが入力されている GUI ウィジェット（QTextEdit）の属性名を作成して、入力されたデータを取得してテストを
        行います。テストは実際のエンジンにおける、レスポンスデータを正規化する関数 self.SubFunctions[n].ExtractAndFormatData() で行います。この関数は
        バックグラウンドスレッドで動作するため、テストもバックグラウンドスレッドで行います。ただし、テストを行うバックグラウンドスレッドはテスト用に用意される
        もののため、仮にエンジンが運用されている状況であっても、テスト処理が実際の運用状況に影響を与えることはありません。バックグラウンドスレッドでのテスト結果
        は、完了し次第 AppClass（self.App）属性の専用の属性に保存され、テストが完了したことを通知するシグナルが発行されます。このシグナルは、バックグラウンド
        スレッドからメインスレッドに向けて発行されるシグナルをハンドルする関数 self.SubThreadProcessHandler() によって処理され、当関数が引数 ReCall に
        True を設定された状態で呼び出されます。この関数は引数 ReCall が True のとき、テスト結果を専用の属性から取り出し、ダイアログに表示する処理を行って、
        テスト結果をユーザーに通知すると共に処理を完了します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            ReCall (bool, optional):
                バックグラウンドスレッドの処理をトリガーした後、処理が完了した際の再呼び出しを識別するフラグ。デフォルトは False。

        Returns:
            なし。
        """
        if not ReCall:  # 「データパスをテスト」ボタンが押されたことによる呼び出しの場合
            BtnName = self.App.sender().objectName()  # 「データパスをテスト」ボタンのオブジェクト名を取得
            EndpointName = BtnName.replace("_pathtest", "")  # オブジェクト名から接尾辞を除去してエンドポイント名を取得
            DataPathsEntName = BtnName.replace("_pathtest", "_DataPaths")  # オブジェクト名の接尾辞を変更してデータパス入力欄の属性名を設定
            JSON_EntName = BtnName.replace("_pathtest", "_sample")  # オブジェクト名の接尾辞を変更して JSON サンプル入力欄の属性名を設定

            DataPaths = self.GetWidgetVal(Widget = self.App.ConnectionEntries[DataPathsEntName])  # データパス入力欄からデータパスを取得
            Data = self.GetWidgetVal(Widget = self.App.ConnectionEntries[JSON_EntName])  # JSON サンプル入力欄から JSON サンプルを取得

            FullWidthAlphanumeric = r"[\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A]"  # 全角英数を検出するための正規表現
            if bool(re.search(FullWidthAlphanumeric, DataPaths)):  # データパスに全角英数が含まれている場合、ダイアログを表示
                QMessageBox.information(self.App,  # ダイアログを表示
                    "全角英数を検出", "データパスに全角英数が含まれています。期待値にはこれを使用できませんので注意してください。")

            # 取得した各種値をシグナルに含めてレスポンスデータを正規化する関数をトリガーする
            # （データパスをテストするための呼び出しであることを示すフラグを有効化）
            # （シグナルのデータ型は SubThreadFunctionsClass の関数 ExtractAndFormatData() に対応、オプショナルな引数の指定も必須）
            self.PathTestSignal.emit(str(EndpointName), str(DataPaths), str(Data), bool(True))
            # レスポンスデータを正規化する関数をトリガーしたことを TaskMonitoringThreadClass に通知するシグナルを発行
            # （シグナルのデータ型は TaskMonitoringThreadClass の関数 AddTask() の引数に対応）
            self.AddTaskSignal.emit(int(0), str(self.App.TaskNames["PathTest"]))
            """ メソッド emit() でシグナルを発行する際、シグナルに含めるデータ型には細心の注意を要します。 """
            """ シグナルとスロットに関する解説は、このクラスの docstring の後半をご確認ください。 """
        elif ReCall:  # トリガーした処理の完了に伴う呼び出しの場合
            if hasattr(self.App, "StructuredData_ofPathTest"):  # AppClass（self.App）属性にテスト結果専用の属性が存在しているか確認
                Message = "値の取得結果を確認してください。{0}{0}{0}".format(self.LF)  # テスト結果を示すためのテキストを準備
                Message += self.MessageStructure(self.App.StructuredData_ofPathTest)  # テスト結果をテキスト化
                self.Dialog(Title = "テスト結果", Text = Message)  # カスタムダイアログにテキスト化したテスト結果を表示
                delattr(self.App, "StructuredData_ofPathTest")  # AppClass（self.App）属性のテスト結果専用の属性を消去

            self.LogManager.LogSeparator(self.App.一般)
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # メインフレーム「設定」タブの API キー設定関連ボタンの処理と状態を管理する関数
    def APIkeys_BtnResponder(self, CallNum = 1, InternalName = None, TabNum = None):
        """ この部分を「関数の docstring」と言います。
        メインフレーム「設定」タブの API キー設定関連ボタンの処理と状態を管理する関数。

        この関数は、ボタンのクリックまたは状態更新の種別を識別するための引数 CallNum、ボタンの内部名を示す引数 InternalName、及びメインフレーム「設定」タブの
        「接続先」タブを識別するための引数 TabNum に基づいて、各ボタンに対応する関数の呼び出しを適切に行います。各ボタンは、各種 API キーの表示／非表示、
        登録／変更、接続テスト、削除に対応しています。ボタンのクリックまたは状態更新の種別を識別するための引数 CallNum は、デフォルトでクリック時の処理を行う値
        1 に設定されています。1 以外であれば、この関数自体はどのような値であってもボタンの状態更新処理を行いますが、こちらの処理の呼び出しを行う場合、この関数が
        呼び出す各ボタンに対応する関数は明示的に 2 を要求します。この関数は引数なしで呼び出された場合、全ての引数にボタンクリック時の処理を行う際のデフォルト値を
        割り当て、必要な情報はボタンのオブジェクト名から取得します。このオブジェクト名は、ボタンが定義される際にメソッド setObjectName() によって事前に定義
        されている必要があります。このとき、オブジェクト名は「InternalName_TabNum」の形式を取る必要があります。これによって、ボタンクリック時の処理を行う際に
        必要となる情報を補完することが可能となり、シグナルへの接続時に引数を指定しない接続形式を採用できます。これ以外の呼び出し、即ちボタンクリックによる呼び
        出しではなく、アプリケーションの他の部分からの、ボタンの状態更新処理を行う目的での呼び出しの場合は、全ての引数が正しく指定される必要があります。ボタンの
        状態更新処理とは、ボタンに表示するテキストやクリックの可否を状況に合わせて更新することを言います。
        処理の各過程に対応するログが LogManagerClass によって LogText_0 に記録されます。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            CallNum (int, optional): 当該ボタンが押されたのか、またはそのボタンの状態を変更するのかを識別する整数値（1 または 2）。デフォルトは 1。
            InternalName (str, optional): ボタンの内部名。この名前に基づいて対応する関数を呼び出す。デフォルトは None。
            TabNum (int, optional):
                メインフレーム「設定」タブの「接続先」タブを識別する整数値（1 〜 5）。ユーザーが現在操作しているタブを指す。デフォルトは None。

        Returns:
            なし。
        """
        if CallNum == self.App.主:  # ボタンがクリックされた場合、ボタンのオブジェクト名を取得して必要な情報を取得
            BtnName = self.App.sender().objectName()  # クリックされたボタンのオブジェクト名を取得
            InternalName, TabNum = BtnName.split("_") if "_" in BtnName else (None, None,)  # オブジェクト名を "_" で分割して必要な情報を取得
            """
ここでは、メソッド split() が二つの要素を含むリストを返すと分かっているため、結果を代入する先をあらかじめリストが含む要素の数だけ用意しておきます。このようにする
ことで、メソッドが返す複数の要素を含むリストを自動的にアンパックすることができ、リストの要素はそれぞれリスト内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

        if InternalName == "ShowKeysBtn":  # API キー及び API シークレットを表示／伏せるボタンの場合
            self.ShowKeysBtn(CallNum, TabNum)  # 対応する関数の呼び出し
        elif InternalName == "ManageKeysBtn":  # API キー及び API シークレットの登録／変更ボタンの場合
            self.ManageKeysBtn(CallNum, TabNum)  # 対応する関数の呼び出し
        elif InternalName == "TestAccessBtn":  # 接続テストボタンの場合
            self.TestAccessBtn(CallNum, TabNum)  # 対応する関数の呼び出し
        elif InternalName == "ClearKeysBtn":  # API キー及び API シークレットを削除するボタンの場合
            self.ClearKeysBtn(CallNum, TabNum)  # 対応する関数の呼び出し

        if CallNum == self.App.主:  # ボタンがクリックされた場合、ログテキストエリアに区切り線を挿入
            self.LogManager.LogSeparator(self.App.一般)

    # SubThreadFunctionsClass の処理完了シグナルをハンドルする関数
    @pyqtSlot(int, str)  # シグナルに対するスロットであることを示すデコレータ
    def SubThreadProcessHandler(self, ThreadID, TaskName):
        """ この部分を「関数の docstring」と言います。
        SubThreadFunctionsClass の処理完了シグナルをハンドルする関数。

        この関数は、この関数が属す「メインスレッドで動作するこのクラス MainThreadFunctionsClass のインスタンス MainFunctions（AppClass（self.App）の
        属性）」が持つバックグラウンドスレッドの各インスタンス self.SubFunctionsThread[n] の非同期イベントループで動作する SubThreadFunctionsClass の
        各インスタンス self.SubFunctions[n] からの処理完了シグナルに接続されるスロットとして設計されています。バックグラウンドスレッドは複数存在し、シグナル
        に含まれる ThreadID を基に、シグナルがどのスレッドからのものか、またそのスレッドはどのエンジンのものかを識別します。識別後、シグナルに含まれるタスク名
        を基に適切な「後続処理を行う関数」を呼び出します。特定のタスク名の場合、そのシグナルは特定の ThreadID 固有のものであるため、直接タスク名を基に「後続
        処理を行う関数」を呼び出します。この関数は、メインスレッドとバックグラウンドスレッドの処理のコネクタとして機能します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            ThreadID (int): SubThreadFunctionsClass のインスタンスが属しているバックグラウンドスレッドの一意な番号。整数値。
            TaskName (str): バックグラウンドスレッドでのデータ処理が完了したタスクの名前。

        Returns:
            なし。
        """
        # 処理が完了したことを TaskMonitoringThreadClass の関数 TaskCompleted() に通知するシグナルを発行
        # （シグナルのデータ型は TaskMonitoringThreadClass の関数 TaskCompleted() に対応、オプショナルな引数の指定も必須）
        self.TaskCompletedSignal.emit(int(ThreadID), str(TaskName), bool(False))
        """ メソッド emit() でシグナルを発行する際、シグナルに含めるデータ型には細心の注意を要します。 """
        """ シグナルとスロットに関する解説は、このクラスの docstring の後半をご確認ください。 """
        self.LogManager.InsertBackLOG(ThreadID, Completed = True)  # 非同期処理中に蓄積されたログをログテキストエリア（QTextEdit）に挿入
        EngineNum = IntegrationOfThreadIDtoEngineNum(ThreadID)  # ThreadID をエンジン番号に変換

        # 特定のタスク名の場合
        if TaskName == self.App.TaskNames["PathTest"]:
            self.PathTest(ReCall = True)  # 処理結果を処理
        # ThreadID を基にバックグラウンドスレッドを識別する場合
        elif EngineNum == 0:  # 特定の GUI 応答用のテストエンジンの場合
            pass
        elif EngineNum > 0:  # メインフレーム「設定」タブの各「接続先」タブから運転開始されたエンジンの場合
            pass
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

# アプリケーションのデータ処理に必要な関数をまとめたクラス
class SubThreadFunctionsClass(QObject):  # QObject を継承（PyQt フレームワークのシグナルとスロットのメカニズムを使用するため）
    """ この部分を「クラスの docstring」と言います。
    このクラスは、アプリケーションの GUI ウィジェットへのユーザーの入力に伴って発生するデータ処理タスクを管理する役割を持ちます。このクラスの全ての関数は
    バックグラウンドスレッド（QThread）で動作することを前提に設計されています。このため、このクラスのインスタンスはバックグラウンドスレッド（QThread）に移動
    されている必要があります。これが行われることで、アプリケーションはメインスレッドで行うべきではないデータ処理タスクをバックグラウンドスレッドで行うことが可能と
    なります。もしメインスレッドでデータ処理タスクが実行されると、メインスレッドは開始されたデータ処理タスクに専念することになり、もしそのタスクが扱うデータ量が
    膨大な場合、メインスレッドはそのデータ処理タスクを終えるのに多くの時間を要することになります。または、データ処理タスクが頻繁にメインスレッドで実行されると、
    メインスレッドはその都度データ処理タスクに専念することになります。これらの状況は、本来メインスレッドが取り扱うべきユーザーのアプリケーションへの入力に対する
    応答処理を阻害します。これは、各スレッドは一度に一つの処理しか実行できないという原則により発生する問題です。アプリケーションの運用においてこれらの状況が顕著に
    なった場合、これはユーザーから見ると、アプリケーションがフリーズしているか、即座に反応しないように見え、ユーザーエクスペリエンスを著しく低下させます。従って
    プログラミングの現場では、データ処理タスクはバックグラウンドスレッドで行うことが推奨されています。またバックグラウンドスレッドには、直接アプリケーションの
    GUI ウィジェットを操作できないという制約があります。これは多くのプログラミング言語に共通するもので、主にスレッドセーフティを欠いてしまうことが理由として挙げ
    られます。スレッドセーフティ、またはスレッドセーフとは、スレッド間通信の安全な同期状態のことを指し、この安全性の確保はアプリケーションの安定性や正常な動作
    といった、アプリケーションの信頼性に直結する課題です。多くの GUI フレームワークは、GUI ウィジェットが一度に一つのスレッドからのみアクセスされることを前提
    として設計されています。これは通常、メインスレッドまたは GUI スレッドと呼ばれるものです。バックグラウンドスレッドから GUI ウィジェットに直接アクセスすると、
    アクセスの競合やデータの競合、整合性の欠如など、スレッドセーフでないことに起因する問題が発生する可能性があります。また、スレッドセーフでない状態は、複数の
    スレッドが同時に GUI ウィジェットを更新しようと試みる可能性があり、この場合、最終的にどのスレッドが GUI ウィジェットの状態を決定するのかが予測できなくなり、
    予期しないバグやアプリケーションのクラッシュを引き起こす可能性があります。このため、このクラスの関数は全て、このスレッドセーフティを念頭に設計されています。
    このクラスのコンストラクタは初期化時に GUI ウィジェットの参照を含む AppClass のインスタンスを要求しますが、このクラスでこのインスタンスを必要とするのは、
    メインスレッドへのデータの受け渡しを効率的に行うためです。従って、このクラスの全ての関数は、このインスタンスを使用した AppClass 属性の GUI ウィジェットの
    操作といった処理は行いません。
    ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。

    -----------------------------------------------------------------------------------------------------------------------------------

    このクラスでは、MainThreadFunctionsClass または TaskMonitoringThreadClass に処理を開始、または完了したことを通知するためのシグナルを定義しています。
    これは PyQt フレームワークのシグナルとスロットのメカニズムを利用した「バックグラウンドスレッド（QThread）の非同期データ処理タスクをメインスレッドと同期」
    するためのものです。このシグナルを介して、メインスレッドはバックグラウンドスレッド（QThread）のデータ処理タスクの状態を把握することができ、必要に応じて処理の
    状況をユーザーにフィードバックすることができます。ただし、バックグラウンドスレッド（QThread）のデータ処理タスクに要している時間が長時間に及んでいる場合、
    これを検知するのは TaskMonitoringThreadClass の役割であり、検知した同クラスは直接 LogManagerClass を通じてユーザーへのフィードバックを行います。
    従ってこの場合、メインスレッドは GUI ウィジェットの更新のみを行います。
    ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。

    -----------------------------------------------------------------------------------------------------------------------------------

    【スレッドセーフティについての追加解説 by ChatGPT 4】
    スレッドセーフティとは、複数のスレッドが同時にプログラムの一部を実行しても、正しい結果が保証され、予期しない問題が起こらないことを意味します。これが重要
    なのは、異なるスレッドが同じデータに同時にアクセスした場合、データが不正確になったり、プログラムが予期しない方法で振る舞う可能性があるためです。例えば、
    バックグラウンドスレッドでデータを更新している最中に、メインスレッドがそのデータを読み込もうとすると、更新途中の不完全なデータを読み取ってしまう可能性があり
    ます。このような問題を防ぐために、スレッドセーフなプログラミング技法が必要です。

    【シグナルとスロットについての追加解説 by ChatGPT 4】
    シグナルとスロットは、PyQt フレームワークで用いられるプログラミングパターンです。これを利用することで、イベントが発生したとき、例えばボタンが押されたときに、
    特定のコード = スロットが実行されるように設定できます。シグナルはイベントの発生を通知し、スロットはその通知を受け取って何かしらのアクションを行う関数です。
    このメカニズムにより、バックグラウンドスレッドで発生した変更やイベントをメインスレッドに伝えることができ、アプリケーションがユーザーの入力に対して適切に応答
    することが可能になります。
    """
    # シグナルを定義（シグナルを発行する際はトリガーする関数の引数がオプショナルな場合でも値の指定が必要）
    # クラス内で発生するイベントを通知するシグナル
    # 処理が完了したことを ThreadID とタスク名で通知するシグナル（MainThreadFunctionsClass 用）
    # （int は関数 SubThreadProcessHandler() の引数 ThreadID に対応。str は TaskName に対応）
    TaskCompletedSignal_1 = pyqtSignal(int, str)  # int は ThreadID

    # 処理を開始したことを ThreadID とタスク名で通知するシグナル（TaskMonitoringThreadClass 用）
    # （int は関数 AddTask() の引数 ThreadID に対応。str は TaskName に対応）
    TaskStartedSignal = pyqtSignal(int, str)  # int は ThreadID
    # 処理が完了したことを ThreadID とタスク名で通知するシグナル（TaskMonitoringThreadClass 用）
    # （int は関数 TaskCompleted() の引数 ThreadID に対応。str は TaskName に対応。bool は CallerIsSubThread に対応）
    TaskCompletedSignal_2 = pyqtSignal(int, str, bool)  # int は ThreadID

    # SubThreadFunctionsClass を初期化する関数（コンストラクタ）
    def __init__(self, ThreadID, AppInstance):
        """ この部分を「関数の docstring」と言います。
        SubThreadFunctionsClass を初期化する関数。

        この初期化関数は、SubThreadFunctionsClass の新しいインスタンスを作成します。引数 ThreadID はクラスのインスタンスが属しているバックグラウンド
        スレッドの一意な番号を指します。AppInstance は AppClass のインスタンスを指し、このクラス内で使用されます。ただしこのクラス内から AppInstance 内の
        GUI ウィジェットを操作することは禁止されています。これはこのクラスがバックグラウンドスレッド（非同期イベントループ）で動作し、PyQt フレームワークに
        おいて GUI ウィジェットの操作はメインスレッド（MainThreadFunctionsClass）からのみ行うことが推奨されているためです。バックグラウンドスレッドから
        GUI ウィジェットの操作を試みた場合、予期せぬ問題を引き起こす可能性があります。このため、AppInstance は、その内部で定義されている「データ処理に必要な
        変数」へのアクセス、または「データ処理の結果の格納」にのみ使用されます。また LogManagerClass のシングルトンインスタンスを self.LogManager 属性に
        設定し、ログ管理機能を準備します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            ThreadID (int): クラスのインスタンスが属しているバックグラウンドスレッドの一意な番号。整数値。
            AppInstance: AppClass のインスタンス。SubThreadFunctionsClass が操作する AppClass のインスタンスを指定。

        Returns:
            なし。
        """
        # QObject の初期化
        super(SubThreadFunctionsClass, self).__init__()  # データ処理専用スレッドなため、parent は省略（デフォルト値：None）

        # クラス（self）属性を定義
        self.LogManager, self.LF = LogManagerClass.GetInstance()  # LogManagerClass のシングルトンインスタンスと OS 依存改行文字を取得
        """
ここでは、関数が複数の要素を含むタプルを返すと分かっているため、関数の返り値を代入する先をあらかじめタプルが含む要素の数だけ用意しておきます。このようにすること
で、関数が返す複数の要素を含むタプルを自動的にアンパックすることができ、タプルの要素はそれぞれタプル内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
        """
        self.ThreadID = ThreadID  # クラスのインスタンスが属しているバックグラウンドスレッドの一意な番号を保存
        self.EngineNum = IntegrationOfThreadIDtoEngineNum(ThreadID)  # クラスのインスタンスが属しているエンジンの番号を取得して保存
        self.App = AppInstance  # AppClass のインスタンスを定義
        self.HttpClient = httpx.AsyncClient()  # 非同期 HTTP クライアントのインスタンスを作成
        self.ProcessCounter = 0  # 処理中に一意な番号が必要となる場合に番号を保持する変数を定義
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 処理中に一意な番号が必要となる場合に番号を返す関数
    def ProcessCounting(self, Reset = False):
        """ この部分を「関数の docstring」と言います。
        処理中に一意な番号が必要となる場合に番号を返す関数。

        この関数は、処理中に一意な番号が必要となる場合に番号を返します。番号を取得する際には引数を必要としません。番号が必要な処理が終了した場合、適切に引数
        Reset が True の状態で呼び出される必要があります。または、番号を保持する変数 self.ProcessCounter を直接 0 に設定する必要があります。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Reset (bool, optional): 番号をリセットするフラグ。デフォルトは False。
        
        Returns:
            int: 引数 Reset を指定しない場合または False を指定する場合、一意な番号。True を指定する場合、なし。
        """
        if not Reset:  # リセットフラグが無効な場合
            self.ProcessCounter += 1  # 処理中に一意な番号が必要となる場合に番号を保持する変数の数値に 1 を加算
            return self.ProcessCounter  # 1 を加算した数値を返す
        else:  # リセットフラグが有効な場合
            self.ProcessCounter = 0  # 処理中に一意な番号が必要となる場合に番号を保持する変数に 0 を代入してリセット
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # XML 形式に変換するために用意された辞書を XML 形式に変換する関数
    def DictToXML(self, RootTag, BaseDict, TextType, LogSection):
        """ この部分を「関数の docstring」と言います。
        XML 形式に変換するために用意された辞書を XML 形式に変換する関数。

        この関数は、XML ツリーの作成処理を行います。ルートタグ名を基にルート要素を作成し、渡された辞書を基に階層的な XML 要素を作成します。辞書の各キーと値に
        対して適切な XML 子要素を作成するために、ジェネレーターとスタックを用いた効率的な処理を行います。最終的に、作成した XML ツリーを bytes 型の文字列に
        変換し、完成した XML データを返します。ただし、引数 TextType に "unicode" が指定されると、返り値は文字列型（str）となります。ネストされた辞書に
        対しては、ネストに用いられているキーをタグ名として使用し、その値である辞書を再帰的に処理し、子要素を追加します。辞書のキーに適切にタグ名が使用されて
        いれば、この関数は正しい形式の XML データを作成します。また、リスト型の値に対しては、リストが格納されているキーをタグ名として使用し、リストの各要素を
        そのタグ名を用いてマークアップします。リスト内の要素が辞書型であれば、その辞書を持つ新しい子要素を作成し、再帰的に処理します。リスト内の要素が辞書型では
        ない場合、その要素をテキストとして持つ子要素を作成します。辞書のキーに特定の形式「タグ名&属性名=属性値」が含まれている場合、そのキーを分割してタグ名と
        属性の辞書を作成し、タグ名を持つ子要素に対して属性を設定します。さらに、キーが接尾辞「&attr」を持つ場合、そのキーと値を属性名及び属性値として現在の要素
        に設定します。また "attr" キーの値としてリストを使用して属性を指定することも可能です。リスト内の要素が「属性名=属性値」という形式の文字列、または
        （属性名, 属性値）という形式のタプルの場合、これらを正しく属性として取り扱い、現在の要素に設定します。いずれの方法でも一つの要素に対して複数の属性指定を
        行うことが可能です。ルート要素に属性を設定する場合は「ルートタグ名&属性名=属性値」の形式で渡されることでこれを正しく処理します。また、引数 BaseDict の
        キーの先頭に一意性を保証する番号を振ることが可能です。これは例えば「番号>タグ名&属性名=属性値」のように、">" を使用して設定可能です。これらの機能により、
        ネストされた辞書やリストを含むデータも適切に階層的な XML 構造に変換し、最終的に正しい形式の XML データを作成します。この関数は関数
        self.ExecuteAPIrequest() から敏感情報を含むデータを渡される可能性があるため、この関数と関数内の全ての補助関数に finally ブロックを設け、変数を明示
        的に None にし、ガベージコレクタに早期にメモリ回収させています。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            RootTag (str): ルート要素のタグ名。属性を設定する場合は「ルートタグ名&属性名=属性値」形式。
            BaseDict (dict): XML 形式に変換する辞書の参照。
            TextType (str): エンコーディングに使用する文字コード。
            LogSection (str): 現在の処理内容を示す文字列｡「LogSection：ログ内容」の形式でシステムログを記録するためのもの。

        Returns:
            bytes or False: XML データ。正常に処理ができない場合、False。

        Usage:
            Input:
                RootTag = "Order&Attr1=Val1&Attr2=Val2"
                BaseDict = {
                    "OrderID&attr=12345": "12345",
                    "Customer&Name=JohnDoe&Email=john.doe@example.com": {
                        "Name": "John Doe",
                        "Email": "john.doe@example.com",
                    },
                    "Attributes": {
                        "OrderStatus&attr": "Completed",
                        "DeliveryDate&attr": "2024-05-30",
                        "attr": ["Priority=High", ("Urgent", "Yes",)],
                        "Info&Instructions=HandleWithCare": "Special instructions for handling.",
                    },
                    "Assets&AssetID=1&Type=Crypto": "Bitcoin",
                    "Assets&AssetID=2&Type=Crypto": "Ethereum",
                    "Transactions": [
                        {
                            "TransactionID&attr=54321": "54321",
                            "Customer&Name=JaneDoe&Email=jane.doe@example.com": {
                                "Name": "Jane Doe",
                                "Email": "jane.doe@example.com",
                            },
                            "Attributes": {
                                "TransactionStatus&attr": "Pending",
                                "TransactionDate&attr": "2024-06-15",
                                "attr": ["Priority=Low", ("Urgent", "No",)],
                                "Info&Instructions=ProcessImmediately": "Process as soon as possible.",
                            },
                            "Assets&AssetID=3&Type=Crypto": "Ripple",
                            "Assets&AssetID=4&Type=Crypto": "Litecoin",
                        },
                    ],
                }
                TextType = "utf-8"
                LogSection = "OrderProcessing"

            Output:
                b'''
                <Order Attr1="Val1" Attr2="Val2">
                        <OrderID attr="12345">12345</OrderID>
                        <Customer Name="JohnDoe" Email="john.doe@example.com">
                                <Name>John Doe</Name>
                                <Email>john.doe@example.com</Email>
                        </Customer>
                        <Attributes OrderStatus="Completed" DeliveryDate="2024-05-30" Priority="High" Urgent="Yes">
                                <Info Instructions="HandleWithCare">Special instructions for handling.</Info>
                        </Attributes>
                        <Assets AssetID="1" Type="Crypto">Bitcoin</Assets>
                        <Assets AssetID="2" Type="Crypto">Ethereum</Assets>
                        <Transactions>
                                <TransactionID attr="54321">54321</TransactionID>
                                <Customer Name="JaneDoe" Email="jane.doe@example.com">
                                        <Name>Jane Doe</Name>
                                        <Email>jane.doe@example.com</Email>
                                </Customer>
                                <Attributes TransactionStatus="Pending" TransactionDate="2024-06-15" Priority="Low" Urgent="No">
                                        <Info Instructions="ProcessImmediately">Process as soon as possible.</Info>
                                </Attributes>
                                <Assets AssetID="3" Type="Crypto">Ripple</Assets>
                                <Assets AssetID="4" Type="Crypto">Litecoin</Assets>
                        </Transactions>
                </Order>
                '''
        """
        # 補助関数：「タグ名&属性名=属性値」形式のキーを処理
        def SplitKeyToTagAndAttr(Key):
            """ この部分を「関数の docstring」と言います。
            「タグ名&属性名=属性値」形式のキーを処理する関数。

            この関数は､「タグ名&属性名=属性値」形式のキーを分割し、タグ名と属性の辞書を作成します。分割したタグ名は、XML 要素のタグとして使用されることを想定
            しています。属性の辞書は、キーが属性名、値が属性値となります。この関数は関数 self.ExecuteAPIrequest() から敏感情報を含むデータを渡される可能性
            があるため、finally ブロックを設け、変数を明示的に None にし、ガベージコレクタに早期にメモリ回収させています。

            Parameters:
                Key (str): 「タグ名&属性名=属性値」形式の属性名及び属性値を含むキー。

            Returns:
                tuple of str, dict: タグ名と属性の辞書のタプル。
            """
            try:  # エラーを検出するブロック
                Parts = Key.split("&")  # Key を "&" で分割してリストを取得
                Tag = Parts[0]  # 最初の要素をタグ名とする
                AttrParts = Parts[1:]  # 残りの要素を属性部分とする
                AttrDict = {}  # 属性の辞書を初期化
                for AttrPart in AttrParts:  # 各属性部分を処理するためのイテレーション
                    AttrName, AttrValue = AttrPart.split("=", 1)  # 属性部分を "=" で分割して属性名及び属性値を取得
                    AttrDict[AttrName] = AttrValue  # 辞書に属性を追加

                return (Tag, AttrDict,)  # タグ名と属性の辞書のタプルを返す
            finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                Key = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Parts = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Tag = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                AttrParts = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                AttrPart = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                AttrName = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                AttrValue = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                AttrDict = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：子要素を処理し、必要に応じてスタックに追加
        def HandleChildElement(Child, Val, Stack, Key = "", Tag = ""):
            """ この部分を「関数の docstring」と言います。
            子要素を処理し、必要に応じてスタックに追加する関数。

            この関数は、渡された子要素と値に基づいて XML の子要素を作成し、必要に応じてスタックに追加します。この関数は関数 self.ExecuteAPIrequest() から
            敏感情報を含むデータを渡される可能性があるため、finally ブロックを設け、変数を明示的に None にし、ガベージコレクタに早期にメモリ回収させています。

            Parameters:
                Child (xml.etree.ElementTree.Element): 現在の要素の下に作成する子要素。
                Val (any): 子要素に設定する値（辞書、リスト、数値、bool 値、文字列）。
                Stack (list): 再帰的処理のためのスタック。
                Key (str, optional): 子要素のキー。デフォルトは空文字列。
                Tag (str, optional): 子要素のタグ。デフォルトは空文字列。

            Returns:
                なし。
            """
            try:  # エラーを検出するブロック
                if isinstance(Val, dict):  # 値が辞書型の場合
                    Stack.append((Val, Child,))  # スタックに辞書を追加
                elif isinstance(Val, list):  # 値がリスト型の場合
                    for SubVal in Val:  # リストの各要素を処理するためのイテレーション
                        if Tag:  # タグが指定されている場合
                            SubChild = XMLtools.SubElement(Child, Tag)  # 子要素を作成
                        if isinstance(SubVal, dict):  # 要素が辞書型の場合
                            if Key:  # キーが指定されている場合
                                Stack.append((SubVal, Child,))  # スタックに追加
                            elif Tag:  # タグが指定されている場合
                                Stack.append((SubVal, SubChild,))  # スタックに追加
                        else:  # 要素が辞書型でない場合
                            if Key:  # キーが指定されている場合
                                SubChild = XMLtools.SubElement(Child, Key)  # 子要素を作成
                            SubChild.text = saxutils.escape(str(SubVal))  # 子要素のテキストを XML エスケープして設定
                elif isinstance(Val, (int, float, bool, str)):  # 値が数値型、bool 値、文字列型の場合
                    Child.text = saxutils.escape(str(Val))  # 子要素のテキストを XML エスケープして設定
            finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                Child = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Val = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Stack = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Key = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Tag = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                SubVal = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                SubChild = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：渡されたキーと値に基づいて XML 要素を作成し、必要に応じてスタックに追加
        def KeyValToXML(Key, Val, CurrentElem, Stack):
            """ この部分を「関数の docstring」と言います。
            渡されたキーと値に基づいて XML 要素を作成し、必要に応じてスタックに追加する関数。

            この関数は、辞書、リスト、整数値、浮動小数点数、bool 値、文字列（str）の値を処理し、適切な XML 子要素を作成します。辞書やリストの場合、再帰的に
            処理するためにスタックに追加します。この関数は関数 self.ExecuteAPIrequest() から敏感情報を含むデータを渡される可能性があるため、finally
            ブロックを設け、変数を明示的に None にし、ガベージコレクタに早期にメモリ回収させています。

            Parameters:
                Key (str): 現在処理中のキー。
                Val (any): 現在処理中の値。
                CurrentElem (Element): 現在の XML 子要素。
                Stack (list): 再帰的処理のためのスタック。

            Returns:
                なし。
            """
            try:  # エラーを検出するブロック
                if "&" in Key and "=" in Key:  # キーに "&" と "=" が含まれている場合､「タグ名&属性名=属性値」形式と判断
                    Tag, AttrDict = SplitKeyToTagAndAttr(Key)  # 補助関数で Key を処理
                    Child = XMLtools.SubElement(CurrentElem, Tag)  # 現在の要素の下にタグを持つ子要素を作成
                    for AttrName, AttrValue in AttrDict.items():  # 各属性を子要素に設定するためのイテレーション
                        Child.set(AttrName, AttrValue)  # 子要素に属性を設定
                    HandleChildElement(Child, Val, Stack, Tag = Tag)  # 補助関数で子要素を処理
                elif Key.endswith("&attr"):  # キーが接尾辞 "&attr" を持つ場合
                    AttrName = Key[:-5]  # 属性名を取得
                    CurrentElem.set(AttrName, str(Val))  # 現在の要素に属性を設定
                elif isinstance(Val, list) and Key == "attr":  # 値がリスト型でキーが "attr" の場合
                    for AttrVal in Val:  # リストの各要素 = 属性名及び属性値を処理するためのイテレーション
                        if isinstance(AttrVal, str):  # 要素が文字列型（str）の場合
                            AttrName, AttrValue = AttrVal.split("=", 1)  # "=" で分割して属性名と属性値を取得
                            CurrentElem.set(AttrName, AttrValue)  # 現在の要素に属性を設定
                        elif isinstance(AttrVal, tuple) and len(AttrVal) == 2:  # 要素がタプルの場合
                            AttrName, AttrValue = AttrVal  # タプルから属性名と属性値を取得
                            CurrentElem.set(AttrName, str(AttrValue))  # 現在の要素に属性を設定
                else:  # ここまでの条件に該当しない場合
                    Child = XMLtools.SubElement(CurrentElem, Key)  # 現在の要素の下にタグを持つ子要素を作成
                    HandleChildElement(Child, Val, Stack, Key = Key)  # 補助関数で子要素を処理
            finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                Key = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Val = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                CurrentElem = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Stack = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Tag = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                AttrDict = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Child = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                AttrName = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                AttrValue = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                AttrVal = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：辞書と現在の要素から XML を作成するジェネレーター
        def GenerateXML(CurrentDict, CurrentElem):
            """ この部分を「関数の docstring」と言います。
            辞書と現在の要素から XML を作成するジェネレーター関数。

            この関数は、スタックを用いて辞書を再帰的に処理し、XML 要素を作成します。作成した XML 要素は、現在の要素の子要素として追加します。辞書の各キーと値
            に対して適切な XML 子要素を作成し、再帰的に処理を行います。辞書内の辞書及びリストといったネスト構造も正しく処理します。リスト内の要素がさらに辞書型
            の場合、その辞書を持つ新しい子要素を作成し、再帰的に処理します。リスト内の要素が辞書型ではない場合、その要素をテキストとして持つ子要素を作成します。
            スタックと "yield" を駆使することで、再帰的な処理を効率化し、メモリ消費を抑えながら部分的に結果を作成していきます。このアプローチにより、大規模な
            辞書の処理も効率的に行うことが可能です。この関数は関数 self.ExecuteAPIrequest() から敏感情報を含むデータを渡される可能性があるため、finally
            ブロックを設け、変数を明示的に None にし、ガベージコレクタに早期にメモリ回収させています。

            Parameters:
                CurrentDict (dict): 現在処理中の辞書。
                CurrentElem (Element): 現在の XML 要素。

            Yields:
                なし。
            """
            try:  # エラーを検出するブロック
                Stack = [(CurrentDict, CurrentElem,)]  # 辞書 CurrentDict と親要素 CurrentElem をスタックに追加
                while Stack:  # スタックが空になるまでのループ
                    CurrentDict, CurrentElem = Stack.pop()  # スタックから辞書 CurrentDict と現在の要素 CurrentElem を取得しつつ削除
                    for Key, Val in CurrentDict.items():  # 辞書のキーバリューアサインメントを処理するためのイテレーション
                        Key = Key.split(">", 1)[1] if ">" in Key else Key  # キーに一意性を保証する番号が振られている場合、除去
                        KeyValToXML(Key, Val, CurrentElem, Stack)  # 補助関数で処理
                        yield  # 部分的にデータを返す
            finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                CurrentDict = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                CurrentElem = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Stack = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Key = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                Val = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        """ DictToXML() の記述 """
        try:  # エラーを検出するブロック
            if not isinstance(RootTag, str):  # RootTag が文字列でない場合
                self.LogManager.RecordBackLOG("{0}：エラー「ルートタグは文字列である必要があります」".format(str(LogSection)), self.ThreadID)
                return False  # 処理を終了して False を返す
            if not isinstance(BaseDict, dict):  # BaseDict が辞書でない場合
                self.LogManager.RecordBackLOG("{0}：エラー「基礎となるデータは辞書である必要があります」".format(str(LogSection)), self.ThreadID)
                return False  # 処理を終了して False を返す
            if not isinstance(TextType, str):  # TextType が文字列でない場合
                self.LogManager.RecordBackLOG("{0}：エラー「エンコーディングの指定は文字列である必要があります」".format(
                    str(LogSection)), self.ThreadID)
                return False  # 処理を終了して False を返す

            # RootTag が "ルートタグのみ" の場合、ルートタグを唯一の要素として持つ XML を作成するために BaseDict からルートタグと値を取得
            RootTag, RootVal = next(iter(BaseDict.items())) if "ルートタグのみ" in RootTag else (RootTag, "",)

            if "&" in RootTag and "=" in RootTag:  # ルートタグに "&" と "=" が含まれている場合､「タグ名&属性名=属性値」形式と判断
                RootTag, RootAttrDict = SplitKeyToTagAndAttr(RootTag)  # 補助関数で RootTag を処理
            else:  # ルートタグに "&" と "=" が含まれていない場合
                RootAttrDict = {}  # 空の属性の辞書を用意

            Elem = XMLtools.Element(RootTag)  # ルートタグ名を使用して、ルート要素を作成

            if RootAttrDict:  # 属性の辞書が空でない場合
                for AttrName, AttrValue in RootAttrDict.items():  # 各属性をルート要素に設定するためのイテレーション
                    Elem.set(AttrName, AttrValue)  # ルート要素に属性を設定

            if RootVal:  # RootVal が有効値を持つ場合
                Elem.text = saxutils.escape(str(RootVal))  # ルートタグのテキストを XML エスケープして設定
                # 完成した XML ツリーを bytes 型の文字列に変換して返す（"unicode" の場合、str）
                return XMLtools.tostring(Elem, encoding = TextType)

            for _ in GenerateXML(BaseDict, Elem):  # ジェネレーター関数を使用して XML を作成
                continue  # 作成処理を続行

            return XMLtools.tostring(Elem, encoding = TextType)  # 完成した XML ツリーを bytes 型の文字列に変換して返す（"unicode" の場合、str）
        except Exception as e:  # 何らかのエラーが発生した場合
            self.LogManager.RecordBackLOG("{0}：エラー「{1}」".format(str(LogSection), str(e)), self.ThreadID)
            return False  # 処理を終了して False を返す
        finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
            RootTag = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            RootVal = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            BaseDict = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            RootAttrDict = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            Elem = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            AttrValue = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # XML または JSON 形式に変換可能な辞書を構築する関数
    def BuildDict_ofXMLorJSON(self, BuildingData, RootTag = "", Tag = "", Attr = "", Value = "", JSON = False):
        """ この部分を「関数の docstring」と言います。
        XML または JSON 形式に変換可能な辞書を構築する関数。

        この関数は、渡される各種引数に基づいて､「辞書を XML 形式に変換する関数 self.DictToXML()」に渡すための辞書、または関数 json.dumps() に渡すための
        辞書またはリストを構築します。

        XML 形式に変換可能な辞書を構築する場合：
        辞書を XML 形式に変換する関数 self.DictToXML() は引数としてルートタグを取り、処理するため、この関数でルートタグを扱う必要はありませんが、扱うことが
        できるように設計されています。ルートタグを設定する場合、呼び出し元の処理フローで扱われる文字列には「ルートタグ:ルートタグ名&属性名=属性値:null」という
        形式、通常のタグを設定する場合は「タグ:タグ名&属性名1=属性値1&属性名2=属性値2:null」という形式、値を持つタグを設定する場合は
        「タグ:タグ名&属性名=属性値:値」という形式が必要です。いずれの場合も属性を設定する部分は省略可能、つまり属性を設定しないことも可能です。またいずれの場合
        もタグに複数の属性を設定することができます。これにより、属性が設定されたタグの中に値を持つタグを定義することや、属性を持たないタグの中に値を持つタグを
        定義すること、または単に平らな構造の、値を持つタグのキーバリューリストを定義することが可能です。引数 BuildingData にルートタグを設定する場合、
        キーワード引数は RootTag のみを渡される必要があります。この場合、BuildingData 辞書に "RootTag" キーを設定し、値として RootTag を設定します。その
        後、同辞書に "Data" キーを設定し、値として空の辞書を設定してその参照を返します。XML にルートタグのみを設定し、ルートタグが直接値を持つようにする場合、
        キーワード引数は RootTag と Value のみを渡される必要があります。この場合、BuildingData 辞書に "RootTag" キーを設定し、値として "ルートタグのみ"
        を設定します。この値は関数 self.DictToXML() でルートタグのみの XML を作成する場合に RootTag として渡す必要があり、同関数はこれに基づいて辞書から
        ルートタグのみの XML を作成します。このため、この関数ではそのための辞書として BuildingData 辞書に "Data" キーを設定し、値として RootTag と Value
        のキーバリューを持つ辞書を設定してその参照を返します。ルートタグのみの場合は、あえて "Data" キーの辞書の参照を返す必要はありませんが、関数の動作の
        一貫性を保つため、新しい階層を作成した場合の挙動として他のパターンと統一しています。ルートタグの設定をこの関数で行わず、通常のタグの設定のみをこの関数で
        行う場合、BuildingData 辞書には "RootTag" 及び "Data" キーは作成しませんので、この点に注意が必要です。通常のタグを設定する場合で属性値を処理する
        必要がある場合、呼び出し元で属性情報部分のみの文字列「属性名1=属性値1&属性名2=属性値2」を抽出し、この関数のキーワード引数 Attr として指定し、他の
        キーワード引数を指定しないことで、更新していない BuildingData と属性名及び属性値のタプルのリストを返すことが可能です。呼び出し元で属性情報の処理を
        行い､「タグ名&属性名1=属性値1&属性名2=属性値2」という形式のタグを作成し、この関数のキーワード引数 Tag に指定し、他のキーワード引数を指定しないことで、
        この関数はタグにタグをネストする準備を行います。このとき、属性情報を持たないタグでも同様の処理を行います。具体的には、BuildingData 辞書内に Tag をキー
        として新しい辞書を設定してその参照を返します。この新しい辞書には、"Ref" をキーとして親参照を記録します。これは次回以降の呼び出しで階層を上がる処理の際に
        この関数内で使用して削除するものです。このため、この関数で XML 形式に変換可能な辞書の構築を開始した場合、一貫してこの関数で構築を完了する必要があります。
        これが行われないと、辞書内に "Ref" キーが残ったままになり、XML 形式に正しく変換できなくなります。キーワード引数として Tag のみを指定する呼び出しを繰り
        返すことで、XML の階層を深くしていくことができます。タグに値を設定する場合は Tag と Value のみを渡される必要があります。この場合、BuildingData 辞書
        に Tag と Value のキーバリューを設定してその参照を返します。この関数では渡される「タグ名&属性名=属性値」形式のタグを辞書のキーとして設定しますが、この
        形式のタグが辞書内で一意である保証がないため、辞書のキーとして設定する際、タグに一意性を保証する番号を付与し､「番号>タグ名&属性名=属性値」という形式に
        して辞書のキーとします。この形式のキーは関数 self.DictToXML() で正しく処理されます。階層的な XML 構造を構築するために辞書の構造も階層的になることが
        ありますが、単に値を持つタグを定義する場合は階層は深くなりません。階層が深くなるのは、タグの中にタグを定義するケースです。一つのタグの中に一つまたは複数
        のタグを定義すると、階層が一つ深くなります。階層を上がるには、呼び出し元の処理フローで扱われる文字列に「タグ:/:null」の形式が必要で、1 階層上がる場合は
        「/」、複数階層上がる場合は「//」のように「/」の数で上がる階層の数を指定します。特定の階層に「ネストされたタグを持つタグ」を並べたい場合、タグにネスト
        しているタグの数 = 階層数だけ「/」を指定して上の階層に戻ることで、特定の階層にタグを並べることができます。また、全てのタグの設定完了後にも、適切にルート
        階層まで参照を戻す呼び出しが必要です。この点については次のセクションで後述します。呼び出し元の処理フローでは、入力文字列を「:」で分割し、タグ名、属性名
        及び属性値、値の三つを抽出してこの関数に渡す必要があります｡「null」は、タグが値を持たず、単に階層の設定や属性の追加を行うために呼び出し元の処理フローで
        使用するものとしてアプリケーション内で定義されています。

        JSON 形式に変換可能な辞書を構築する場合：
        JSON 形式に変換可能な辞書を構築する場合、引数 JSON は常に True に設定する必要があります。呼び出し元の処理フローで扱われる文字列には「^キー:キー名:値」
        という形式が必要です。呼び出し元の処理フローでは、入力文字列を「:」で分割し、キー名、値の二つを抽出して値を処理し、キー名と共にこの関数に渡す必要があり
        ます。キー名は JSON の辞書構造を構築する際に必要となりますが、リスト構造を構築する際には渡される必要はありません。渡されると、誤動作の原因となります。
        呼び出し元の処理フローで初期化した、この関数の引数 BuildingData として渡すためのデータの型を辞書またはリストから他方へ変更する必要が生じた場合、この
        関数でその処理を行うことも可能です。その場合、キーワード引数 Tag に None を指定し、Value に目的の空の辞書またはリストを指定します。JSON 形式に変換
        可能な辞書を構築する場合、キーワード引数は Tag、Value、JSON のみを使用します。この関数はネスト構造を作成した場合、その階層の参照を返すため、呼び出し元
        ではネストしたデータ型が辞書またはリストのいずれであるかを把握している必要があります。辞書にキーバリューを追加する場合、Tag にキー名を、Value に値を
        指定します。Value に空の辞書またはリストを指定された場合、そのデータ型の値を追加し、その参照を返します。リストに要素を追加する場合、Tag は指定せず、
        Value のみを指定します。この場合も空の辞書またはリストを指定可能です。辞書にキーバリューを追加する際、キー名は一意性が保証されている必要があり、この関数
        での一意性の付与は行いません。辞書またはリストに辞書またはリストをネストし、要素を追加し終えた後、上の階層に戻るには、戻る階層数だけ「/」を Tag として
        渡される必要があります。例えば、2 階層上がる場合は「//」とします。また、全ての要素の追加完了後にも、適切にルート階層まで参照を戻す呼び出しが必要です。
        この点については次のセクションで後述します。

        この関数は、ネスト構造を作成する際、後で上の階層に戻るための参照を、作成したネスト構造内に記録します。このため、データの構築完了後に適切に参照をルート
        階層まで戻す呼び出しが行われないと、データには参照の記録が残ったままになり、後続の処理で不整合が起きる要因となります。この関数では上の階層に戻る際、その
        ための参照を取得した後に適切にその参照をデータから削除します。また、このようなロジックのため、この関数は BuildingData の構築を開始した場合、次の呼び
        出し時には前回返した参照を「そのまま」渡されることを前提としています。従って、データの構築中に呼び出し元で返り値に何らかの変更が加えられたり、別の参照が
        渡されたりする場合、この関数が構築するデータには予期しない不整合が生じる可能性があります。この関数は関数 self.ExecuteAPIrequest() から敏感情報を含む
        データを渡される可能性があるため、finally ブロックを設け、変数を明示的に None にし、ガベージコレクタに早期にメモリ回収させています。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            BuildingData (dict): XML または JSON 形式に変換可能な辞書を構築する先の辞書の参照。JSON 形式の場合、リストの参照も指定可能。
            RootTag (str, optional): XML のルート要素のタグ名。属性を設定する場合は「ルートタグ名&属性名=属性値」形式。デフォルトは空文字列。
            Tag (str, optional): XML のタグ名または JSON のキー。デフォルトは空文字列。
            Attr (str, optional): XML の「属性名=属性値」または「属性名1=属性値1&属性名2=属性値2」という形式の属性情報を含む文字列。デフォルトは空文字列。
            Value (dict or list or str, optional):
                XML のタグまたは JSON のキーの値。JSON に辞書またはリストをネストする場合は空の辞書またはリスト。デフォルトは空文字列。
            JSON (bool, optional): JSON 形式に変換可能な辞書を構築することを示すフラグ。デフォルトは False。

        Returns:
            tuple of dict, list: 更新した BuildingData の参照と、属性情報のタプル「("属性名", "属性値")」のリスト。

        Raises:
            ValueError:
                ● パターン 1: JSON フラグが有効であるにも関わらず XML のルートタグが渡された場合に発生。
                ● パターン 2: JSON フラグが無効であるにも関わらず Value としてリストが渡された場合に発生。
                ● パターン 3: 属性情報に "=" が存在しない場合に発生。
        """
        try:  # エラーを検出するブロック
            if not JSON and RootTag and not Value:  # XML のルートタグを設定する呼び出しの場合
                BuildingData["RootTag"] = RootTag  # "RootTag" キーにルートタグを設定
                BuildingData["Data"] = {}  # ルートタグ内に配置されるデータを格納する辞書を作成
                BuildingData = BuildingData["Data"]  # 参照を更新し、階層を潜る
                return BuildingData, []  # 更新した辞書の参照と空のリストを返す
            elif not JSON and RootTag and Value:  # XML にルートタグのみが存在するようにする呼び出しの場合
                BuildingData["RootTag"] = "ルートタグのみ"  # 関数 self.DictToXML() がルートタグのみを処理するようにする条件を設定
                BuildingData["Data"] = {RootTag: Value,}  # RootTag と Value のペアを持つ辞書を作成
                BuildingData = BuildingData["Data"]  # 参照を更新
                return BuildingData, []  # 更新した辞書の参照と空のリストを返す
            elif JSON and RootTag:  # JSON フラグが有効であるにも関わらず XML のルートタグが渡された場合、ValueError を発生させる
                raise ValueError("JSON にルートタグを設定することはできません")
            # XML のタグ名または JSON のキーを処理する呼び出しの場合
            elif (Tag and not Tag.startswith("/")) or (JSON and \
            ((not Value and isinstance(Value, (dict, list))) or (Tag and Value) or (not Tag and Value))):
                # Tag が有効値を持つ、かつ JSON フラグが無効、かつ Tag に "署名" が含まれない場合、タグ名に一意性を保証する番号を付与
                Tag = "{0}>".format(str(self.ProcessCounting())) + Tag if Tag and not JSON and "署名" not in Tag else Tag
                if not Value:  # Value が有効値を持たない場合
                    # 現在の参照が辞書、かつ Value が空の辞書または空文字列の場合（XML、JSON 共通）
                    if isinstance(BuildingData, dict) and isinstance(Value, (dict, str)):
                        BuildingData[Tag] = {"Ref": BuildingData,}  # タグ名に現在の参照を持つ辞書を設定し、次のタグ名の処理に備える
                        BuildingData = BuildingData[Tag]  # 参照を更新し、階層を潜る
                    elif JSON:  # JSON フラグが有効な場合
                        if isinstance(BuildingData, dict) and isinstance(Value, list):  # 現在の参照が辞書、かつ Value が空のリストの場合
                            if not BuildingData and not Tag:  # 現在の参照が空、かつ Tag が有効値を持たない場合
                                BuildingData = Value  # 空の辞書である現在の参照を空のリストである Value に変更
                            elif Tag:  # Tag が有効値を持つ場合
                                BuildingData[Tag] = [BuildingData,]  # キーに現在の参照を持つリストを設定し、次のキーの処理に備える
                                BuildingData = BuildingData[Tag]  # 参照を更新し、階層を潜る
                        elif isinstance(BuildingData, list):  # 現在の参照がリストの場合
                            if isinstance(Value, dict):  # Value が空の辞書の場合
                                if not BuildingData and Tag is None:  # 現在の参照が空、かつ Tag が None の場合
                                    BuildingData = Value  # 空のリストである現在の参照を空の辞書である Value に変更
                                elif not Tag:  # Tag が有効値を持たない場合
                                    BuildingData.append({"Ref": BuildingData,})  # リストに現在の参照を持つ辞書を追加し、次の処理に備える
                                    BuildingData = BuildingData[-1]  # 参照を更新し、階層を潜る
                            elif isinstance(Value, list):  # Value が空のリストの場合
                                BuildingData.append([BuildingData,])  # リストに現在の参照を持つリストを追加し、次の処理に備える
                                BuildingData = BuildingData[-1]  # 参照を更新し、階層を潜る
                elif isinstance(BuildingData, dict):  # Value が有効値を持つ、かつ現在の参照が辞書の場合（XML、JSON 共通）
                    BuildingData[Tag] = Value  # タグ名に値を設定
                elif JSON and isinstance(BuildingData, list):  # Value が有効値を持つ、かつ JSON フラグが有効、かつ現在の参照がリストの場合
                    BuildingData.append(Value)  # リストに値を追加

                return BuildingData, []  # 更新した辞書の参照と空のリストを返す
            # JSON フラグが無効であるにも関わらず Value としてリストが渡された場合、ValueError を発生させる
            elif not JSON and isinstance(Value, list):
                raise ValueError("XML 構築中にリストを使用することはできません")
            elif Attr and "=" in Attr:  # XML の属性を処理する呼び出しの場合
                Attributes = Attr.split("&")  # 複数のキーバリューを繋ぐ "&" で分割してキーバリューのリストを取得
                # キーバリューのリストからキーバリューを取り出し、"=" で分割してリストを取得し、リストをタプルに変換
                AttrList = [tuple(Attribute.split("=")) for Attribute in Attributes]

                return BuildingData, AttrList  # 更新していない辞書の参照と属性名及び属性値のタプルのリストを返す
            elif Attr and "=" not in Attr:  # XML の属性を処理する場合で属性情報に "=" が存在しない場合、ValueError を発生させる
                raise ValueError('属性情報を指示する文字列に "=" が存在しません。内容：{0}'.format(str(Attr)))
            elif Tag and Tag.startswith("/"):  # XML または JSON の階層を上がる呼び出しの場合
                LevelsUp = Tag.count("/")  # "/" の数を数える
                for _ in range(LevelsUp):  # "/" の数だけ上の階層に戻るためのイテレーション
                    if isinstance(BuildingData, dict) and "Ref" in BuildingData:  # 現在の参照が辞書、かつ "Ref" キーが存在する場合
                        ParentRef = BuildingData["Ref"]  # "Ref" キーが持つ親参照を取得
                        del BuildingData["Ref"]  # "Ref" キーを削除
                        BuildingData = ParentRef  # 参照を更新し、階層を上がる
                    # 現在の参照がリスト、かつ最初の要素が辞書またはリストの参照の場合
                    elif isinstance(BuildingData, list) and isinstance(BuildingData[0], (dict, list)):
                        ParentRef = BuildingData[0]  # 最初の要素が持つ親参照を取得
                        del BuildingData[0]  # 親参照の要素を削除
                        BuildingData = ParentRef  # 参照を更新し、階層を上がる

                return BuildingData, []  # 更新した辞書の参照と空のリストを返す

            return BuildingData, []  # 更新していない辞書の参照と空のリストを返す
        finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
            BuildingData = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            ParentRef = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            Tag = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            Value = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # HTTP リクエストに必要なクエリパラメータ及びヘッダーを構築し、必要に応じてリクエストボディや署名を付与してリクエストを実行する関数
    def ExecuteAPIrequest(self, SignString, ParamsString, HeaderString, Method, Domain, Path, TextType = "utf-8", AuthType = "HMAC",
        EscapePattern = 1, ProductCode = None, OrderType = None, Side = None, Price = None, Size = None):
        """ この部分を「関数の docstring」と言います。
        HTTP リクエストに必要なクエリパラメータ及びヘッダーを構築し、必要に応じてリクエストボディや署名を付与してリクエストを実行する関数。

        この関数は、指定されたドメイン、パスに対して、指定された HTTP メソッドを用いた HTTP リクエストを行います。リクエストの構築には引数 ParamsString、
        HeaderString を用い、それぞれの文字列で指定される必要な情報をクエリパラメータ、ヘッダーに含めます。署名が必要なリクエストの場合には、引数 SignString
        を用いて署名に含めるべき情報を含めた署名を作成し、リクエストに付与します。リクエストボディをリクエストに含める必要がある場合は、ParamsString からその
        情報を抽出し、リクエストボディを作成します。引数 AuthType、EscapePattern はアプリケーションのメインフレーム「接続先編集」タブで設定された値が渡される
        ことを想定しています。これらの引数に基づいてリクエストを構築し、エラーがない場合はリクエストを送信し、レスポンスデータを返します。この関数では、
        リクエストに必要な API キー及び API シークレットをリクエスト毎に復号化するアプローチを採用しています。これはアプリケーションの仕様によるもので、これら
        「漏洩リスクが管理されるべき敏感情報」を、復号化した状態のままメモリ上に長時間保持しないことで、アプリケーションが予期しないトラブルに遭遇した場合の敏感
        情報の漏洩リスクを最小限に抑えます。このアプローチはリクエスト毎に各種キーの復号化処理を必要とするためシステムに負荷をかけることになりますが、
        アプリケーションは計算リソースの豊富な環境で実行されることを前提としているため、より安全なこのアプローチを採用しています。また、この関数の設計は汎用性
        確保のため、特定の暗号資産取引所の名称を条件分岐に使用するといった類のハードコーディング（ソースコード内に値や設定を直接記述し、保守性や汎用性を下げる
        こと）を徹底的に排除しています。これにより、リクエストの作成に必要な情報は全て引数または AppClass（self.App）属性の設定値から得る設計となっており、
        対応可能な暗号資産取引所が一つ増えれば、同様のパターンを採用している他の暗号資産取引所、あるいはこれまでに対応しているパターンを組み合わせたパターンを
        採用している暗号資産取引所にも対応可能になります。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            SignString (str): 署名構築指示文字列。署名のコンポーネントを "," で区切ったもの。必要ない場合は "None"（str）。
            ParamsString (str):
                クエリパラメータ構築指示文字列。
                クエリパラメータのコンポーネントを "," で区切り、キーと値を ":" で区切ったもの。必要ない場合は "None"（str）。
            HeaderString (str):
                ヘッダー構築指示文字列。ヘッダーのコンポーネントを "," で区切り、キーと値を ":" で区切ったもの。必要ない場合は "None"（str）。
            Method (str): HTTP メソッド。リクエストの種類を指定（例: "GET", "POST"）。
            Domain (str): API のドメイン。"http" で始まるものを指定（例: "https://api.bitflyer.com"）。
            Path (str): リクエストのパス。API のエンドポイントを指定（例: "/v1/getticker"）。
            TextType (str, optional): リクエストの各種コンポーネントのエンコードタイプ。デフォルトは utf-8。
            AuthType (str, optional): 認証方式を表す文字列。デフォルトは "HMAC"。
            EscapePattern (int, optional):
                特殊文字のエスケープパターンを指定する整数値（1 または 2）。標準エスケープまたは特殊エスケープ。デフォルトは 1。
            ProductCode (str, optional): リクエストに使用する商品コード。デフォルトは None。
            OrderType (str, optional): 注文タイプ（例: "LIMIT", "MARKET"）。デフォルトは None。
            Side (str, optional): 取引種別（例: "BUY", "SELL"）。デフォルトは None。
            Price (float, optional): 注文価格（LIMIT 注文の場合）。デフォルトは None。
            Size (float, optional): 注文数量。デフォルトは None。

        Returns:
            dict or False: API のレスポンスデータ。未対応の認証方式、または何らかのエラーが発生した場合 False。
                - StatusCode (int): HTTP レスポンスのステータスコード。
                - Data (str): API のレスポンスデータ本体。UTF-8 でデコードされた文字列。
        """
        # 補助関数：署名またはクエリパラメータまたはヘッダー構築指示文字列のフォーマットエラーを記録
        def Error_ofComponent(Item, Domain, Path, CheckSet = {}, StringName = "", JsonXmlConflict = False, IsBodyNotEmpty = False,
            MissingRef = False, FlagIsConfused = False):
            """ この部分を「関数の docstring」と言います。
            署名またはクエリパラメータまたはヘッダー構築指示文字列のフォーマットエラーを記録する関数。

            この関数は、署名またはクエリパラメータまたはヘッダー構築指示文字列中の一つのコンポーネント、"," で分割したリストの一つの要素の形式が正しいもので
            ない場合のエラーログを記録します。エラーログは各構築指示文字列毎に最適化したものを記録します。

            Parameters:
                Item (str): 現在処理中のコンポーネント。
                Domain (str): API のドメイン。"http" で始まるものを指定（例: "https://api.bitflyer.com"）。
                Path (str): リクエストのパス。API のエンドポイントを指定（例: "/v1/getticker"）。
                CheckSet (set, optional): Item のフォーマットの確認に使用する文字列（str）のセット。
                StringName (str, optional): 現在処理している構築指示文字列の種類。"クエリパラメータ" または "ヘッダー"。
                JsonXmlConflict (bool, optional):
                    リクエストボディを JSON または XML 形式にすることが必要とされている場合に JSONbody、XMLbody フラグが同時に有効になっている場合の
                    エラーを記録するためのフラグ。
                IsBodyNotEmpty (bool, optional):
                    リクエストボディを JSON または XML 形式にすることが必要とされている場合に「JSON または XML 形式に変換可能な辞書を構築中に変化する階層の
                    現在の参照を記録する辞書」が初期状態にも関わらずリクエストボディのコンポーネントを格納する辞書が空でない場合のエラーを記録するためのフラグ。
                MissingRef (bool, optional):
                    リクエストボディを JSON または XML 形式にすることが必要とされている場合に署名を求められた場合で「JSON または XML 形式に変換可能な辞書を
                    構築中に変化する階層の現在の参照を記録する辞書」に参照が記録されていない場合のエラーを記録するためのフラグ。
                FlagIsConfused (bool, optional):
                    JSONbody、XMLbody、URLbody の各種フラグは互いに排他的でなければならないにも関わらず、複数のフラグが同時に True となっている場合の
                    エラーを記録するためのフラグ。

            Returns:
                bool: フォーマットエラーを記録した場合、True。そうでなければ False。
            """
            if Domain == "null":  # Domain が null = Path にフルパスが格納されている場合
                Path = Path.split("://", 1)[1].split("/", 1)[1].strip()  # スキームとドメインを取り除いたパスを取得

            if CheckSet:  # CheckSet が指定されている場合、署名構築指示文字列のコンポーネントに対するチェックを行う
                if all(Check not in Item for Check in CheckSet):  # Item が CheckSet のいずれの文字列とも一致しない場合、エラーを記録
                    self.LogManager.RecordBackLOG(('APIclient：エラー「署名構築指示文字列の ":" が見つからないか、正しい形式ではありません。'
                        'パス：{0}、項目：{1}」').format(str(Path), str(Item)), self.ThreadID)
                    return True  # 処理を終了して True を返す
            elif StringName:  # StringName が指定されている場合、クエリパラメータまたはヘッダー構築指示文字列のコンポーネントに対するチェックを行う
                if not Item.count(":") == 2:  # Item の区切り文字 ":" が二つでない場合、エラーを記録
                    self.LogManager.RecordBackLOG(('APIclient：エラー「{0}構築指示文字列の ":" が二つと一致しません。'
                        'パス：{1}、項目：{2}」').format(str(StringName), str(Path), str(Item)), self.ThreadID)
                    return True  # 処理を終了して True を返す
            elif JsonXmlConflict:  # JSON または XML 形式エラーを記録するための呼び出しの場合、エラーの記録を行う
                self.LogManager.RecordBackLOG(('APIclient：エラー「正しく JSON または XML 形式のリクエストボディを構築するためのクエリパラメータ構築'
                    '指示文字列が設定されていません。"JSONボディ" "XMLボディ" 指示を同時に使用することはできません。一つのエンドポイントのリクエスト形式は'
                    '一つに統一される必要があります。パス：{0}」').format(str(Path)), self.ThreadID)
                return True  # 処理を終了して True を返す
            elif IsBodyNotEmpty:  # JSON または XML 形式エラーを記録するための呼び出しの場合、エラーの記録を行う
                self.LogManager.RecordBackLOG(('APIclient：エラー「正しく JSON または XML 形式のリクエストボディを構築するためのクエリパラメータ構築'
                    '指示文字列が設定されていません。"ボディ構築" 及び "JSONボディ" または "XMLボディ" 指示の間に別の指示が存在している可能性があります。'
                    'パス：{0}」').format(str(Path)), self.ThreadID)
                return True  # 処理を終了して True を返す
            elif MissingRef:  # JSON または XML 形式エラーを記録するための呼び出しの場合、エラーの記録を行う
                self.LogManager.RecordBackLOG(('APIclient：エラー「正しく JSON または XML 形式のリクエストボディを構築するためのクエリパラメータ構築'
                    '指示文字列が設定されていません。"JSONボディ" または "XMLボディ" 指示の前に "^署名" 指示を置くことはできません。'
                    'パス：{0}」').format(str(Path)), self.ThreadID)
                return True  # 処理を終了して True を返す
            elif FlagIsConfused:  # JSONbody、XMLbody、URLbody の各種フラグが複数同時に True となっている場合の呼び出しの場合、エラーの記録を行う
                self.LogManager.RecordBackLOG(('APIclient：エラー「一つのエンドポイントのクエリパラメータ構築指示文字列に "JSONボディ" "XMLボディ" '
                    '"URLクエリ" 指示を同時に複数含めることはできません。一つのエンドポイントのリクエスト形式は一つに統一される必要があります。'
                    'パス：{0}」').format(str(Path)), self.ThreadID)
                return True  # 処理を終了して True を返す

            return False  # Item が正しい形式の場合、False を返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：署名構築指示文字列を処理
        def ProcessSignString(SignString, Domain, Path, Timestamp, Method, ProductCode, OrderType, Side, Price, Size):
            """ この部分を「関数の docstring」と言います。
            署名構築指示文字列を処理する関数。

            この関数は、署名構築指示文字列を処理するためのものです。関数の実行中に補助関数 ProcessParamsString() によって変更される可能性のある
            エンクロージングスコープの変数は nonlocal キーワードによって参照します。このキーワードの使用は変数の変更を目的としたものではなく、変数の出自の
            可視化を目的としたものです。

            Parameters:
                SignString (str): 署名構築指示文字列。署名のコンポーネントを "," で区切ったもの。必要ない場合は "None"（str）。
                Domain (str): API のドメイン。"http" で始まるものを指定（例: "https://api.bitflyer.com"）。
                Path (str): リクエストのパス。API のエンドポイントを指定（例: "/v1/getticker"）。
                Timestamp (str): 呼び出し元の関数 self.ExecuteAPIrequest() で扱われる Unix タイムスタンプ。
                Method (str): HTTP メソッド。リクエストの種類を指定（例: "GET", "POST"）。
                ProductCode (str): リクエストに使用する商品コード。
                OrderType (str): 注文タイプ（例: "LIMIT", "MARKET"）。
                Side (str): 取引種別（例: "BUY", "SELL"）。
                Price (float): 注文価格（LIMIT 注文の場合）。
                Size (float): 注文数量。

            Returns:
                tuple of;
                    Host, SignBase64encode, SignBase64URLencode, SafeSign, JoinChar, SignText

            Raises:
                ValueError: 署名構築指示文字列のコンポーネントが適切な形式でない場合に発生。
            """
            self.LogManager.RecordBackLOG("APIclient：署名作成開始", self.ThreadID)
            # 一般的な認証方式における署名作成での共通処理
            SignComponents = []  # 署名のコンポーネントを格納するリストを初期化
            Host = ""  # ホスト名の変数を空文字列（str）で初期化
            SignBase64encode = False  # 署名を Base64 エンコードすることが必要とされていることを示すフラグを初期化
            SignBase64URLencode = False  # 署名を Base64 URL エンコードすることが必要とされていることを示すフラグを初期化
            SafeSign = False  # 署名を URL セーフエンコードすることが必要とされていることを示すフラグを初期化
            JoinChar = ""  # 署名のコンポーネントの連結文字を空文字列（str）で初期化
            SignText = ""  # 署名用のテキストの変数を空文字列（str）で初期化

            # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
            nonlocal ParamsString, TextType, EscapePattern, SignDict, SerializedParams
            """
            補助関数 ProcessParamsString() の引数順序及び使用順序で並べています。
            この関数では実際にはこれらは直接的には変更しません。変数の出自の可視化を目的とした宣言です。
            """

            if not SignString == "null":  # 署名構築指示文字列が "null" でない場合、署名の構築を行う
                # 署名構築指示文字列を "," で分割してリストを取得し、余計な空白を除去し、空文字列を除去し、署名構築指示を順に処理するためのイテレーション
                # （"," がない場合、文字列が唯一のイテレータとなり、空文字列の場合、イテレーションは実行されない）
                for Item in filter(None, [item.strip() for item in SignString.split(",")]):
                    if Item == "タイムスタンプ":  # 署名にタイムスタンプが必要とされている場合、署名のコンポーネントを格納するリストに追加
                        SignComponents.append(Timestamp)  # タイムスタンプを追加（対応：bitFlyer、bitbank、Coincheck、GMOコイン）
                    elif Item == "メソッド":  # 署名にメソッドが必要とされている場合、署名のコンポーネントを格納するリストに追加
                        SignComponents.append(Method)  # メソッドを追加（対応：bitFlyer、BitTrade、GMOコイン）
                    elif "パス" in Item:  # 署名にパスが必要とされている場合、署名のコンポーネントを格納するリストに追加
                        # Item が適切な形式でない場合、ValueError を発生させる
                        if Error_ofComponent(Item, Domain, Path, CheckSet = {"パス:パス", "パス:フルパス",}):
                            raise ValueError("フォーマットエラー")

                        if Item == "パス:パス":  # 通常の場合（対応：bitFlyer、bitbank、BitTrade、GMOコイン）
                            if Domain == "null":  # Domain が null = Path にフルパスが格納されている場合
                                ExtractedPath = Path.split("://", 1)[1].split("/", 1)[1].strip()  # スキームとドメインを取り除いたパスを取得
                            else:  # Domain が null = Path にフルパスが格納されていない場合
                                ExtractedPath = Path  # Path をそのまま使用
                            SignComponents.append(ExtractedPath)  # パスを追加
                        elif Item == "パス:フルパス":  # フルパスが必要とされている場合（対応：Coincheck）
                            if Domain == "null":  # Domain が null = Path にフルパスが格納されている場合
                                SignComponents.append(Path)  # パスを追加
                            else:  # Domain が null = Path にフルパスが格納されていない場合
                                SignComponents.append(urljoin(Domain, Path))  # パスを追加
                    # 署名にクエリパラメータが必要とされている場合、署名のコンポーネントを格納するリストに追加（対応：bitbank）
                    # 署名にボディが必要とされている場合、署名のコンポーネントを格納するリストに追加（対応：bitFlyer、bitbank、Coincheck、GMOコイン）
                    elif any(Item == Check for Check in {"クエリパラメータ", "ボディ"}):
                        ProcessParamsString(ParamsString, TextType, EscapePattern, Domain, Path, Timestamp, SignDict, ProductCode,
                            OrderType, Side, Price, Size, CallerIsSign = True)  # 補助関数でクエリパラメータ構築指示文字列を処理
                        SignComponents.append(SerializedParams)  # クエリパラメータまたはボディを追加
                    elif "ホスト" in Item:  # 署名にホスト名が必要とされている場合、署名のコンポーネントを格納するリストに追加
                        if Error_ofComponent(Item, Domain, Path, CheckSet = {":",}):  # Item が適切な形式でない場合、ValueError を発生させる
                            raise ValueError("フォーマットエラー")

                        Host = Item.replace("ホスト:", "", 1).strip()  # ホスト名を取得
                        SignComponents.append(Host)  # ホスト名を追加（対応：BitTrade）
                    elif Item == "Base64":  # 署名を Base64 エンコードすることが必要とされている場合、その情報を記録（対応：BitTrade）
                        SignBase64encode = True  # 署名を Base64 エンコードすることが必要とされていることを示すフラグを有効化
                    elif Item == "Base64URL":  # 署名を Base64 URL エンコードすることが必要とされている場合、その情報を記録（対応：備え）
                        SignBase64URLencode = True  # 署名を Base64 URL エンコードすることが必要とされていることを示すフラグを有効化
                    elif Item == "セーフサイン":  # 署名を URL セーフエンコードすることが必要とされている場合、その情報を記録（対応：備え）
                        SafeSign = True  # 署名を URL セーフエンコードすることが必要とされていることを示すフラグを有効化
                    elif "改行" in Item:  # 署名のコンポーネントの連結に改行が必要とされている場合、その情報を記録
                        # Item が適切な形式でない場合、ValueError を発生させる
                        if Error_ofComponent(Item, Domain, Path, CheckSet = {"改行:n", "改行:r", "改行:rn",}):
                            raise ValueError("フォーマットエラー")

                        if Item == "改行:n":  # 署名のコンポーネントの連結に改行 \n が必要とされている場合、その情報を記録（対応：BitTrade）
                            JoinChar = "\n"  # 連結文字として改行 \n を設定
                        elif Item == "改行:r":  # 署名のコンポーネントの連結に改行 \r が必要とされている場合、その情報を記録（対応：備え）
                            JoinChar = "\r"  # 連結文字として改行 \r を設定
                        elif Item == "改行:rn":  # 署名のコンポーネントの連結に改行 \r\n が必要とされている場合、その情報を記録（対応：備え）
                            JoinChar = "\r\n"  # 連結文字として改行 \r\n を設定

                SignText = JoinChar.join(SignComponents)  # 署名用のテキストを構築（パフォーマンス向上のためメソッド join() を使用）

            return Host, SignBase64encode, SignBase64URLencode, SafeSign, JoinChar, SignText  # 処理した値を返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：署名を作成
        def CreateSign(ReturnStr, SignText, TextType, SignDict, SignKey, AuthType, SignBase64encode, SignBase64URLencode, SafeSign):
            """ この部分を「関数の docstring」と言います。
            署名を作成する関数。

            この関数は、引数に基づいて多様な形式の署名を作成します。作成した署名は、引数 SignDict 内に引数 SignKey をキーとして格納し、関数は署名の作成が完了
            したかを示す bool 値を返します。呼び出し元の関数 self.ExecuteAPIrequest() において、API シークレットの復号化及び使用はこの関数内に限定されて
            います。これによって、復号化された API シークレットがメモリ上に露出する時間を最小限に抑えることを実現しています。

            Parameters:
                ReturnStr (bool): 復号化関数に API シークレットを文字列型（str）として要求するフラグ。
                SignText (str): 署名用のテキスト。
                TextType (str): 文字列型の API シークレットと署名用のテキストをエンコードする文字コード。
                SignDict (dict): 作成した署名を格納する辞書の参照。
                SignKey (str): SignDict の署名にアクセスするキー。
                AuthType (str): 認証方式を表す文字列。
                SignBase64encode (bool): 署名を Base64 エンコードすることが必要とされていることを示すフラグ。
                SignBase64URLencode (bool): 署名を Base64 URL エンコードすることが必要とされていることを示すフラグ。
                SafeSign (bool): 署名を URL セーフエンコードすることが必要とされていることを示すフラグ。

            Returns:
                bool: 署名の作成が完了した場合、True。そうでなければ False。
            """
            # AES 暗号化された API シークレットを取得
            APIsecret_EncryptedBytes = getattr(self.App, "APIsecret_EncryptedBytes_{0}".format(str(self.EngineNum)), None)
            self.LogManager.RecordBackLOG("APIclient：API シークレット復号化開始", self.ThreadID)
            try:  # エラーを検出するブロック
                # グローバル関数を呼び出して API シークレットを復号化
                APIsecret_DecryptedBytes = ErrorHandler_ofEncryptOrDecrypt(self.LogManager, self.App, APIsecret_EncryptedBytes,
                    "API シークレット", ThreadID = self.ThreadID, Decrypt = True, ReturnStr = ReturnStr)  # API シークレットの復号化
                if not APIsecret_DecryptedBytes:  # API シークレットの復号化に失敗している場合、処理を終了
                    return False  # 処理を終了して False を返す
                self.LogManager.RecordBackLOG("APIclient：API シークレット復号化完了", self.ThreadID)
                if isinstance(APIsecret_DecryptedBytes, str):  # 署名に使用する API シークレットを UTF-8 以外でエンコードしなければならない場合
                    APIsecret_DecryptedBytes = APIsecret_DecryptedBytes.encode(TextType)  # API シークレットを TextType でエンコード

                if AuthType == "HMAC":  # HMAC 認証方式の場合
                    # HMAC オブジェクトを作成
                    SignDict[SignKey] = hmac.new(APIsecret_DecryptedBytes, SignText.encode(TextType), hashlib.sha256)
                else:  # 未対応の認証方式の場合、処理を終了
                    self.LogManager.RecordBackLOG("APIclient：未対応の認証方式「{0}」".format(str(AuthType)), self.ThreadID)
                    return False  # 処理を終了して False を返す

                if SignBase64encode:  # 署名を Base64 エンコードすることが必要とされていることを示すフラグが有効な場合
                    SignDict[SignKey] = base64.b64encode(SignDict[SignKey].digest()).decode()  # メッセージダイジェストを Base64 エンコード
                elif SignBase64URLencode:  # 署名を Base64 URL エンコードすることが必要とされていることを示すフラグが有効な場合
                    # メッセージダイジェストを Base64 URL エンコード
                    SignDict[SignKey] = base64.urlsafe_b64encode(SignDict[SignKey].digest()).decode()
                else:  # 署名を Base64 エンコードすることが必要とされていることを示すフラグが無効な場合、SafeSign に基づいてメッセージダイジェストを作成
                    if SafeSign:  # URL セーフエンコードが求められている場合、16 進数の URL セーフメッセージダイジェストを作成
                        SignDict[SignKey] = urllib.parse.quote_plus(SignDict[SignKey].hexdigest())
                    else:  # URL セーフエンコードが求められていない場合、16 進数のメッセージダイジェストを作成
                        SignDict[SignKey] = SignDict[SignKey].hexdigest()

                self.LogManager.RecordBackLOG("APIclient：署名作成完了", self.ThreadID)
                return True  # 署名の作成が完了したことを示す True を返す
            finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                APIsecret_DecryptedBytes = None  # 使用完了した復号化データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                SignDict = None  # 使用完了した API シークレットを含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：復号化した API キーを取得
        def GetAPIkey():
            """ この部分を「関数の docstring」と言います。
            復号化した API キーを取得する関数。

            この関数は、AES 暗号化された API キーを取得し、グローバル関数を呼び出して復号化し、復号化した文字列型（str）の API キーを返します。この関数の
            返り値は、直接クエリパラメータやヘッダーのコンポーネントを格納する各辞書の要素として代入されることを想定しています。これにより、復号化された
            API キーがメモリ上に複数露出する状況を回避可能となります。ただし、この実装はクエリパラメータとヘッダーの両方に API キーを含める必要が生じた場合、
            この関数で呼び出している復号化処理を都度行うことになるため、若干非効率となります。しかし、実際にクエリパラメータとヘッダーの両方に API キーを含める
            ことを求める API が存在することは稀であるため、呼び出し元の関数 self.ExecuteAPIrequest() ではこれを想定しません。ただし、想定はしないものの、
            実際にクエリパラメータとヘッダーの両方に API キーを含める設定がなされた場合でも、呼び出し元は正しく機能します。

            Parameters:
                なし。

            Returns:
                str: 復号化した API キー。

            Raises:
                InvalidKey: API キーの取得に失敗した場合に発生。
            """
            # AES 暗号化された API キーを取得
            APIkey_EncryptedBytes = getattr(self.App, "APIkey_EncryptedBytes_{0}".format(str(self.EngineNum)), None)
            self.LogManager.RecordBackLOG("APIclient：API キー復号化開始", self.ThreadID)
            try:  # エラーを検出するブロック
                # グローバル関数を呼び出して API キーを復号化
                APIkey_DecryptedStr = ErrorHandler_ofEncryptOrDecrypt(self.LogManager, self.App, APIkey_EncryptedBytes, "API キー",
                    ThreadID = self.ThreadID, Decrypt = True, ReturnStr = True)  # API キーの復号化
                if not APIkey_DecryptedStr:  # API キーの復号化に失敗している場合、InvalidKey を発生させる
                    raise InvalidKey("API キー取得失敗")
                self.LogManager.RecordBackLOG("APIclient：API キー復号化完了", self.ThreadID)
                return APIkey_DecryptedStr  # 復号化した API キーを返す
            finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                APIkey_DecryptedStr = None  # 使用完了した復号化データの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：クエリパラメータのコンポーネントが格納された辞書をシリアライズ
        def SerializeQuery(SortedQuery, SafeQuery, EscapePattern, SignKey = ""):
            """ この部分を「関数の docstring」と言います。
            クエリパラメータのコンポーネントが格納された辞書をシリアライズする関数。

            この関数は、クエリパラメータのコンポーネントが格納された辞書、引数 SortedQuery を引数 SafeQuery、EscapePattern に基づいてシリアライズします。
            シリアライズ処理はエンコード処理も含み、SafeQuery が True の場合は URL セーフエンコードを行います。加えて EscapePattern が 1 以外の場合は
            特定の記号を置換する特殊エスケープも行います。SafeQuery が False の場合は URL セーフエンコードを行わず、単純にキーバリューアサインメントを
            シリアライズします。

            Parameters:
                SortedQuery (dict): クエリパラメータのコンポーネントを格納する辞書の参照。
                SafeQuery (bool): クエリパラメータを URL セーフエンコードすることが必要とされていることを示すフラグ。
                EscapePattern (int): 特殊文字のエスケープパターンを指定する整数値（1 または 2）。標準エスケープまたは特殊エスケープ。
                SignKey (str, optional): SignDict の署名にアクセスするキー。シリアライズ結果に署名を含めない場合に指定。

            Returns:
                str, str:
                    単純シリアライズまたは標準エスケープしたクエリパラメータ文字列と、特殊エスケープしたクエリパラメータ文字列。後者は条件により空文字列。
            """
            try:  # エラーを検出するブロック
                if SignKey and SignKey in SortedQuery:  # SignKey を渡されていてクエリパラメータのコンポーネントを格納する辞書にキーが存在する場合
                    ModifiedQuery = copy.deepcopy(SortedQuery)  # クエリパラメータのコンポーネントを格納する辞書を深いコピー
                    del ModifiedQuery[SignKey]  # 深いコピーから SignKey キーを削除
                    SignKeyIsDeleted = True  # 深いコピーから SignKey キーを削除したことを示すフラグを有効化
                else:  # 前の条件に該当しない場合
                    ModifiedQuery = SortedQuery  # 深いコピーの変数にクエリパラメータのコンポーネントを格納する辞書の参照を代入
                    SignKeyIsDeleted = False  # 深いコピーから SignKey キーを削除したことを示すフラグを無効化

                # SafeQuery が有効な場合、ModifiedQuery を URL セーフエンコード、そうでなければエンコードせずにクエリパラメータとしてシリアライズ
                QueryString_1 = urlencode(ModifiedQuery) if SafeQuery \
                    else "&".join(["{0}={1}".format(str(Key), str(Value)) for Key, Value in ModifiedQuery.items()])

                QueryString_2 = ""  # 特殊エスケープを施したクエリパラメータの文字列を格納する変数を初期化
                if SafeQuery and not EscapePattern == self.App.標準:  # 特殊エスケープが求められている場合
                    QueryString_2 = QueryString_1.replace("+", "%20").replace("*", "%2A").replace("%7E", "~")  # 特定の記号を置換

                if not SignKeyIsDeleted:  # 深いコピーから SignKey キーを削除したことを示すフラグが無効な場合のログ記録
                    self.LogManager.RecordBackLOG("APIclient：クエリパラメータ構築完了", self.ThreadID)

                return QueryString_1, QueryString_2  # シリアライズしたクエリパラメータを返す
            finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                SortedQuery = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                ModifiedQuery = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                QueryString_1 = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                QueryString_2 = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                if not SafeQuery:  # SafeQuery が無効な場合
                    Value = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：クエリパラメータ構築指示文字列を処理
        def ProcessParamsString(ParamsString, TextType, EscapePattern, Domain, Path, Timestamp, SignDict, ProductCode, OrderType, Side,
            Price, Size, CallerIsSign = False):
            """ この部分を「関数の docstring」と言います。
            クエリパラメータ構築指示文字列を処理する関数。

            この関数は、クエリパラメータ構築指示文字列を処理するためのものです。クエリパラメータ構築指示文字列はリクエストボディの構築にも使用可能なものとして
            設計されているため、この関数では必要に応じてリクエストボディの構築も行います。また、クエリパラメータまたはリクエストボディの各パラメータ
            （コンポーネント）の順序が重要な場合、クエリパラメータ構築指示文字列の指示順序がそのまま処理順序となるため、パラメータの順序はクエリパラメータ構築
            指示文字列から直接指定可能です。関数の実行中に変更する可能性のあるエンクロージングスコープの変数は nonlocal キーワードによって参照及び変更します。

            Parameters:
                ParamsString (str):
                    クエリパラメータ構築指示文字列。
                    クエリパラメータのコンポーネントを "," で区切り、キーと値を ":" で区切ったもの。必要ない場合は "None"（str）。
                TextType (str): リクエストボディの各種コンポーネントのエンコードタイプ。
                EscapePattern (int): 特殊文字のエスケープパターンを指定する整数値（1 または 2）。標準エスケープまたは特殊エスケープ。
                Domain (str): API のドメイン。"http" で始まるものを指定（例: "https://api.bitflyer.com"）。
                Path (str): リクエストのパス。API のエンドポイントを指定（例: "/v1/getticker"）。
                Timestamp (str): 呼び出し元の関数 self.ExecuteAPIrequest() で扱われる Unix タイムスタンプ。
                SignDict (dict): 署名が格納されている辞書の参照。
                ProductCode (str): リクエストに使用する商品コード。
                OrderType (str): 注文タイプ（例: "LIMIT", "MARKET"）。
                Side (str): 取引種別（例: "BUY", "SELL"）。
                Price (float): 注文価格（LIMIT 注文の場合）。
                Size (float): 注文数量。
                CallerIsSign (bool, optional): 補助関数 ProcessSignString() による呼び出しかを示すフラグ。デフォルトは False。

            Returns:
                なし。

            Raises:
                ValueError: クエリパラメータ構築指示文字列のコンポーネントが適切な形式でない場合に発生。
            """
            # 補助関数：署名用クエリパラメータの分離保存
            def SignParamsSeparation(Key1, Key2, BuildingData, SignParams):
                """ この部分を「関数の docstring」と言います。
                署名用クエリパラメータの分離保存を行う関数。

                この関数は、署名にクエリパラメータの "一部" を含めることが必要とされている場合、専用の辞書 SignParams に引数 BuildingData[Key2] と同じ値
                を追加します。値の追加時に使用するキーも同じものを使用します。これにより、署名にクエリパラメータ全体ではなく、一部を含める必要がある場合に対応
                可能になります。

                Parameters:
                    Key1 (str): クエリパラメータ構築指示文字列から取り出した、アプリケーション固有のキー。
                    Key2 (str): クエリパラメータ構築指示文字列から取り出した、暗号資産取引所固有のキー。
                    BuildingData (dict): クエリパラメータまたはリクエストボディのコンポーネントを格納する辞書の参照。
                    SignParams (dict): 署名用クエリパラメータのコンポーネントを格納する辞書の参照。

                Returns:
                    なし。
                """
                try:  # エラーを検出するブロック
                    if "in署名" in Key1:  # 署名にクエリパラメータの "一部" を含めることが必要とされている場合、専用の辞書に同じ値を追加
                        SignParams[Key2] = BuildingData[Key2]  # 同じ値を追加
                finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                    BuildingData = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    SignParams = None  # 使用完了した API キーを含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

            # 補助関数：フラグハンドラ
            def FlagHandler():
                """ この部分を「関数の docstring」と言います。
                フラグハンドラ関数。

                この関数は、この関数が定義されている補助関数 ProcessParamsString() のエンクロージングスコープのフラグ QueryBuilding、BodyBuilding、
                FlagChanged を nonlocal キーワードを使用して参照及び反転します。これにより、現在の状況を表す複数のフラグの変更を、この関数の呼び出しを行う
                だけで行うことが可能になります。

                Parameters:
                    なし。

                Returns:
                    なし。
                """
                nonlocal QueryBuilding, BodyBuilding, FlagChanged  # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
                QueryBuilding, BodyBuilding, FlagChanged = not QueryBuilding, not BodyBuilding, not FlagChanged  # フラグの値を反転
                """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

            # 補助関数：コンポーネントを処理
            def ProcessComponent(SignParams, SortedQuery, RequestBody, BuildingData, CurrentRef, SignRef, TextType, Item, Timestamp,
                SignDict, ProductCode, OrderType, Side, Price, Size):
                """ この部分を「関数の docstring」と言います。
                コンポーネントを処理する関数。

                この関数は、クエリパラメータ構築指示文字列から取り出されたコンポーネントを処理するためのものです。この関数が定義されている補助関数
                ProcessParamsString() のエンクロージングスコープのイミュータブル属性は nonlocal キーワードを使用して参照及び変更します。また、エラーを
                記録するために必要となる情報も補助関数 ProcessParamsString() のエンクロージングスコープのものをクロージャによって参照します。

                Parameters:
                    SignParams (dict): 署名用クエリパラメータのコンポーネントを格納する辞書の参照。
                    SortedQuery (dict): クエリパラメータのコンポーネントを格納する辞書の参照。
                    RequestBody (dict): リクエストボディのコンポーネントを格納する辞書の参照。
                    BuildingData (dict): クエリパラメータまたはリクエストボディのコンポーネントを格納する辞書の参照。
                    CurrentRef (dict): XML 形式に変換可能な辞書を構築中に変化する階層の現在の参照を記録する辞書の参照。
                    SignRef (dict): リクエストボディを XML 形式にすることが必要とされている場合に署名を後から追加するための辞書の参照を記録する辞書の参照。
                    TextType (str): リクエストボディの各種コンポーネントのエンコードタイプ。
                    Item (str): クエリパラメータ構築指示文字列から取り出されたコンポーネント。
                    Timestamp (str): 呼び出し元の呼び出し元の関数 self.ExecuteAPIrequest() で扱われる Unix タイムスタンプ。
                    SignDict (dict): 署名が格納されている辞書の参照。
                    ProductCode (str): リクエストに使用する商品コード。
                    OrderType (str): 注文タイプ（例: "LIMIT", "MARKET"）。
                    Side (str): 取引種別（例: "BUY", "SELL"）。
                    Price (float): 注文価格（LIMIT 注文の場合）。
                    Size (float): 注文数量。

                Returns:
                    dict: クエリパラメータまたはリクエストボディのコンポーネントを格納する辞書の参照。

                Raises:
                    ValueError:
                        ● パターン 1:
                            XML 形式に変換可能な辞書を構築中に変化する階層の現在の参照を記録する辞書が初期状態にも関わらずリクエストボディのコンポーネントを
                            格納する辞書が空でない場合に発生。
                        ● パターン 2: XML 形式に変換可能な辞書を構築中に変化する階層の現在の参照を記録する辞書に参照が記録されていない場合に発生。
                """
                # 補助関数：bitFlyer のクエリパラメータまたはリクエストボディのコンポーネントを処理
                def Params_ofbitFlyer():
                    """ この部分を「関数の docstring」と言います。
                    bitFlyer のクエリパラメータまたはリクエストボディのコンポーネントを処理する関数。

                    この関数は、bitFlyer で必要となるクエリパラメータまたはリクエストボディのコンポーネントを処理します。この関数でカバーするクエリパラメータ
                    またはリクエストボディは、他の暗号資産取引所のものとしても使用可能です。この関数は呼び出し元の補助関数 ProcessComponent() に必要な機能
                    を提供する専用関数として、不可分な関係で定義され、モジュールの他の部分で同様の機能が必要になるとは想定しないため、引数を取らず、必要な
                    エンクロージングスコープ属性の参照及び変更は nonlocal キーワードによって行います。

                    Parameters:
                        なし。

                    Returns:
                        bool: クエリパラメータまたはリクエストボディを処理した場合、True。そうでなければ False。
                    """
                    try:  # エラーを検出するブロック
                        # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
                        nonlocal BuildingData, Key1, Key2, Value, Val, ProductCode, OrderType, Side, Price, Size
                        if "これは暫定的な文字列です" in Val:  # 新たなキーバリューに対応する場合に変更する条件式
                            # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                            if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                BuildingData[Key2] = Value  # 暫定的にキーバリューを単純追加
                            else:  # リクエストボディを JSON または XML 形式にすることが必要とされている場合
                                Val = Value  # 暫定的に Value を取得

                            return True  # クエリパラメータまたはリクエストボディを処理したことを示す True を返す
                        else:  # どの条件にも該当しない場合、処理を終了
                            return False  # 処理を終了して False を返す
                    finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                        BuildingData = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                        Value = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                        Val = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

                # 補助関数：bitbank（アルファベット順）のクエリパラメータまたはリクエストボディのコンポーネントを処理
                def Params_ofbitbank():
                    """ この部分を「関数の docstring」と言います。
                    bitbank（アルファベット順）のクエリパラメータまたはリクエストボディのコンポーネントを処理する関数。

                    この関数は、bitbank で必要となるクエリパラメータまたはリクエストボディのコンポーネントを処理します。この関数でカバーするクエリパラメータ
                    またはリクエストボディは、他の暗号資産取引所のものとしても使用可能です。この関数は呼び出し元の補助関数 ProcessComponent() に必要な機能
                    を提供する専用関数として、不可分な関係で定義され、モジュールの他の部分で同様の機能が必要になるとは想定しないため、引数を取らず、必要な
                    エンクロージングスコープ属性の参照及び変更は nonlocal キーワードによって行います。

                    Parameters:
                        なし。

                    Returns:
                        bool: クエリパラメータまたはリクエストボディを処理した場合、True。そうでなければ False。
                    """
                    try:  # エラーを検出するブロック
                        # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
                        nonlocal BuildingData, Key1, Key2, Value, Val, ProductCode, OrderType, Side, Price, Size
                        if "これは暫定的な文字列です" in Val:  # 新たなキーバリューに対応する場合に変更する条件式
                            # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                            if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                BuildingData[Key2] = Value  # 暫定的にキーバリューを単純追加
                            else:  # リクエストボディを JSON または XML 形式にすることが必要とされている場合
                                Val = Value  # 暫定的に Value を取得

                            return True  # クエリパラメータまたはリクエストボディを処理したことを示す True を返す
                        else:  # どの条件にも該当しない場合、処理を終了
                            return False  # 処理を終了して False を返す
                    finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                        BuildingData = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                        Value = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                        Val = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

                # 補助関数：BitTrade（アルファベット順）のクエリパラメータまたはリクエストボディのコンポーネントを処理
                def Params_ofBitTrade():
                    """ この部分を「関数の docstring」と言います。
                    BitTrade（アルファベット順）のクエリパラメータまたはリクエストボディのコンポーネントを処理する関数。

                    この関数は、BitTrade で必要となるクエリパラメータまたはリクエストボディのコンポーネントを処理します。この関数でカバーするクエリパラメータ
                    またはリクエストボディは、他の暗号資産取引所のものとしても使用可能です。この関数は呼び出し元の補助関数 ProcessComponent() に必要な機能
                    を提供する専用関数として、不可分な関係で定義され、モジュールの他の部分で同様の機能が必要になるとは想定しないため、引数を取らず、必要な
                    エンクロージングスコープ属性の参照及び変更は nonlocal キーワードによって行います。

                    Parameters:
                        なし。

                    Returns:
                        bool: クエリパラメータまたはリクエストボディを処理した場合、True。そうでなければ False。
                    """
                    try:  # エラーを検出するブロック
                        # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
                        nonlocal BuildingData, Key1, Key2, Value, Val, ProductCode, OrderType, Side, Price, Size
                        if "これは暫定的な文字列です" in Val:  # 新たなキーバリューに対応する場合に変更する条件式
                            # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                            if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                BuildingData[Key2] = Value  # 暫定的にキーバリューを単純追加
                            else:  # リクエストボディを JSON または XML 形式にすることが必要とされている場合
                                Val = Value  # 暫定的に Value を取得

                            return True  # クエリパラメータまたはリクエストボディを処理したことを示す True を返す
                        else:  # どの条件にも該当しない場合、処理を終了
                            return False  # 処理を終了して False を返す
                    finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                        BuildingData = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                        Value = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                        Val = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

                # 補助関数：Coincheck（アルファベット順）のクエリパラメータまたはリクエストボディのコンポーネントを処理
                def Params_ofCoincheck():
                    """ この部分を「関数の docstring」と言います。
                    Coincheck（アルファベット順）のクエリパラメータまたはリクエストボディのコンポーネントを処理する関数。

                    この関数は、Coincheck で必要となるクエリパラメータまたはリクエストボディのコンポーネントを処理します。この関数でカバーする
                    クエリパラメータまたはリクエストボディは、他の暗号資産取引所のものとしても使用可能です。この関数は呼び出し元の補助関数
                    ProcessComponent() に必要な機能を提供する専用関数として、不可分な関係で定義され、モジュールの他の部分で同様の機能が必要になるとは想定
                    しないため、引数を取らず、必要なエンクロージングスコープ属性の参照及び変更は nonlocal キーワードによって行います。

                    Parameters:
                        なし。

                    Returns:
                        bool: クエリパラメータまたはリクエストボディを処理した場合、True。そうでなければ False。
                    """
                    try:  # エラーを検出するブロック
                        # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
                        nonlocal BuildingData, Key1, Key2, Value, Val, ProductCode, OrderType, Side, Price, Size
                        if "これは暫定的な文字列です" in Val:  # 新たなキーバリューに対応する場合に変更する条件式
                            # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                            if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                BuildingData[Key2] = Value  # 暫定的にキーバリューを単純追加
                            else:  # リクエストボディを JSON または XML 形式にすることが必要とされている場合
                                Val = Value  # 暫定的に Value を取得

                            return True  # クエリパラメータまたはリクエストボディを処理したことを示す True を返す
                        else:  # どの条件にも該当しない場合、処理を終了
                            return False  # 処理を終了して False を返す
                    finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                        BuildingData = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                        Value = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                        Val = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

                # 補助関数：GMOコイン（アルファベット順）のクエリパラメータまたはリクエストボディのコンポーネントを処理
                def Params_ofGMOコイン():
                    """ この部分を「関数の docstring」と言います。
                    GMOコイン（アルファベット順）のクエリパラメータまたはリクエストボディのコンポーネントを処理する関数。

                    この関数は、GMOコイン で必要となるクエリパラメータまたはリクエストボディのコンポーネントを処理します。この関数でカバーするクエリパラメータ
                    またはリクエストボディは、他の暗号資産取引所のものとしても使用可能です。この関数は呼び出し元の補助関数 ProcessComponent() に必要な機能
                    を提供する専用関数として、不可分な関係で定義され、モジュールの他の部分で同様の機能が必要になるとは想定しないため、引数を取らず、必要な
                    エンクロージングスコープ属性の参照及び変更は nonlocal キーワードによって行います。

                    Parameters:
                        なし。

                    Returns:
                        bool: クエリパラメータまたはリクエストボディを処理した場合、True。そうでなければ False。
                    """
                    try:  # エラーを検出するブロック
                        # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
                        nonlocal BuildingData, Key1, Key2, Value, Val, ProductCode, OrderType, Side, Price, Size
                        if "これは暫定的な文字列です" in Val:  # 新たなキーバリューに対応する場合に変更する条件式
                            # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                            if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                BuildingData[Key2] = Value  # 暫定的にキーバリューを単純追加
                            else:  # リクエストボディを JSON または XML 形式にすることが必要とされている場合
                                Val = Value  # 暫定的に Value を取得

                            return True  # クエリパラメータまたはリクエストボディを処理したことを示す True を返す
                        else:  # どの条件にも該当しない場合、処理を終了
                            return False  # 処理を終了して False を返す
                    finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                        BuildingData = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                        Value = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                        Val = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

                """ ProcessComponent() の記述 """
                try:  # エラーを検出するブロック
                    Before_AttrsStack = []  # リクエストボディを XML 形式にすることが必要とされている場合に属性を処理するためのスタックを初期化
                    After_AttrsStack = []  # リクエストボディを XML 形式にすることが必要とされている場合に評価後の属性を処理するためのスタックを初期化

                    # クエリパラメータ構築指示をキーと値に分割し、余計な空白を除去
                    Key1, Key2, Value = [Part.strip() for Part in Item.split(":")]
                    # （Key1 は アプリケーション固有のキー、Key2 と Value は API ドキュメント記載の適切なキーバリューの値）
                    """
ここでは、メソッド split() が三つの要素を含むリストを返すと分かっているため、結果を代入する先をあらかじめリストが含む要素の数だけ用意しておきます。このようにする
ことで、メソッドが返す複数の要素を含むリストを自動的にアンパックすることができ、リストの要素はそれぞれリスト内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                    """

                    nonlocal QueryBuilding, BodyBuilding, FlagChanged  # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
                    if FlagChanged:  # クエリパラメータまたはリクエストボディを構築していることを示すフラグが変更されたことを示すフラグが有効な場合
                        if QueryBuilding and not BodyBuilding:  # クエリパラメータを構築していることを示すフラグ状態の場合
                            BuildingData = SortedQuery  # 構築中データの変数にクエリパラメータのコンポーネントを格納する辞書の参照を設定
                        elif not QueryBuilding and BodyBuilding:  # リクエストボディを構築していることを示すフラグ状態の場合
                            BuildingData = RequestBody  # 構築中データの変数にリクエストボディのコンポーネントを格納する辞書の参照を設定
                        FlagChanged = False  # クエリパラメータまたはリクエストボディを構築していることを示すフラグが変更されたことを示すフラグを無効化

                    nonlocal JSONbody, XMLbody, URLquery  # 引数として受け取らない外側のスコープの変更するローカル変数を宣言

                    # JSON または XML 形式に変換可能な辞書を構築中にクエリパラメータの構築を行った場合
                    if QueryBuilding and (JSONbody or XMLbody):
                        # クエリパラメータ構築指示文字列が JSON のキーまたは XML のルートタグまたはタグを指定するものである場合
                        if any(Check in Key1 for Check in {"^キー", "ルートタグ", "タグ",}):
                            FlagHandler()  # 各種フラグの値を反転し、リクエストボディの構築に切り替え
                            BuildingData = RequestBody  # 構築中データの変数にリクエストボディのコンポーネントを格納する辞書の参照を設定

                    # リクエストボディを JSON または XML 形式にすることが必要とされている場合、その形式の辞書を構築
                    if BodyBuilding and (JSONbody or XMLbody):
                        if JSONbody and XMLbody:  # JSON と XML のフラグが同時に有効になっている場合、ValueError を発生させる
                            Error_ofComponent(Item, Domain, Path, JsonXmlConflict = True)  # エラーを記録
                            raise ValueError("フォーマットエラー")

                        # JSON または XML 形式に変換可能な辞書を構築中に変化する階層の現在の参照を記録する辞書が初期状態の場合
                        if CurrentRef["Ref"] is None:
                            # JSON または XML 形式に変換可能な辞書を構築中に変化する階層の現在の参照を記録する辞書が初期状態にも関わらず
                            # リクエストボディのコンポーネントを格納する辞書が空でない場合、ValueError を発生させる
                            if not BuildingData == {}:
                                Error_ofComponent(Item, Domain, Path, IsBodyNotEmpty = True)  # エラーを記録
                                raise ValueError("フォーマットエラー")

                            CurrentRef["Ref"] = BuildingData  # JSON または XML 形式に変換可能な辞書を構築中に変化する階層の現在の参照を記録

                        # クエリパラメータ構築指示文字列が JSON のキーまたは XML のルートタグまたはタグを指定するもので階層を上がる指示 "/" でない場合
                        # （階層を上がる指示の場合は while はスキップすることになり、階層を上がる処理に移行）
                        if any(Check in Key1 for Check in {"^キー", "ルートタグ", "タグ",}) and not Key2.startswith("/"):
                            Tag, Attrs = Key2.split("&", 1) if "&" in Key2 else (Key2, "")  # XML の場合、"&" で分割してタグ名と属性情報を取得
                            if "ルートタグ" in Key1 and not Attrs and Value == "null":  # XML のルートタグで属性がなく、値も null の場合
                                # ルートタグを設定
                                CurrentRef["Ref"], _ = self.BuildDict_ofXMLorJSON(CurrentRef["Ref"], RootTag = Tag, JSON = JSONbody)
                                return CurrentRef["Ref"]  # リクエストボディのコンポーネントを格納する辞書の参照を返す
                            elif Attrs:  # XML の属性情報が存在する場合、タプル ("属性名", "属性値") のリストを取得
                                CurrentRef["Ref"], AttrList = self.BuildDict_ofXMLorJSON(  # 属性情報のリストを取得
                                    CurrentRef["Ref"], Attr = Attrs, JSON = JSONbody)
                                # 属性情報のリストで「リクエストボディを XML 形式にすることが必要とされている場合に属性を処理するためのスタック」を上書き
                                Before_AttrsStack.extend(AttrList)
                            # Value を「リクエストボディを XML 形式にすることが必要とされている場合に属性を処理するためのスタック」に追加
                            Before_AttrsStack.append(Value)
                        # クエリパラメータ構築指示文字列が JSON のキーまたは XML のタグ情報を示すものでない場合
                        elif all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ",}):
                            FlagHandler()  # 各種フラグの値を反転し、クエリパラメータの構築に切り替え
                            BuildingData = SortedQuery  # 構築中データの変数にクエリパラメータのコンポーネントを格納する辞書の参照を設定
                            # Key1 を「リクエストボディを XML 形式にすることが必要とされている場合に属性を処理するためのスタック」に追加
                            Before_AttrsStack.append(Key1)
                    elif QueryBuilding or BodyBuilding:  # 前の条件に該当しない場合
                        # Key1 を「リクエストボディを XML 形式にすることが必要とされている場合に属性を処理するためのスタック」に追加
                        Before_AttrsStack.append(Key1)

                    # リクエストボディを XML 形式にすることが必要とされている場合に属性を処理するためのスタックが空になるまでのループ
                    while Before_AttrsStack:
                        """
ここでは、リクエストボディを XML 形式にすることが必要とされている場合に属性を処理するためのループを展開していますが、このループ内の処理はその他の場合の処理にも
必要なため､「リクエストボディを XML 形式にすることが必要とされている場合に属性を処理するためのスタック」にその他の場合の Key1 を追加することでこれに対応して
います。この場合、ループ内の処理は一回だけ実行されることになり、ループにはなりません。
                        """
                        Item = Before_AttrsStack.pop(0)  # スタックから先頭の Item を取得しつつ削除（変数 Item を上書きして再利用）
                        AttrName, Val = Item if isinstance(Item, tuple) else ("", Item)  # Item がタプルの場合、属性名と属性値にアンパック
                        """
ここでは、Item がタプルの場合は必ず属性名と属性値の二つの要素を含むタプルであるという前提でアンパックを行っています。これは、先の処理で Key1 が "ルートタグ"
または "タグ" の場合で属性情報が存在する場合、関数 self.BuildDict_ofXMLorJSON() で同タプルを含むリストを取得し、スタックに上書きしているという前提によるもの
です。Item がタプルではない場合、属性名 AttrName には空文字列（str）を代入し、Val に Item を代入しています。Item がタプルではない場合の Item の内容は、先の
処理で再利用前の状態の Item を split() して取得した Key1、または Key1 が "^キー"、"ルートタグ"、"タグ" の場合の同 Value です。代入先を Val としているのは、
JSON 形式がより一般的に採用されており、クエリパラメータを構築する機会が少なく、XML 形式のリクエストボディを構築する必要が生じるのが稀であるため、より一般的な
JSON 形式で用いられる「キー」という表現に対応する命名を採用しているためです。
                        """

                        # 以下「パラメータ」は「クエリパラメータまたはリクエストボディ」のことを指す
                        if "APIキー" in Val:  # パラメータに API キーが必要とされている場合、構築中データの参照に追加
                            # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                            if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                # 対応：BitTrade
                                BuildingData[Key2] = GetAPIkey()  # API キーを追加
                                SignParamsSeparation(Val, Key2, BuildingData, SignParams)  # 署名用パラメータの分離保存
                            else:  # リクエストボディを JSON または XML 形式にすることが必要とされている場合
                                # 対応：備え
                                Val = GetAPIkey()  # API キーを取得
                        elif "タイムスタンプ" in Val:  # パラメータにタイムスタンプが必要とされている場合、構築中データの参照に追加
                            # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                            if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                # 対応：BitTrade
                                BuildingData[Key2] = Timestamp  # タイムスタンプを追加
                                SignParamsSeparation(Val, Key2, BuildingData, SignParams)  # 署名用パラメータの分離保存
                            else:  # リクエストボディを JSON または XML 形式にすることが必要とされている場合
                                # 対応：備え
                                Val = Timestamp  # タイムスタンプを取得
                        elif "^署名" in Val:  # パラメータに署名が必要とされている場合、構築中データの参照に追加
                            nonlocal SignKey  # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
                            if not CallerIsSign:  # 補助関数 ProcessSignString() による呼び出しかを示すフラグが無効な場合
                                # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                                if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                    # 対応：備え
                                    BuildingData[Key2] = SignDict[SignKey]  # 署名を追加
                                else:  # リクエストボディを JSON または XML 形式にすることが必要とされている場合
                                    # 対応：備え
                                    Val = SignDict[SignKey]  # 署名を取得
                            else:  # 補助関数 ProcessSignString() による呼び出しかを示すフラグが有効な場合
                                # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                                if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                    # 対応：BitTrade
                                    SignKey = Key2  # SignDict の署名にアクセスするキーを Key2 に設定
                                    BuildingData[SignKey] = None  # None を追加し、後続の処理で署名を追加可能にする
                                else:  # リクエストボディを JSON または XML 形式にすることが必要とされている場合
                                    # 対応：備え
                                    Val = b"SIGN" if AttrName else None  # b"SIGN" または None を代入し、後続の処理で署名を追加可能にする
                                    nonlocal NestedBodyRequireSign  # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
                                    NestedBodyRequireSign = True  # 複雑な辞書に署名が必要とされていることを識別するためのフラグを有効化

                                nonlocal QueryRequireSign, BodyRequireSign  # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
                                if QueryBuilding:  # クエリパラメータを構築していることを示すフラグが有効な場合
                                    QueryRequireSign = True  # クエリパラメータに署名が必要とされていることを識別するためのフラグを有効化
                                elif BodyBuilding:  # リクエストボディを構築していることを示すフラグが有効な場合
                                    BodyRequireSign = True  # リクエストボディに署名が必要とされていることを識別するためのフラグを有効化
                        elif "セーフクエリ" in Val:  # クエリパラメータを URL セーフエンコードすることが必要とされている場合、その情報を記録
                            # 対応：一般
                            nonlocal SafeQuery  # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
                            SafeQuery = True  # クエリパラメータを URL セーフエンコードすることが必要とされていることを示すフラグを有効化
                        # パラメータに Unicode ソートが必要とされている場合、構築中データの参照をソート
                        elif "ソート" in Val:  # このキーは ParamsString の各階層構築指示の最後、Key2.startswith("/") の前に位置している必要あり
                            """
ここでは、メソッド sorted() を使用して構築中データの辞書またはリストの要素をソートしています。メソッド sorted() は Unicode の文字コード順に従って要素をソート
し、Unicode は古い文字コード ASCII、ISO 8859 シリーズ、JIS、GB 2312、Big5、KOI8-R、MacRoman、Windows-1252 などをカバーする広範な文字コードであるため、
これによって特定の文字コード範囲で要素をソートする必要がある場合にもメソッド sorted() で単純にソートすることができます。
                            """
                            # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                            if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}) and not JSONbody and not XMLbody:
                                # 対応：BitTrade
                                SortedDict = sorted(BuildingData.items())  # 構築中データの辞書をソートしてリストを取得
                                BuildingData.clear()  # 構築中データの辞書の元の内容を消去
                                BuildingData.update(dict(SortedDict))  # ソート結果のリストを元の辞書に変換して構築中データの辞書に上書き
                            else:  # リクエストボディを JSON または XML 形式にすることが必要とされている場合
                                # 対応：備え
                                if isinstance(CurrentRef["Ref"], dict):  # 構築中データの参照が辞書の場合
                                    SortedDict = sorted(CurrentRef["Ref"].items())  # 構築中データの辞書をソートしてリストを取得
                                    CurrentRef["Ref"].clear()  # 構築中データの辞書の元の内容を消去
                                    CurrentRef["Ref"].update(dict(SortedDict))  # ソート結果のリストを元の辞書に変換して構築中データの辞書に上書き
                                elif isinstance(CurrentRef["Ref"], list):  # 構築中データの参照がリストの場合
                                    SortedList = sorted(CurrentRef["Ref"])  # 構築中データのリストをソートしてリストを取得
                                    CurrentRef["Ref"].extend(SortedList)  # ソート結果のリストで元のリストを上書き
                        elif "クエリ構築" in Val:  # クエリパラメータの構築を開始することが示された場合、フラグを切り替える
                            if BodyBuilding:  # リクエストボディを構築していることを示すフラグが有効なことを確認
                                FlagHandler()  # 各種フラグの値を反転
                        elif "ボディ構築" in Val:  # リクエストボディの構築を開始することが示された場合、フラグを切り替える
                            if QueryBuilding:  # クエリパラメータを構築していることを示すフラグが有効なことを確認
                                FlagHandler()  # 各種フラグの値を反転
                        elif "JSONボディ" in Val:  # リクエストボディを JSON 形式にすることが必要とされている場合、その情報を記録
                            # 対応：bitFlyer、bitbank、BitTrade、Coincheck、GMOコイン
                            JSONbody = True  # リクエストボディを JSON 形式にすることが必要とされていることを示すフラグを有効化
                        elif "XMLボディ" in Val:  # リクエストボディを XML 形式にすることが必要とされている場合、その情報を記録
                            # 対応：備え
                            XMLbody = True  # リクエストボディを XML 形式にすることが必要とされていることを示すフラグを有効化
                        elif "URLクエリ" in Val:  # リクエストボディを URL セーフエンコードすることが必要とされている場合、その情報を記録
                            # 対応：備え
                            URLquery = True  # リクエストボディを URL セーフエンコードすることが必要とされていることを示すフラグを有効化
                        elif Params_ofbitFlyer():  # bitFlyer でカバーされるパラメータの場合
                            """
ここでは、コンポーネントがどのパラメータに該当するかの評価を多くの取引所で見られる普遍的な順序で行っています。そして、各暗号資産取引所に固有のパラメータの評価を
最後に行っています。この評価順序により、頻繁に行うことが求められるクエリパラメータ構築指示文字列の処理において､「不一致」と評価する回数を可能な限り抑制することが
可能です。条件式の評価は高速に行われますが、条件が多い場合はマイクロ秒単位とは言え、やはり処理時間は増加します。API へのリクエストを頻繁に行うこのアプリケーション
では、小さな単位のパフォーマンスへの悪影響が全体のパフォーマンスの低下に繋がります。従って、アプリケーションの全体的なパフォーマンスに貢献するよう、適切な順序で
評価を行うことが重要になります。
                            """
                            # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                            if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                SignParamsSeparation(Val, Key2, BuildingData, SignParams)  # 署名用パラメータの分離保存
                        # bitbank、BitTrade、Coincheck、GMOコイン（アルファベット順）のいずれかでカバーされるパラメータの場合
                        # （いずれかが True となった場合、評価終了）
                        elif Params_ofbitbank() or Params_ofBitTrade() or Params_ofCoincheck() or Params_ofGMOコイン():
                            # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                            if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                SignParamsSeparation(Val, Key2, BuildingData, SignParams)  # 署名用パラメータの分離保存
                        # ここまでの条件に該当しない場合、構築中データの参照に Key2 と Value を追加
                        elif all(Check not in "null" for Check in {Key2, Value,}):  # Key2、Value のいずれも "null" でないことを確認
                            # リクエストボディを JSON または XML 形式にすることが必要とされていない場合
                            if all(Check not in Key1 for Check in {"^キー", "ルートタグ", "タグ"}):
                                BuildingData[Key2] = Value  # 暗号資産取引所固有の何らかのキーバリューであることを想定
                                SignParamsSeparation(Val, Key2, BuildingData, SignParams)  # 署名用パラメータの分離保存

                        # クエリパラメータ構築指示文字列が JSON のキーまたは XML のルートタグまたはタグを指定するものである場合、
                        # リクエストボディを XML 形式にすることが必要とされている場合に評価後の属性を処理するためのスタックに各種値を追加
                        if any(Check in Key1 for Check in {"^キー", "ルートタグ", "タグ",}):
                            if AttrName:  # 属性名が有効値を持つ場合、Key を属性値として取り扱う
                                After_AttrsStack.append((AttrName, Val,))  # 属性名と属性値のタプルをスタックに追加
                            else:  # 属性名が有効値を持たない場合、Key を JSON のキーまたは XML のタグの値として取り扱う
                                After_AttrsStack.append(Val)  # Val をスタックに追加
                                """
ここでは、Key の内容に基づいて処理した Val を「リクエストボディを XML 形式にすることが必要とされている場合に評価後の属性を処理するためのスタック」に追加して
います。このブロックの前の処理でリクエストボディを JSON または XML 形式にすることが必要とされていない場合に Key2 と Value を BuildingData に追加する処理を
行っていますが、これと同様の、リクエストボディを JSON または XML 形式にすることが必要とされている場合の処理は後続の処理で、Key2 は先に作成した変数 Tag として、
Value はスタックに追加した Key、即ち後続の処理で取り出して Value に代入する Val として処理します。このとき、Key の内容は先の処理で参照する Value と同じもの
になっています。
                                """

                    SavedValue = Value  # リクエストボディを XML 形式にすることが必要とされている場合に評価後の値を処理するために Value の状態を保存

                    # クエリパラメータ構築指示文字列がルートタグまたはタグを指定するもので階層を上がる指示 "/" でない場合
                    if any(Check in Key1 for Check in {"ルートタグ", "タグ",}) and not Key2.startswith("/"):
                        TagWithAttrs = Tag  # タグ名を初期化
                        # リクエストボディを XML 形式にすることが必要とされている場合に評価後の属性を処理するためのスタックが空になるまでのループ
                        while After_AttrsStack:
                            Item = After_AttrsStack.pop(0)  # スタックから先頭の Item を取得しつつ削除（変数 Item を上書きして再利用）
                            AttrName, Val = Item if isinstance(Item, tuple) else ("", Item)  # Item がタプルの場合、属性名と属性値にアンパック
                            if AttrName:  # 属性名が有効値を持つ場合
                                TagWithAttrs = "{0}&{1}={2}".format(str(TagWithAttrs), str(AttrName), str(Val))  # タグ名に属性情報を追加
                            else:  # 属性名が有効値を持たない場合
                                Value = Val  # タグ名の値を設定
                            """
ここでは､「リクエストボディを XML 形式にすることが必要とされている場合に評価後の属性を処理するためのスタック」を使用して while ループを展開し、先の while
ループで評価した属性値及びタグの値を処理しています。ここでの想定は、先の while ループで「タグ:タグ名&属性名1=属性値1&属性名2=属性値2:値」の形式のクエリ
パラメータ構築指示文字列を処理したことにより、スタックに属性情報のタプルが「定義された順序」で存在し、最後にタグの値が存在しているというものです。ここで重要なのは、
スタックには要素がクエリパラメータ構築指示文字列で「定義された順序」で存在しているという点です。定義された順序を保持するために、先の while ループではスタックから
要素を取り出す際にメソッド pop(0) を使用し、要素を先頭から取り出し、処理しています（メソッド pop() は 0、即ちインデックスを指定しないと、スタックの最後から要素
を取り出します）。そしてここでもスタックの先頭から要素を取り出すことで､「定義された順序」を維持した状態で「タグ名&属性名1=属性値1&属性名2=属性値2」という形式の
タグ名を作成しています。この形式のタグ名は、XML 形式に変換可能な辞書を構築する関数 self.BuildDict_ofXMLorJSON() によって辞書に組み込まれ、実際に XML 形式に
変換する関数 self.DictToXML() によって正しく処理されます。スタックから取り出した要素がタプルではない場合、while ループの中で Value に単純代入しており、
スタックにこのような要素が複数存在すると、先に取り出した要素が失われるという構造になっています。しかし、これは「タグ:タグ名&属性名1=属性値1&属性名2=属性値2:値」
という設計のクエリパラメータ構築指示文字列において､「:値」の部分のみが「スタックから取り出した要素がタプルではない」に該当するため、設計上 Value に値を代入する
のは一回のみということになり、不整合は起きません。また、属性が存在しない場合は、単にタグと値を取得します。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                            """

                        # 複雑な辞書に署名が必要とされていることを識別するためのフラグが有効な場合、後続の処理で署名を追加可能にする
                        if NestedBodyRequireSign:
                            # XML 形式に変換可能な辞書を構築中に変化する階層の現在の参照を記録する辞書が初期状態の場合、ValueError を発生させる
                            if CurrentRef["Ref"] is None:
                                Error_ofComponent(Item, Domain, Path, MissingRef = True)  # エラーを記録
                                raise ValueError("フォーマットエラー")

                            TagWithAttrs = "署名>" + TagWithAttrs  # タグ名の先頭に "署名>" を追加
                            SignRef["Ref"] = CurrentRef["Ref"]  # XML 形式に変換可能な辞書の署名が必要とされている階層の参照を記録
                            SignRef["Key"] = TagWithAttrs  # 署名を属性またはタグの値として必要としているタグ名を記録
                            """
ここでは、階層構造を持つ辞書内に後続の処理で署名を追加可能にするため、タグ名の先頭に "署名>" を追加しています。これは XML 形式に変換可能な辞書を構築する関数
self.BuildDict_ofXMLorJSON() に、渡したタグ名に辞書のキーとしての一意性を保証する番号を付与することを行わないようにすることを指示するためのものです。一意性を
保証する番号を付与しないキーが唯一存在することが、このキーの一意性を保証します。番号は「番号>」の形式で付与され、これは辞書を XML 形式に変換する関数
self.DictToXML() によって正しく除去されます。従って関数 self.ExecuteAPIrequest() 内では直接これを除去する処理を行う必要はありません。また階層構造を持つ
辞書内の署名の追加が必要な階層と、その階層の対象のキーを SignRef 辞書に記録しておくことで、後続の処理での署名追加処理が容易になるようにしています。
                            """

                        if Value == "null":  # 値がnullの場合
                            self.CurrentRef, _ = self.BuildDict_ofXMLorJSON(self.CurrentRef, Tag = TagWithAttrs)  # タグを設定
                        else:  # 値がnullでない場合
                            if Key1 == "ルートタグ":  # ルートタグの場合
                                self.CurrentRef, _ = self.BuildDict_ofXMLorJSON(self.CurrentRef, RootTag = TagWithAttrs, Value = Value)  # ルートタグと値を設定
                            else:  # タグの場合
                                self.CurrentRef, _ = self.BuildDict_ofXMLorJSON(self.CurrentRef, Tag = TagWithAttrs, Value = Value)  # タグと値を設定
                    elif Key1 == "タグ" and Key2.startswith("/"):  # 保存されたKey1がタグで階層を上がる指示の場合
                        self.CurrentRef, _ = self.BuildDict_ofXMLorJSON(self.CurrentRef, Tag = Key2)  # 階層を上がる処理

                    return BuildingData  # クエリパラメータまたはリクエストボディのコンポーネントを格納する辞書の参照を返す
                finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                    SignParams = None  # 使用完了した API キーを含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    SortedQuery = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    RequestBody = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    BuildingData = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    SignDict = None  # 使用完了した API シークレットを含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    After_AttrsStack = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    Key1 = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

            """ ProcessParamsString() の記述 """
            # 引数として受け取らない外側のスコープの変更するローカル変数を宣言
            nonlocal SignParams, SortedQuery, RequestBody, JSONbody, XMLbody, URLquery, SafeQuery, SerializedParams, \
                SignParamsSerialized, SignKey, QueryRequireSign, BodyRequireSign, NestedBodyRequireSign, SignRef
            """
            エンクロージングスコープでの初期化順序で並べています。
            このレベルでは実際には多くの変数は直接的には変更しません。変数の出自の可視化を目的とした宣言です。
            """
            # クエリパラメータ及びリクエストボディのコンポーネントを格納する辞書が空、
            # かつクエリパラメータ構築指示文字列が "null" でない場合、クエリパラメータの構築を行う
            if not SortedQuery and not RequestBody and not ParamsString == "null":
                try:  # エラーを検出するブロック
                    self.LogManager.RecordBackLOG("APIclient：クエリパラメータ構築開始", self.ThreadID)
                    BuildingData = {}  # クエリパラメータまたはリクエストボディのコンポーネントを格納する辞書の参照を保持する変数を初期化
                    CurrentRef = {"Ref": None}  # JSON または XML 形式に変換可能な辞書を構築中に変化する階層の現在の参照を記録する辞書を初期化
                    FlagChanged = True  # クエリパラメータまたはリクエストボディを構築していることを示すフラグが変更されたことを示すフラグを初期化
                    QueryBuilding = True  # クエリパラメータを構築していることを示すフラグを初期化
                    BodyBuilding = False  # リクエストボディを構築していることを示すフラグを初期化

                    # クエリパラメータ構築指示文字列を "," で分割してリストを取得し、余計な空白を除去し、空文字列を除去し、
                    # クエリパラメータ構築指示を順に処理するためのイテレーション
                    # （"," がない場合、文字列が唯一のイテレータとなり、空文字列の場合、イテレーションは実行されない）
                    for Item in filter(None, [item.strip() for item in ParamsString.split(",")]):
                        # Item が適切な形式でない場合、ValueError を発生させる
                        if Error_ofComponent(Item, Domain, Path, StringName = "クエリパラメータ"):
                            raise ValueError("フォーマットエラー")

                        BuildingData = ProcessComponent(  # コンポーネントを補助関数で処理
                            SignParams, SortedQuery, RequestBody, BuildingData, CurrentRef, SignRef, TextType, Item, Timestamp,
                            SignDict, ProductCode, OrderType, Side, Price, Size)

                    # 補助関数 ProcessSignString() による呼び出しかを示すフラグが有効、
                    # かつ署名用クエリパラメータのコンポーネントを格納する辞書が空でない場合、署名用クエリパラメータをシリアライズするために参照を変更
                    if CallerIsSign and SignParams:
                        SortedQuery = SignParams  # クエリパラメータの参照を署名用クエリパラメータの参照に変更
                        SignParamsSerialized = True  # 署名用クエリパラメータをシリアライズしたことを示すフラグを有効化

                    # クエリパラメータのコンポーネントが格納された辞書が構築されていて補助関数 ProcessSignString() による呼び出しかを示すフラグが無効な
                    # 場合、署名部分を含めてシリアライズ
                    if SortedQuery and not CallerIsSign:
                        # クエリパラメータのコンポーネントが格納された辞書をシリアライズ
                        # （返り値を EscapePattern でスライスし、必要なパターンを取得）
                        SerializedParams = SerializeQuery(SortedQuery, SafeQuery, EscapePattern)[EscapePattern - 1]
                    # クエリパラメータのコンポーネントが格納された辞書が構築されていて補助関数 ProcessSignString() による呼び出しかを示すフラグが有効な
                    # 場合、署名部分を含めずにシリアライズ
                    elif SortedQuery and CallerIsSign:
                        SerializedParams = SerializeQuery(SortedQuery, SafeQuery, EscapePattern, SignKey)[EscapePattern - 1]
                finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                    SignParams.clear()  # 使用完了した API キーを含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    SortedQuery = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    RequestBody = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    SignDict = None  # 使用完了した API シークレットを含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    SerializedParams = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            # クエリパラメータまたはリクエストボディのコンポーネントを格納する辞書が空でない、
            # かつどちらかの署名が必要とされていることを識別するためのフラグが有効な場合、クエリパラメータまたはリクエストボディまたはその両方に署名を含める
            elif (SortedQuery or RequestBody) and (QueryRequireSign or BodyRequireSign):
                try:  # エラーを検出するブロック
                    Stack = []  # クエリパラメータとリクエストボディの両方に署名を追加しなければならない場合のためのスタックを初期化
                    if QueryRequireSign:  # クエリパラメータに署名が必要とされていることを識別するためのフラグが有効な場合、スタックに参照を追加
                        Stack.append(SortedQuery)  # クエリパラメータのコンポーネントを格納する辞書の参照をスタックに追加
                    if BodyRequireSign:  # リクエストボディに署名が必要とされていることを識別するためのフラグが有効な場合、スタックに参照を追加
                        Stack.append(RequestBody)  # リクエストボディのコンポーネントを格納する辞書の参照をスタックに追加

                    while Stack:  # スタックが空になるまでのループ
                        ProcessingDict = Stack.pop()  # スタックから処理を行うクエリパラメータまたはリクエストボディの辞書の参照を取得しつつ削除
                        if not XMLbody:  # リクエストボディを XML 形式にすることが必要とされていることを示すフラグが無効な場合
                            ProcessingDict[SignKey] = SignDict[SignKey]  # 処理中の辞書の該当箇所に署名を追加

                    if QueryRequireSign:  # クエリパラメータに署名が必要とされていることを識別するためのフラグが有効な場合、シリアライズ
                        # クエリパラメータのコンポーネントが格納された辞書をシリアライズ
                        # （返り値を EscapePattern でスライスし、必要なパターンを取得）
                        SerializedParams = SerializeQuery(SortedQuery, SafeQuery, EscapePattern)[EscapePattern - 1]
                finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
                    SortedQuery = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    RequestBody = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    SignDict = None  # 使用完了した API シークレットを含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    SerializedParams = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    Stack = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
                    ProcessingDict = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる

        # 補助関数：ヘッダー構築指示文字列を処理
        def ProcessHeaderString(HeaderString, Headers, Domain, Timestamp, SignDict, SignKey):
            """ この部分を「関数の docstring」と言います。
            ヘッダー構築指示文字列を処理する関数。

            この関数は、ヘッダー構築指示文字列を処理するためのものです。

            Parameters:
                HeaderString (str):
                    ヘッダー構築指示文字列。ヘッダーのコンポーネントを "," で区切り、キーと値を ":" で区切ったもの。必要ない場合は "None"（str）。
                Headers (dict): ヘッダーのコンポーネントを格納する辞書の参照。
                Domain (str): API のドメイン。"http" で始まるものを指定（例: "https://api.bitflyer.com"）。
                Timestamp (str): 呼び出し元の関数 self.ExecuteAPIrequest() で扱われる Unix タイムスタンプ。
                SignDict (dict): 署名が格納されている辞書の参照。
                SignKey (str): SignDict の署名にアクセスするキー。

            Returns:
                なし。

            Raises:
                ValueError: ヘッダー構築指示文字列のコンポーネントが適切な形式でない場合に発生。
            """
            if not HeaderString == "null":  # ヘッダー構築指示文字列が "null" でない場合、ヘッダーの構築を行う
                self.LogManager.RecordBackLOG("APIclient：認証ヘッダー構築開始", self.ThreadID)
                # ヘッダー構築指示文字列を "," で分割してリストを取得し、余計な空白を除去し、空文字列を除去し、
                # ヘッダー構築指示を順に処理するためのイテレーション
                # （"," がない場合、文字列が唯一のイテレータとなり、空文字列の場合、イテレーションは実行されない）
                for Item in filter(None, [item.strip() for item in HeaderString.split(",")]):
                    if Error_ofComponent(Item, Domain, Path, StringName = "ヘッダー"):  # Item が適切な形式でない場合、ValueError を発生させる
                        raise ValueError("フォーマットエラー")

                    Key1, Key2, Value = [Part.strip() for Part in Item.split(":")]  # ヘッダー構築指示をキーと値に分割し、余計な空白を除去
                    # （Key2 と Value は API ドキュメント記載の適切なもの）
                    # ヘッダーにユーザーエージェントが必要とされている場合、ヘッダーのコンポーネントを格納する辞書に追加
                    if Key1 == "ユーザーエージェント" and Value == "BitTrade":  # BitTrade の API の場合
                        Headers[Key2] = self.App.BitTradeUserAgent  # BitTrade の API の場合、ユーザーエージェントの指定値を追加
                    elif Key1 == "ユーザーエージェント":  # 特定の暗号資産取引所でない場合
                        Headers[Key2] = self.App.DefaultUserAgent  # ユーザーエージェントの固定値を追加（対応：備え）
                    elif Key1 == "APIキー":  # ヘッダーに API キーが必要とされている場合、ヘッダーのコンポーネントを格納する辞書に追加
                        Headers[Key2] = GetAPIkey()  # API キーを追加（対応：bitFlyer、bitbank、Coincheck、GMOコイン）
                    elif Key1 == "タイムスタンプ":  # ヘッダーにタイムスタンプが必要とされている場合、ヘッダーのコンポーネントを格納する辞書に追加
                        Headers[Key2] = Timestamp  # タイムスタンプを追加（対応：bitFlyer、bitbank、Coincheck、GMOコイン）
                    elif Key1 == "署名":  # ヘッダーに署名が必要とされている場合、ヘッダーのコンポーネントを格納する辞書に追加
                        Headers[Key2] = SignDict[SignKey]  # 署名を追加（対応：bitFlyer、bitbank、Coincheck、GMOコイン）
                    else:  # ここまでの条件に該当しない場合、ヘッダーのコンポーネントを格納する辞書に Key2 と Value を追加
                        Headers[Key2] = Value  # ヘッダーのコンポーネントを格納する辞書に Key2 と Value を追加

                self.LogManager.RecordBackLOG("APIclient：認証ヘッダー構築完了", self.ThreadID)
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：URL を作成
        def CreateURL(CallNum, EscapePattern, FrontSign, RearSign, Domain, Path, SignDict, QueryString_1, QueryString_2):
            """ この部分を「関数の docstring」と言います。
            URL を作成する関数。

            この関数は、引数に基づいて適切な形式の URL を作成します。

            Parameters:
                CallNum (int): 動作モードを指定する整数値。
                    1: UrlIncludeSign が有効で https:// を補完する必要がある場合のクエリパラメータ付き URL。
                    2: UrlIncludeSign が有効で https:// を補完する必要がない場合のクエリパラメータ付き URL。
                    3: UrlIncludeSign が無効で https:// を補完する必要がある場合のクエリパラメータ付き URL。
                    4: UrlIncludeSign が無効で https:// を補完する必要がない場合のクエリパラメータ付き URL。
                    5: クエリパラメータを URL に含める必要がない場合の、https:// を補完した、または補完しない URL。
                EscapePattern (int): 特殊文字のエスケープパターンを指定する整数値（1 または 2）。標準エスケープまたは特殊エスケープ。
                FrontSign (bool): URL パラメータの前方に署名を含めることが必要とされていることを示すフラグ。
                RearSign (bool): URL パラメータの後方に署名を含めることが必要とされていることを示すフラグ。
                Domain (str): API のドメイン。
                Path (str): リクエストのパス。API のエンドポイントを指定（例: "/v1/getticker"）。
                SignDict (dict): URL に署名を含める際に使用するキーに関連付けて署名を格納した辞書。
                QueryString_1 (str): クエリパラメータを URL セーフエンコードした文字列。
                QueryString_2 (str): クエリパラメータを URL セーフエンコードした文字列に特殊エスケープを施したもの。

            Returns:
                str: 作成した URL。
            """
            if CallNum == 1:  # https:// を補完する必要がある場合、かつ URL に署名を含めることが必要とされている場合
                # 標準エスケープで URL パラメータの前方に署名を含める場合の URL 構築
                if EscapePattern == self.App.標準 and FrontSign and not RearSign:
                    URL = "https://{0}{1}?{2}&{3}".format(str(Domain), str(Path), str(urlencode(SignDict)), str(QueryString_1))
                # 標準エスケープで URL パラメータの後方に署名を含める場合の URL 構築
                elif EscapePattern == self.App.標準 and not FrontSign and RearSign:
                    URL = "https://{0}{1}?{2}&{3}".format(str(Domain), str(Path), str(QueryString_1), str(urlencode(SignDict)))
                # 特殊エスケープで URL パラメータの前方に署名を含める場合の URL 構築
                elif not EscapePattern == self.App.標準 and FrontSign and not RearSign:
                    URL = "https://{0}{1}?{2}&{3}".format(str(Domain), str(Path), str(urlencode(SignDict)), str(QueryString_2))
                # 特殊エスケープで URL パラメータの後方に署名を含める場合の URL 構築
                elif not EscapePattern == self.App.標準 and not FrontSign and RearSign:
                    URL = "https://{0}{1}?{2}&{3}".format(str(Domain), str(Path), str(QueryString_2), str(urlencode(SignDict)))
            elif CallNum == 2:  # https:// を補完する必要がない場合、かつ URL に署名を含めることが必要とされている場合
                # 標準エスケープで URL パラメータの前方に署名を含める場合の URL 構築
                if EscapePattern == self.App.標準 and FrontSign and not RearSign:
                    URL = "{0}{1}?{2}&{3}".format(str(Domain), str(Path), str(urlencode(SignDict)), str(QueryString_1))
                # 標準エスケープで URL パラメータの後方に署名を含める場合の URL 構築
                elif EscapePattern == self.App.標準 and not FrontSign and RearSign:
                    URL = "{0}{1}?{2}&{3}".format(str(Domain), str(Path), str(QueryString_1), str(urlencode(SignDict)))
                # 特殊エスケープで URL パラメータの前方に署名を含める場合の URL 構築
                elif not EscapePattern == self.App.標準 and FrontSign and not RearSign:
                    URL = "{0}{1}?{2}&{3}".format(str(Domain), str(Path), str(urlencode(SignDict)), str(QueryString_2))
                # 特殊エスケープで URL パラメータの後方に署名を含める場合の URL 構築
                elif not EscapePattern == self.App.標準 and not FrontSign and RearSign:
                    URL = "{0}{1}?{2}&{3}".format(str(Domain), str(Path), str(QueryString_2), str(urlencode(SignDict)))
            elif CallNum == 3:  # https:// を補完する必要がある場合、かつ URL に署名を含めることが必要とされていない場合の URL 構築
                URL = "https://{0}{1}?{2}".format(str(Domain), str(Path), str(QueryString_1)) if EscapePattern == self.App.標準 else \
                    "https://{0}{1}?{2}".format(str(Domain), str(Path), str(QueryString_2))
            elif CallNum == 4:  # https:// を補完する必要がない場合、かつ URL に署名を含めることが必要とされていない場合の URL 構築
                URL = "{0}{1}?{2}".format(str(Domain), str(Path), str(QueryString_1)) if EscapePattern == self.App.標準 else \
                    "{0}{1}?{2}".format(str(Domain), str(Path), str(QueryString_2))
            elif CallNum == 5:  # クエリパラメータを URL に含める必要がない場合の URL 構築
                URL = "https://{0}{1}".format(str(Domain), str(Path)) if "://" not in Domain and "://" not in Path else \
                    "{0}{1}".format(str(Domain), str(Path))

            return URL  # 作成した URL を返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：状況に合わせた URL を作成
        def CreateContextualURL(Domain, Host, Path, UrlIncludeSign, SortedQuery, EscapePattern, FrontSign, RearSign, SignDict,
            QueryString_1, QueryString_2):
            """ この部分を「関数の docstring」と言います。
            状況に合わせた URL を作成する関数。

            この関数は、引数に基づいて補助関数 CreateURL() を適切な引数と共に呼び出し、適切な形式の URL を作成します。

            Parameters:
                Domain (str): API のドメイン。"http" で始まるものを指定（例: "https://api.bitflyer.com"）。
                Host (str): ホスト名。使用可能な場合はドメインに優先して使用。
                Path (str): リクエストのパス。API のエンドポイントを指定（例: "/v1/getticker"）。
                UrlIncludeSign (bool): URL に署名を含めることが必要とされていることを示すフラグ。
                SortedQuery (dict): クエリパラメータのコンポーネントを格納する辞書の参照。
                EscapePattern (int): 特殊文字のエスケープパターンを指定する整数値（1 または 2）。標準エスケープまたは特殊エスケープ。
                FrontSign (bool): URL パラメータの前方に署名を含めることが必要とされていることを示すフラグ。
                RearSign (bool): URL パラメータの後方に署名を含めることが必要とされていることを示すフラグ。
                SignDict (dict): URL に署名を含める際に使用するキーに関連付けて署名を格納した辞書。
                QueryString_1 (str): クエリパラメータを URL セーフエンコードした文字列。
                QueryString_2 (str): クエリパラメータを URL セーフエンコードした文字列に特殊エスケープを施したもの。

            Returns:
                str: 作成した URL。
            """
            # URL に署名を含めることが必要とされていることを示すフラグが有効、かつ Host が指定されているまたは指定されていない、
            # かつ Domain が null = Path にフルパスが格納されている場合のクエリパラメータ付き URL の構築
            if UrlIncludeSign and Domain == "null":
                URL = CreateURL(2, EscapePattern, FrontSign, RearSign, "", Path, SignDict, QueryString_1, QueryString_2)
            # URL に署名を含めることが必要とされていることを示すフラグが有効、かつ Host が指定されている、
            # かつ Domain が null = Path にフルパスが格納されていない場合のクエリパラメータ付き URL の構築
            elif UrlIncludeSign and Host and not Domain == "null":
                URL = CreateURL(1, EscapePattern, FrontSign, RearSign, Host, Path, SignDict, QueryString_1, QueryString_2)
            # URL に署名を含めることが必要とされていることを示すフラグが有効、かつ Host が指定されていない、
            # かつ Domain が null = Path にフルパスが格納されていない場合のクエリパラメータ付き URL の構築
            elif UrlIncludeSign and not Host and not Domain == "null":
                URL = CreateURL(2, EscapePattern, FrontSign, RearSign, Domain, Path, SignDict, QueryString_1, QueryString_2)
            # URL に署名を含めることが必要とされていることを示すフラグが無効、かつ Host が指定されているまたは指定されていない、
            # かつ Domain が null = Path にフルパスが格納されている場合のクエリパラメータ付き URL の構築
            elif not UrlIncludeSign and Domain == "null" and SortedQuery:
                URL = CreateURL(4, EscapePattern, FrontSign, RearSign, "", Path, SignDict, QueryString_1, QueryString_2)
            # URL に署名を含めることが必要とされていることを示すフラグが無効、かつ Host が指定されている、
            # かつ Domain が null = Path にフルパスが格納されていない場合のクエリパラメータ付き URL の構築
            elif not UrlIncludeSign and Host and not Domain == "null" and SortedQuery:
                URL = CreateURL(3, EscapePattern, FrontSign, RearSign, Host, Path, SignDict, QueryString_1, QueryString_2)
            # URL に署名を含めることが必要とされていることを示すフラグが無効、かつ Host が指定されていない、
            # かつ Domain が null = Path にフルパスが格納されていない場合のクエリパラメータ付き URL の構築
            elif not UrlIncludeSign and not Host and not Domain == "null" and SortedQuery:
                URL = CreateURL(4, EscapePattern, FrontSign, RearSign, Domain, Path, SignDict, QueryString_1, QueryString_2)
            elif Domain == "null":  # Domain が null = Path にフルパスが格納されている場合のクエリパラメータのない URL の構築
                URL = CreateURL(5, EscapePattern, FrontSign, RearSign, "", Path, SignDict, QueryString_1, QueryString_2)
            elif not Domain == "null":  # Domain が null = Path にフルパスが格納されていない場合のクエリパラメータのない URL の構築
                URL = CreateURL(5, EscapePattern, FrontSign, RearSign, Domain, Path, SignDict, QueryString_1, QueryString_2)

            return URL  # 作成した URL を返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        """ self.ExecuteAPIrequest() の記述 """
        try:  # エラーを検出するブロック
            SignDict = {}  # 署名を格納する辞書を初期化
            SignParams = {}  # 署名用クエリパラメータのコンポーネントを格納する辞書を初期化
            SortedQuery = {}  # クエリパラメータのコンポーネントを格納する辞書を初期化
            RequestBody = {}  # リクエストボディのコンポーネントを格納する辞書を初期化
            Timestamp = str(int(time.time()))  # 署名、またはクエリパラメータ、またはヘッダー用に現在の Unix タイムスタンプを文字列として取得
            """
ここでは、以下補助関数 ProcessParamsString() で使用する変数の初期化を行っています。同関数内でこれらの変数を初期化せず、ここで初期化を行っているのは、同関数が
このトップレベルだけでなく、補助関数 ProcessSignString() 内でも呼び出されるケースがあり、この場合初期化が重複してしまうためです。補助関数
ProcessParamsString() はこのトップレベルや補助関数 ProcessSignString() と密接な関係にあるため、以下の変数は引数として渡すのではなく、nonlocal キーワード
によって参照及び変更します。なお、一部の変数は補助関数 ProcessSignString() も nonlocal キーワードによって参照しますが、変更は行いません。nonlocal
キーワードは同関数の保守性向上のため、クロージャの利用では可視化されない、変数の出自の可視化を目的として使用しています。この関数は補助関数内で nonlocal
キーワードを多用しているため、以下にこの関数における変数のエコシステムを簡易的に示します。

def ExecuteAPIrequest():
    変数1 = 値  # 関数 ExecuteAPIrequest() のローカル変数（トップレベル）

    def ProcessSignString():
        変数2 = 値  # 補助関数 ProcessSignString() のローカル変数
        nonlocal 変数1  # 関数 ExecuteAPIrequest() 直下に定義されているため、外側、エンクロージングスコープのローカル変数にアクセス可能
        〜処理を行う〜
        return 変数2

    def ProcessParamsString():
        フラグ = 値  # 補助関数 ProcessParamsString() のローカル変数
        nonlocal 変数1  # 関数 ExecuteAPIrequest() 直下に定義されているため、外側、エンクロージングスコープのローカル変数にアクセス可能

        def FlagHandler():
            nonlocal フラグ  # 補助関数 ProcessParamsString() 直下に定義されているため、外側、エンクロージングスコープのローカル変数にアクセス可能

        def ProcessComponent():
            # 補助関数 ProcessParamsString() 直下に定義されているため、外側、エンクロージングスコープのローカル変数にアクセス可能
            # 補助関数 ProcessParamsString() は関数 ExecuteAPIrequest() 直下に定義されているため、
            # この関数は同関数のエンクロージングスコープのローカル変数にもアクセス可能
            nonlocal フラグ, 変数1

            def Params_ofbitFlyer():
                # 補助関数 ProcessComponent() 直下に定義されていて、同関数は補助関数 ProcessParamsString() 直下に定義されていて、
                # 同関数は関数 ExecuteAPIrequest() 直下に定義されているため、トップレベルのローカル変数にアクセス可能
                nonlocal 変数1
            """
            JSONbody = False  # リクエストボディを JSON 形式にすることが必要とされていることを示すフラグを初期化
            XMLbody = False  # リクエストボディを XML 形式にすることが必要とされていることを示すフラグを初期化
            URLquery = False  # リクエストボディを URL セーフエンコードすることが必要とされていることを示すフラグを初期化
            SafeQuery = False  # クエリパラメータを URL セーフエンコードすることが必要とされていることを示すフラグを初期化
            SerializedParams = ""  # クエリパラメータのコンポーネントが格納された辞書をシリアライズした文字列の変数を初期化
            SignParamsSerialized = False  # 署名用クエリパラメータをシリアライズしたことを示すフラグを初期化
            SignKey = "なし"  # SignDict の署名にアクセスするキーの変数を初期化
            QueryRequireSign = False  # 後続の処理がクエリパラメータに署名が必要とされていることを識別するためのフラグを初期化
            BodyRequireSign = False  # 後続の処理がリクエストボディに署名が必要とされていることを識別するためのフラグを初期化
            NestedBodyRequireSign = False  # 後続の処理が複雑な辞書に署名が必要とされていることを識別するためのフラグを初期化
            # リクエストボディを XML 形式にすることが必要とされている場合に署名を後から追加するための辞書の参照を記録する辞書を初期化
            SignRef = {"Ref": None}

            # 一般的な認証方式における署名作成での共通処理として、署名構築指示文字列を処理
            Host, SignBase64encode, SignBase64URLencode, SafeSign, JoinChar, SignText = \
                ProcessSignString(SignString, Domain, Path, Timestamp, Method, ProductCode, OrderType, Side, Price, Size)
            """
ここでは、関数が複数の要素を含むタプルを返すと分かっているため、関数の返り値を代入する先をあらかじめタプルが含む要素の数だけ用意しておきます。このようにすること
で、関数が返す複数の要素を含むタプルを自動的にアンパックすることができ、タプルの要素はそれぞれタプル内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """
            """
ここでは、補助関数を呼び出して署名構築指示文字列に従って署名用のテキストの構築を行っています。署名にクエリパラメータまたはリクエストボディ（以下、パラメータ）を
含めることが必要とされている場合、そのコンポーネントを処理する部分で補助関数 ProcessParamsString() を呼び出し、クエリパラメータ構築指示文字列に従って
パラメータの構築を行い、シリアライズしたパラメータ文字列を取得し、コンポーネントとして格納します。ただし、クエリパラメータ構築指示文字列に「パラメータに署名が必要
とされていることを示す指示」が含まれる場合、この段階では署名の格納は不可能なため、後続の処理で改めてこの処理を行います｡「署名にパラメータを含めることが必要とされて
いて、パラメータに署名が必要とされている」という特定の条件では、署名に含めるパラメータに署名は含めません。これを実現しようとすると、一度署名を作成してパラメータ
文字列を作成し、これを使用してもう一度署名を作成する、という不適切な状況になるためです。署名の各コンポーネントを連結する連結文字も署名構築指示文字列で指示され、
指示に従って連結文字を選択し、署名の各コンポーネントを連結します。ここでの補助関数の責務は署名用のテキストの構築までであり、実際の署名処理は別の補助関数が担います。
クエリパラメータ構築指示文字列の処理を先に行わないのは、パラメータに署名を含める必要がある場合に対応するためです。ここでは将来の拡張可能性を確保するために、補助
関数が返すことのできる値は全て返しています。返り値が多いのはこのためです。
            """

            ReturnStr = False if TextType == "utf-8" else True  # TextType が utf-8 の場合 ReturnStr を False に、そうでなければ True に設定
            # 補助関数で署名を作成し、失敗した場合、処理を終了
            if not CreateSign(
            ReturnStr, SignText, TextType, SignDict, SignKey, AuthType, SignBase64encode, SignBase64URLencode, SafeSign):
                return False  # 処理を終了して False を返す
            """
ここでは、先に行った処理で作成した署名用のテキストを用いて補助関数を呼び出し、実際の署名処理を行っています。ここで作成する署名には署名を除く全てのクエリパラメータ
またはリクエストボディが含まれる場合があり、署名にクエリパラメータまたはリクエストボディを含めることや、どのクエリパラメータまたはリクエストボディを署名に含めるか、
という指示は、署名構築指示文字列及びクエリパラメータ構築指示文字列に含まれます。作成した署名は専用の辞書 SignDict の参照を通じて利用可能となります。
            """

            # クエリパラメータ及びリクエストボディのコンポーネントを格納する辞書が空、
            # かつクエリパラメータ構築指示文字列が "null" でない場合、クエリパラメータの構築を行う
            # または、クエリパラメータまたはリクエストボディのコンポーネントを格納する辞書が空でない、
            # かつどちらかの署名が必要とされていることを識別するためのフラグが有効な場合、クエリパラメータまたはリクエストボディまたはその両方に署名を含める
            ProcessParamsString(  # クエリパラメータ構築指示文字列を処理
                ParamsString, TextType, EscapePattern, Domain, Path, Timestamp, SignDict, ProductCode, OrderType, Side, Price, Size)
            """
ここでは、補助関数を呼び出してクエリパラメータ構築指示文字列に従ってクエリパラメータまたはリクエストボディの構築を行っています。クエリパラメータの構築の場合、
クエリパラメータに含めるコンポーネントは特にエンコードをすることなく、プレーンテキストのまま取り扱っています。これは、クエリパラメータのコンポーネントは通常
プレーンテキストのまま送信するためです。ただしクエリパラメータとして特定の記号は使用できないため、クエリパラメータの構築完了後、シリアライズの際にクエリパラメータ
全体を URL セーフエンコードしています。ただしこのエンコードの必要性の指示がクエリパラメータ構築指示文字列に含まれない場合、URL セーフエンコードは行わず、クエリ
パラメータのキーバリューアサインメントを直接シリアライズします。
            """
            # 署名用クエリパラメータをシリアライズしたことを示すフラグが有効、かつクエリパラメータのコンポーネントを格納する辞書が空でない場合、
            # クエリパラメータをシリアライズ
            if SignParamsSerialized and SortedQuery:
                """
ここでは､「署名にクエリパラメータの "一部" を含めることが必要とされている」場合に発生する、
本来の URL 用のクエリパラメータがシリアライズされていない状況に対応しています。
                """
                # クエリパラメータのコンポーネントが格納された辞書をシリアライズ
                # （返り値を EscapePattern でスライスし、必要なパターンを取得）
                SerializedParams = SerializeQuery(SortedQuery, SafeQuery, EscapePattern)[EscapePattern - 1]

            Headers = {}  # ヘッダーのコンポーネントを格納する辞書を初期化
            ProcessHeaderString(HeaderString, Headers, Domain, Timestamp, SignDict, SignKey)  # ヘッダー構築指示文字列を処理
            """
ここでは、補助関数を呼び出してヘッダー構築指示文字列に従ってヘッダーの構築を行っています。ヘッダーの構築の際、ヘッダーに含めるコンポーネントは特にエンコードをする
ことなく、プレーンテキストのまま取り扱っています。これは、ヘッダーは通常プレーンテキストのまま送信されるためです。ヘッダーのコンポーネントをエンコードする必要が
ある場合、それは通常とは異なる仕様を採用しているということになりますので、API ドキュメントに記載されている指示に従う必要があります。ここでは、API ドキュメントで
特に言及されていない一般的な処理を行っているため、そのような特別な処理は別途実装を行う必要があります。
            """

            URL = ""
            # URL = CreateContextualURL(Domain, Host, Path, UrlIncludeSign, SortedQuery, EscapePattern, FrontSign, RearSign, SignDict,
                # QueryString_1, QueryString_2)  # 適切な形式の URL を作成

            if Method.upper() == "GET":  # メソッドが GET の場合
                Request = urllib.request.Request(URL, headers = Headers, method = Method.upper())  # GET リクエストの作成
            elif Method.upper() == "POST":  # メソッドが POST の場合
                # POST リクエストの作成、RequestBody は bytes 型で渡す必要あり
                Request = urllib.request.Request(URL, data = RequestBody, headers = Headers, method = Method.upper())
            with urllib.request.urlopen(Request) as Response:  # リクエストの送信及びレスポンスの取得
                ResponseData = Response.read().decode("utf-8")  # レスポンスデータの取得及びデコード（str）
                self.LogManager.RecordBackLOG("APIclient：リクエスト成功「{0}」".format(str(Response.getcode())), self.ThreadID)
                return {"StatusCode": Response.getcode(), "Data": ResponseData,}  # レスポンスデータを返す
        except urllib.error.HTTPError as e:  # HTTPError が発生した場合
            ErrorResponse = e.read().decode("utf-8")  # レスポンスデータの取得及びデコード（str）
            if e.code < 500:  # クライアントエラーの場合
                self.LogManager.RecordBackLOG("APIclient：クライアントエラー「{0}、{1}、{2}」".format(
                    str(e.code), str(e.reason), ErrorResponse), self.ThreadID)
            else:  # サーバーエラーの場合
                self.LogManager.RecordBackLOG("APIclient：サーバーエラー「{0}、{1}、{2}」".format(
                    str(e.code), str(e.reason), ErrorResponse), self.ThreadID)
            return False  # 処理を終了して False を返す
        except urllib.error.URLError as e:  # URLError が発生した場合
            self.LogManager.RecordBackLOG("APIclient：ネットワークエラー「{0}」".format(str(e.reason)), self.ThreadID)
            return False  # 処理を終了して False を返す
        except Exception as e:  # 何らかのエラーが発生した場合
            self.LogManager.RecordBackLOG("APIclient：リクエスト失敗「{0}」".format(str(e)), self.ThreadID)
            return False  # 処理を終了して False を返す
        finally:  # try または except ブロックの範囲の終了または関数の終了直前に必ず実行するブロック
            SignDict = None  # 使用完了した API シークレットを含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            SignParams = None  # 使用完了した API キーを含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            SortedQuery = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            RequestBody = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            SerializedParams = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            Headers = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
            URL = None  # 使用完了した敏感情報を含むデータの変数を None で上書きしてガベージコレクタに早期にメモリ回収させる
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # ドットで区切られたデータパス、引数 PathForStructure に従って値を引数 StructuredData["Data"] の指定された位置に格納する関数
    def SetDataVal(self, DatasetName, Tupled_orListed_values, StructuredData, PathForStructure):
        """ この部分を「関数の docstring」と言います。
        ドットで区切られたデータパス、引数 PathForStructure に従って値を引数 StructuredData["Data"] の指定された位置に格納する関数。

        この関数は、前提として引数として渡される辞書 StructuredData に "TemplateForm" "TemplatePath" "Data" の三つのキーが並列に設定されている必要が
        あります。また、"TemplateForm" には "Data" を構造化するための、初期化されたデータ構造体が存在する必要があります。初期化されたデータ構造体とは、構造
        化したい "Data" の基本構造を持つ、全ての値が None に設定されたデータ構造体のことを言います。つまり、"Data" を構造化するためのテンプレートです。この
        データ構造体は複雑な構造を持つことができ、リストの中の辞書、その逆、さらに入れ子になったリストや辞書など、この関数は初期化されたデータ構造体が適切に提供
        される限り、これら複雑なデータ構造に対応することが可能です。この関数が現在対応しているデータ型は、リスト、辞書、タプルです。これら以外のデータ型を
        "Data" に含める必要が生じた場合、関数を拡張する必要があります。初期化されたデータ構造体には、反復可能、つまりイテラブルなデータ構造は要素として一つのみ
        格納されていることが求められます。この関数は、反復可能なデータ構造の構築を求められている場合、その唯一の要素を使用して "Data" を構造化します。このとき、
        反復可能なデータ構造はさらに複雑なデータ構造を持つことができます。注意点として、反復「不能」なデータ型に対しては、この関数は初期化されたデータ構造体を
        用いた "Data" の拡張を行うことはできません。"TemplateForm" の最終的な値の格納場所を None で初期化しておくことで、どのような値でも格納可能になり
        ます。また、"Data" は "TemplateForm" と同じデータ構造体で初期化済みである必要があります（既に当該箇所が初期化済みで、何らかの値が格納されている場合、
        問題は起きません。ただし指定された引数 PathForStructure が、既に値が格納されている箇所を指示している場合、値は上書きします）。"TemplatePath" は
        引数 PathForStructure がインデックス範囲外を指示する場合に、"Data" のリストを拡張するための適切なデータ構造体を "TemplateForm" から取得する際に
        使用するデータパスです。即ち、"TemplatePath" は "TemplateForm"、初期化されたデータ構造体のデータパスである必要があります。このデータパスも引数
        PathForStructure と同じくドット記法で引数 StructuredData に格納されている必要があります。"TemplatePath" のインデックス指定にあたるセグメントは
        「index」と記述します。"TemplateForm" "TemplatePath" の具体的な例は AppClass で定義されている self.DataHandleForm 属性を参照してください。
        この属性の "DataHandleNames" が "TemplateForm" に、"KeyPath" が "TemplatePath" に対応しています。

        この関数は、引数 StructuredData["Data"] の複数階層に渡るドット記法のデータパス、引数 PathForStructure を解析し、これに従って引数
        Tupled_orListed_values を引数 StructuredData["Data"] の適切な位置に格納します。引数 PathForStructure は文字列型（str）として受け取り、
        ドット（"."）で区切られた各セグメントを通じて引数 StructuredData["Data"] の深い階層にアクセスします。セグメントが文字列型（str）の場合は辞書のキー
        として扱い、整数値（int）の場合はリストやタプルのインデックス番号として解釈します。最後のセグメントに到達した時点で、引数 Tupled_orListed_values を
        その位置に格納します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            DatasetName (str): 構造化する StructuredData["Data"] のデータセット名。API のエンドポイント名など。エラー発生時のエラーメッセージに使用。
            Tupled_orListed_values (tuple or list of any values): 格納する値。タプルまたはリスト形式。
            StructuredData (dict):
                値を構造化及び格納する先の "Data" キーを含む辞書。"TemplateForm" "TemplatePath" も "Data" と共に格納されている必要あり。
            PathForStructure (str): StructuredData["Data"] に値を格納するための、ドット記法のデータパス。格納先としてインデックス範囲外を指定可能。

        Returns:
            dict: 元の StructuredData に値を格納した StructuredData。

        Raises:
            IndexError: テンプレートデータ StructuredData["TemplateForm"] にインデックスが存在しない場合に発生。
            KeyError: テンプレートデータ StructuredData["TemplateForm"] にキーが存在しない場合に発生。
            TypeError: テンプレートデータ StructuredData["TemplateForm"] が予期しないデータ型の場合に発生。
        """
        # 補助関数：インデックス番号がリストの範囲外であれば、対応するテンプレート構造体を追加
        def AppendIndexRangeOfTemplate(DatasetName, Key_i, KeyForStructure, Target, StructuredData):
            """ この部分を「関数の docstring」と言います。
            インデックス番号がリストの範囲外であれば、対応するテンプレート構造体を追加する関数。

            この関数は、指定されたデータパスに基づき、引数 Target（呼び出し元で取り扱い中の StructuredData["Data"] の所定の場所）のリストのインデックスが
            足りない場合に、引数 StructuredData["TemplateForm"] を参照して、適切な新しいデータ構造体をリストに追加します。引数
            StructuredData["TemplatePath"] は、テンプレート構造体 StructuredData["TemplateForm"] を使用してデータ構造 Target
            （StructuredData["Data"] 内）をどのように構築すべきかを指示するためのもので、リストのインデックス範囲外にアクセスしようとした場合に
            StructuredData["TemplateForm"] のどのデータ構造を追加すべきかを定義します。このプロセスにより、Target（StructuredData["Data"] 内）の
            リストをデータパスに従って適切に拡張し、データの格納に必要な構造を確実に用意します。

            Parameters:
                DatasetName (str):
                    構造化する StructuredData["Data"] のデータセット名。API のエンドポイント名など。エラー発生時のエラーメッセージに使用。
                Key_i (int):
                    呼び出し元が現在処理しているキー（引数 KeyForStructure）のインデックス。呼び出し元の引数 PathForStructure のセグメント位置に対応。
                KeyForStructure (int): 呼び出し元が現在処理しているキー。引数 Target（StructuredData["Data"] 内）のリストのインデックスとして使用。
                Target (list): 値を格納する先のリストの参照（呼び出し元の引数 StructuredData["Data"] 内）。ネストされたものにも対応。
                StructuredData (dict):
                    値を格納する StructuredData["Data"] を含む全体のデータ構造の参照。"TemplateForm" と "TemplatePath" を含む。

            Returns:
                なし。

            Raises:
                ValueError: テンプレートデータにキーが存在しない場合に発生。
            """
            # インデックス番号がリストの範囲外の場合、対応するテンプレート構造体を追加
            if isinstance(KeyForStructure, int) and isinstance(Target, list) and len(Target) <= KeyForStructure:
                Template_DataForm = StructuredData.get("TemplateForm", {})  # StructuredData からテンプレート構造体全体を取得
                Template_Keys = StructuredData.get("TemplatePath", "").split(".")  # テンプレート構造体のデータパスをドットで分割してリストを取得
                # 呼び出し元が現在処理しているキーに対応するセグメントまでテンプレートキーを取り出し、対応するテンプレート構造体を特定するためのイテレーション
                for Template_Key_i, Template_Key in enumerate(Template_Keys):
                    # テンプレート構造体のデータパスの index セグメントは 0（文字列型、str）に置き換える
                    # （テンプレート構造体のリストの唯一の要素を取り出すため）
                    Template_Key = Template_Key if not "index" == Template_Key else "0"
                    # テンプレート構造体のデータパスのセグメントが整数の場合、型変換して整数値（int）を取得
                    Template_Key = Template_Key if not Template_Key.strip().isdigit() else int(Template_Key.strip())
                    # テンプレート構造体のデータパスの最適化されたセグメントを使用してテンプレート構造体の現在地を更新
                    if isinstance(Template_DataForm, dict):
                        # Template_Key で Template_DataForm を更新
                        # （Template_Key が対象に存在しないエラー時は空文字列（str）を格納し、後続のコードで検知）
                        Template_DataForm = Template_DataForm.get(Template_Key, "")
                    elif isinstance(Template_DataForm, list):
                        # Template_Key で Template_DataForm を更新
                        # （Template_Key が対象に存在しないエラー時は空文字列（str）を格納し、後続のコードで検知）
                        Template_DataForm = Template_DataForm[Template_Key] if len(Template_DataForm) > Template_Key else ""

                    # Template_Key が Template_DataForm に存在しない場合、これをエラーとして ValueError を発生させる
                    if Template_DataForm == "":
                        raise ValueError(("テンプレートデータにキーが存在しません。内部エラーのため、開発者に連絡してください。"
                            "データセット名：{0}、キー：{1}").format(str(DatasetName), str(".".join(Template_Keys))))

                    # Template_Key_i が Key_i と等価 = 呼び出し元が現在処理しているキーに対応するテンプレート構造体に到達
                    if Template_Key_i == Key_i:
                        break  # イテレーションを終了してテンプレート構造体を Target に追加する処理に移行

                while len(Target) <= KeyForStructure:  # 必要な範囲長までリストを Template_DataForm で拡張
                    # 関数 copy.deepcopy() を使用して、参照ではなくテンプレート構造体の複製を追加
                    Target.append(copy.deepcopy(Template_DataForm))
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        """ self.SetDataVal() の記述 """
        KeysForStructure = PathForStructure.split(".")  # 値の格納先を指示するデータパスをドットで分割してリストを取得
        Processed_Keys = []  # データパスのキーが整数の場合に整数値（int）に型変換したものを含む、処理済みのキーを格納するリストを初期化
        Target = StructuredData["Data"]  # 更新対象の参照を設定
        Parent_Target = None  # 値の格納先がタプルの場合に使用する、タプルの親要素の参照を保持する変数を初期化
        Parent_Key = None  # 値の格納先がタプルの場合に使用する、タプルの親要素に対応するデータパスのキーを保持する変数を初期化

        for Key_i, KeyForStructure in enumerate(KeysForStructure):  # 分割したデータパスを一つずつ処理するためのイテレーション
            try:  # エラーを検出するブロック
                KeyForStructure = int(KeyForStructure)  # キーが整数の場合はインデックス番号であるという前提の下、整数値（int）への変換を試行
            except ValueError:  # ValueError が発生した場合（変換試行失敗）
                pass  # 整数値（int）に変換できない場合、そのまま文字列（str）のキーとして扱う

            # インデックス番号がリストの範囲外であれば、対応するテンプレート構造体を追加
            AppendIndexRangeOfTemplate(DatasetName, Key_i, KeyForStructure, Target, StructuredData)

            Processed_Keys.append(KeyForStructure)  # 整数値（int）への変換試行済みのキーを Processed_Keys リストに追加

            if Key_i == len(KeysForStructure) - 1:  # データパスの最後のキーに到達した場合
                if isinstance(Target, tuple):  # 値の格納位置がタプルで、タプルの要素を変更する必要がある場合
                    NewElements = list(Target)  # タプルはイミュータブルなデータ型のため、リストに変換して操作可能、ミュータブルにする
                    while len(NewElements) <= KeyForStructure:  # 現在処理しているキーが指示する範囲長までリストを拡張するためのループ
                        NewElements.append(None)  # 必要な範囲長までリストを None で拡張
                    NewElements[KeyForStructure] = Tupled_orListed_values  # 現在処理しているキーが指示する位置に値を格納
                    NewTuple = tuple(NewElements)  # リストをタプルに変換して元のデータ型に戻す

                    if Key_i > 0:  # 値を格納したタプルに親要素が存在する場合、その要素を特定
                        Parent_Target = StructuredData["Data"]  # 親要素の初期設定
                        # 現在処理しているキーの一つ前未満に相当するセグメントまで処理済みのキーを取り出し、対応する親要素を特定
                        # 現在処理しているキー = 値の格納位置、一つ前 = タプルの位置、一つ前未満 = タプルの親要素の位置
                        """ [:Key_i - 1] は、Key_i - 1 未満をイテレーションの範囲に指定するリストのスライス指示です。 """
                        for Parent_Key in Processed_Keys[:Key_i - 1]:  # 親要素の特定なので現在のキーインデックス -1 まで取り出す
                            Parent_Target = Parent_Target[Parent_Key]  # 取り出したキーセグメントを使用して親要素の参照を保持する変数を更新
                        Parent_Key = Processed_Keys[Key_i - 1]  # スライスで除外した Key_i - 1 を指定して親要素内のタプルの位置を示すキーを取得

                    if Parent_Target is not None and Parent_Key is not None:  # 各変数が初期値でない = 親要素が存在する場合、その要素を更新
                        Parent_Target[Parent_Key] = NewTuple  # 特定した親要素とタプルの位置を指示するキーを使用し、更新した新しいタプルで上書き
                    else:  # 親要素が存在しない場合、StructuredData の対応する構造体自体を更新
                        StructuredData["Data"] = NewTuple  # 親要素が存在しない = 最上位階層
                else:  # 値の格納位置がタプルでない場合、直接値を格納
                    Target[KeyForStructure] = Tupled_orListed_values  # 最終的に行き着いた Target の、現在処理しているキーに対応する位置に値を格納
            else:  # データパスの中間に位置する場合、データ構造が現在処理しているキーと整合するかチェック
                if isinstance(Target, list):  # リストの場合、インデックス範囲内かチェック
                    if len(Target) <= KeyForStructure:  # インデックス範囲外の場合、IndexError を発生させる
                        raise IndexError(("テンプレートデータにインデックスが存在しません。内部エラーのため、開発者に連絡してください。"
                            "データセット名：{0}、キー：{1}").format(
                                str(DatasetName), str(".".join([str(Key) for Key in Processed_Keys]))))
                # 辞書の場合、キーが存在するか、またキーに対応する値がリストまたは辞書かチェック（中間点のため、どれかになる）
                elif isinstance(Target, dict):
                    if KeyForStructure not in Target:  # 辞書にキーが存在しない場合、KeyError を発生させる
                        raise KeyError(("テンプレートデータにキーが存在しません。内部エラーのため、開発者に連絡してください。"
                            "データセット名：{0}、キー：{1}").format(
                                str(DatasetName), str(".".join([str(Key) for Key in Processed_Keys]))))
                    # 辞書のキーに対応する値が予期しない型の場合、TypeError を発生させる
                    elif not isinstance(Target[KeyForStructure], (list, dict)):
                        raise TypeError(("テンプレートデータが予期しない型です。内部エラーのため、開発者に連絡してください。"
                            "データセット名：{0}、キー：{1}").format(
                                str(DatasetName), str(".".join([str(Key) for Key in Processed_Keys]))))

                Target = Target[KeyForStructure]  # 次のキーの処理、イテレーションのために Target の参照、StructuredData["Data"] 内の現在地を更新
            """
この関数では行う処理の特性上、リストの範囲長を取得するメソッド len() を多用しており、また難解なリストのスライス指定も行っています。このため、この関数の動作を理解
するには、メソッド len() の特性と Python におけるリストのスライス指定の仕様を正しく理解する必要があります。リストのスライス指定の仕様については、このスクリプト
ファイルの冒頭に用意している Python の基本的な仕様を解説する docstring を参照すると、理解を深めることができます。ここでは、メソッド len() の特性について触れ、
どのように注意しなければならないかを解説します。メソッド len() には様々なデータ型を渡すことができますが、ここではこのアプリケーションにおいて特に理解して
おかなければならないデータ型の場合について解説します。メソッド len() は、引数として渡すデータが持つ要素数を返します。要素とは、リストであればリストが含む内容の
一単位を指し、辞書であれば辞書のキーの数を指します。タプルの場合はリストと同様です。文字列型（str）を渡した場合はその文字数を返します。重要なポイントは、メソッド
len() が返す要素数は 1 から数え始めた数を表すという点です。これは直感的で分かりやすいですが、この数をリストのインデックスなどと比較する場合には注意を要します。
なぜなら、Python ではインデックスの算出にゼロベースインデックスという方法を採用しているためです。これは言葉の通り、インデックスを 0 から数え始めるというものです。
つまり、例えば現在処理しているキーがリストのインデックス範囲内かどうかを確認するとします。もし範囲外を指定してしまうと、リストにはそのインデックス（要素）が存在
しないため、IndexError が発生してしまい、アプリケーションがクラッシュする原因となってしまいます。このため、こうした確認処理を行うことはエラーを未然に防ぐ効果的な
アプローチとなります。こうした確認処理を実際に行う場合、メソッド len() が返す要素数は 1 から数え始めるのに対し、インデックスは 0 から始まるため、単純に
「要素数 2 == インデックスの総数 2」のように比較した場合、両者が実際に表している数の間には 1 のズレが生じてしまいます。従ってこの例だと、要素数は 2 で分かり
やすいですが、インデックスは 0 から始まるため、そのインデックスを持つデータの実際の要素数は 3 となります。つまり、この式は False と評価されます。実践的な例では、
現在処理しているキーがリストのインデックス範囲内で True と評価したい場合､「if Key <= Index:」とし、範囲外を検出したい場合はこの条件式に not 演算子を付けるか、
「if Key > Index:」とする方法もあります。重要なのは、比較式で要素数とインデックスの「総数」が等価な場合を適切に取り扱うことです。要素数がインデックスの総数と
等価であるということは、要素数はインデックスよりも 1 少ない数を表しますので、インデックス範囲内となります。これを正しく理解し、リストのスライス指定の仕様も
踏まえることが、この関数を理解する重要な足がかりとなります。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
            """

        return StructuredData  # 元の StructuredData に値を格納した StructuredData を返す

    # データ処理の進捗状況を示すプログレスバーを文字列（str）で表現してシステムログとして報告する関数
    def ReportProgress(self, Current, Total):
        """ この部分を「関数の docstring」と言います。
        データ処理の進捗状況を示すプログレスバーを文字列（str）で表現してシステムログとして報告する関数。

        この関数は、データ処理量の総量が数値として事前に把握できる状況で、引数 Total に対する引数 Current の割合の情報を、システムログに記録するために最適化
        します。具体的には、パーセンテージ表記及び文字列でのプログレスバー表記を含むシステムログ用の文字列を作成し、LogManagerClass の専用関数
        RecordProgress() に渡します（以下進捗率報告）。進捗率報告は 0% から開始し、以降 5% の倍数毎に行います。進捗率報告の形式は、進捗率が 100% 未満の
        場合は「n%：>_（"n" は進捗のパーセンテージ、">" の数は進捗率 5% 毎の個数、"_" の数は未完了率 5% 毎の個数）」、100% に達した場合は
        「100%：>>>>>>>>>>>>>>>>>>>>」となります。また進捗率が 100% に達した際､「同じ進捗率での重複ログの出力を避けるために、進捗率の最終報告値を確認する
        ための属性」をリセットします。この属性はこの関数で動的に作成し、利用し、値を管理します。この関数の責務は、バックグラウンドスレッドで動作するこのクラスの
        データ処理タスクを、システムログという形で可視化し、ユーザーエクスペリエンスの向上を図ることです。

        Args:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            Current (int): データの総量における、現在処理中のデータの番号。
            Total (int): データの総量。

        Returns:
            なし。
        """
        # 同じ進捗率での重複ログの出力を避けるために、進捗率の最終報告値を確認するための属性名を設定
        LastReportedProgress_attr = "LastReportedProgress"
        """ "attr" は attribute（属性）の略を指し、プログラミングの文脈において一般的に使われます。 """
        LastReportedProgress = getattr(self, LastReportedProgress_attr, None)  # 進捗率の最終報告値を取得（初回は None となる）

        ProgressPercentage = int((float(Current) / float(Total)) * 100) if Total > 0 else 100  # 引数から進捗率を計算し、整数に丸める

        # 進捗率が 0%（初回のみ）または 1% 以上かつ 5% の倍数の場合、システムログ用の文字列（str）を作成
        if (ProgressPercentage == 0 and LastReportedProgress is None) or (ProgressPercentage > 0 and ProgressPercentage % 5 == 0):
            FirstReport = True if LastReportedProgress is None else False  # 初回の進捗率報告の場合、それを示すフラグを有効化
            LastReportedProgress = 0 if LastReportedProgress is None else LastReportedProgress  # 初回の進捗率報告の場合、0 を代入
            # 同じ進捗率での重複ログの出力を避けるために、進捗率の最終報告値を確認
            if LastReportedProgress == 0 or ProgressPercentage > LastReportedProgress:  # 最終報告値が 0% または現在の値が最終報告値以上の場合
                # プログレスバーを表現する文字列（str）を作成（進捗率を 5% 毎に一つの ">" で表現し、未完了率を 5% 毎に一つの "_" で表現）
                # 例：進捗率が 20% の場合、">>>>" に続けて未完了率 "________________" を追加して ">>>>________________" と表現
                # 進捗率 5% 毎に一つの ">" を表記
                CompletedProgress = ">" * (ProgressPercentage // 5)
                # 未完了率 5% 毎に一つの "_" を表記（20 = ">" の総数 - 現在の進捗率）
                RemainingProgress = "_" * (20 - (ProgressPercentage // 5))
                ProgressBar = CompletedProgress + RemainingProgress  # 進捗率表記と未完了率表記を結合
                # 現在の進捗率に応じた最終的なシステムログ用の文字列を作成
                ProgressLog = "{0}%：{1}".format(str(ProgressPercentage), str(ProgressBar))

                # 作成した文字列（str）を LogManagerClass の進捗率報告の記録専用関数 RecordProgress() に渡す
                self.LogManager.RecordProgress(FirstReport, ProgressLog, ProgressPercentage, self.EngineNum, self.ThreadID)

                if ProgressPercentage < 100:  # 進捗率が 100% 未満の場合、進捗率の最終報告値を更新
                    LastReportedProgress = ProgressPercentage  # 報告した進捗率で値を上書き
                    setattr(self, LastReportedProgress_attr, LastReportedProgress)  # 更新した値をクラス（self）属性として保存
                else:  # 進捗率が 100% に達した場合、進捗率の最終報告値を None でリセット
                    setattr(self, LastReportedProgress_attr, None)  # None をクラス（self）属性として保存
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 各種接続先の各種 API エンドポイントからの JSON 形式のレスポンスデータを正規化する関数
    @pyqtSlot(str, str, str, bool)  # シグナルに対するスロットであることを示すデコレータ
    def ExtractAndFormatData(self, EndpointName, DataPaths, Data, PathTest = False):
        """ この部分を「関数の docstring」と言います。
        各種接続先の各種 API エンドポイントからの JSON 形式のレスポンスデータを正規化する関数。

        この関数は、行う処理が多岐に渡り非常に複雑なため、理解促進のために本来なら Python のクロージャ機能によって渡す必要のない補助関数への引数渡しを明示的に
        行っています。関数は、API のエンドポイントから返された JSON 形式のレスポンスデータを、アプリケーションが取り扱うデータ構造に適合、正規化するために設計
        された二段階の処理フローを実行します。第一段階である補助関数 FirstProcess_SeparateDataPaths() は、API のエンドポイント名に基づいて取得される
        データパスを示す文字列（str）、引数 DataPaths で個々の項目名毎に定義されたデータパスを第二段階で使用する形式に分離及び整理します。分離処理では、
        各項目名、それに対応する JSON 形式のレスポンスデータ内のデータパス、及び期待値を取得して整理します。このプロセスでは、"null" というデータパスを持つ項目
        を特定し、その項目を後続の処理から除外します。これにより、特定の状況下で無視するようにユーザーによって定義されたデータ項目を事前に把握し、処理の効率化と
        精度の向上を図ります。第二段階である補助関数 SecondProcess_DataRetrievalAndFormat() は、第一段階で整理したデータパスを基に実際に JSON 形式の
        レスポンスデータから必要なデータを抽出し、期待値に応じた最適化を施した上で、アプリケーションが取り扱うデータ構造に構造化し直します。この第二段階における
        処理には、データパスの解析、リストタグの処理、期待値との照合、必要に応じて最適化したデータの格納が含まれます。これらの処理は全て適切なエラーハンドリング
        によって監視し、不適切な問題が発生した場合にはユーザーにシステムログを通じてフィードバックします。これらの処理フローを通じて、それぞれ異なるデータ構造を
        持つレスポンスデータを効率的に統一し、アプリケーションが取り扱うデータ構造に組み込むことを実現し、正規化を完了します。
        処理の各過程に対応するログが LogManagerClass によって BackLog 属性に記録されます。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            EndpointName (str): レスポンスデータ取得元のエンドポイント名。
            DataPaths (str): JSON 形式のレスポンスデータからデータを取り出すために事前に定義されたデータパス。
            Data (JSON): API のエンドポイントから返された JSON 形式のレスポンスデータ。
            PathTest (bool, optional): データパスをテストするための呼び出しを示すフラグ。デフォルトは False。

        Returns:
            dict: JSON 形式のレスポンスデータから取り出したデータを正規化した辞書。正規化したデータは辞書内の "Data" キーに配置。
        """
        # 補助関数：データパス内で定義されたリストタグを処理
        def ProcessListTags(CallNum, EndpointName = None, ItemName = None, DataPath = None, bool_ofIndexedListTags = None,
            DataIndex = None, Data_ofListTags = None, ProcessedValue = None):
            """ この部分を「関数の docstring」と言います。
            データパス内で定義されたリストタグを処理する関数。

            この関数は、引数 CallNum が 1 の場合と 2 の場合とで異なる責務を担っていますが、どちらもリストタグを適切に処理するという点では共通しています。
            リストタグは、アプリケーションがリストとして取得しなければならない値を API が返さない場合に使用します。この関数は、このリストタグの取り扱いを適切に
            行う責務を持ちます。[list] タグは、アプリケーションがリストとして取り扱っている項目名を関数 self.ExtractAndFormatData() の引数 DataPaths
            内でマークアップし、リスト化するために用意されており、[listup] タグは、本来値として取得しなければならないものがデータパスとして存在する場合に、
            値として抽出したいそのデータパスのキーを指定するために用意されています。この関数はこれらのタグを処理することで、API がアプリケーションが取り扱う
            データ構造と整合しないデータを返す場合の対処を行います。

            CallNum が 1 の場合、この関数は引数 ItemName と引数 DataPath に含まれるタグの正当性を検証し、適切にデータを整形して後続の処理に渡すための
            前処理を行います。具体的には、[list] と [listup] タグが正しく使用されているかをチェックします。タグが適切に使用されていて、DataPath に
            [listup] タグが存在する場合、[listup] タグを基に DataPath から ListUpKey を取得します。これは [listup] タグの直後から最初のドットまでの
            文字列を指します。ListUpKey は後続の処理でそのまま取得値として扱われ、DataPath が指示する場所からの値の取得処理は行われません。DataPath に
            [listup] タグが存在する場合の次の処理として、DataPath から [listup] タグを除去し、DataPath を後続の処理で利用できる形式に変換します。また、
            DataPath に [index] タグが含まれているかどうかもチェックします。[listup] タグを除去した DataPath は、さらに [index] タグを含む場合に後続の
            処理で使用されます。含まれていなければ返り値は False、False、ListUpKey、DataPath となり、含まれていれば False、True、ListUpKey、DataPath
            となります。これらの返り値は、後続の処理でのデータの扱い方を判断するための条件分岐に直接作用します。最初の False は [listup] タグが DataPath に
            含まれていたことを示し、二つ目の True または False は DataPath における [index] タグの有無に基づきます。また、全てのタグが正常であり、かつ
            [listup] タグが DataPath に含まれない場合は、True, False, None, DataPath を返します。この返り値は、データが正常であり、特に [listup] タグ
            に関する処理が不要であることを示しており、インデクシングは外部で別途チェックするべきであることを意味しています。この関数は不適切なタグの使用を厳しく
            チェックし、ItemName 内に [listup] タグが含まれている場合や、DataPath 内に [list] タグが含まれている場合、または DataPath 内に複数の
            [listup] タグが存在する場合には、ValueError を発生させ、エラーメッセージによりタグの不適切な使用を報告します。これにより、結果として得られる
            データの整合性を保ち、システム全体の安定性と信頼性を向上します。このように、この関数はデータ処理の正確性と効率性を確保するために厳密な処理を行います。
            処理の各過程に対応するログが LogManagerClass によって BackLog 属性に記録されます。

            CallNum が 2 の場合、この関数は引数 ItemName を使用して [list] または [listup] タグによるリスト項目の処理を行います。処理はまず、ItemName
            に存在する [list] タグを除去し、項目名をクリーンアップするところから開始します。クリーンアップ後、データパス内の [index] タグの有無を示す引数
            bool_ofIndexedListTags に基づき処理を分岐します。この関数を CallNum = 2 で呼び出す際には、引数 DataPath として [index] タグを処理して
            いない状態のデータパスを指定し、これの [index] タグの有無に基づき処理を行うようにすることも可能ですが、この引数は CallNum = 1 の場合に使用する
            ものとして定義されているものであるため、定義と呼び出し時の指定方法の混乱を避けるため、CallNum = 2 の場合は明示的に bool_ofIndexedListTags を
            使用します。データパスに [index] タグが存在しない場合、引数 Data_ofListTags の "FlatData" キーに対応する辞書に ItemName をキーとする新しい
            空のリストを作成し、このリストにデータパスから取得した値を追加します。[index] タグが存在する場合、より複雑な処理が必要になります。具体的には、
            Data_ofListTags の "IndexedData" キーに対応するリストにアクセスし、引数 DataIndex が指定するインデックス位置にデータパスから取得した値を
            追加します。このとき、この関数は基本的に新しい要素を追加するために呼び出されるため、少なからずリストのインデックスの拡張が必要になります。拡張する際
            には、新しいインデックス位置には None を挿入し続けます。ただし、この拡張ループは基本的に一回で終了することを想定しています。これは、この関数が
            リストに追加する要素は基本的に前の要素に続くものであることと、当該リストに対する変更はこの関数以外では行われないためです。拡張が DataIndex の位置
            に到達したら、そこに新たに辞書を作成し、その辞書内に ItemName をキーとする新しい空のリストを配置します。その後、この新しく作成したリストに対して、
            データパスから取得した値を追加します。この方法により、データの取得元の各インデックス位置に対応したデータの保存と管理を行い、[list] または
            [listup] タグによるリスト項目のデータを効率的かつ正確に管理することを実現しています。この処理の結果は、Data_ofListTags の参照に対して直接作用
            するため、この関数の呼び出し元には返り値は返しません。
            処理の各過程に対応するログが LogManagerClass によって BackLog 属性または ProcessLog 属性に記録されます。

            Parameters:
                CallNum (int): 関数に求められている処理を識別する整数値。1 または 2。
                EndpointName (str, optional): レスポンスデータ取得元のエンドポイント名。CallNum を 1 で呼び出す際に指定。
                ItemName (str, optional): 関数 self.ExtractAndFormatData() の引数 DataPaths における、処理中の項目名。
                DataPath (str, optional): 処理中の項目名に対するデータパス。CallNum を 1 で呼び出す際に指定。
                bool_ofIndexedListTags (bool, optional):
                    [list] タグを含む引数 ItemName（リスト項目）のデータパスがインデックス処理されたものかどうかを示すフラグ。
                    CallNum を 2 で呼び出す際に指定。
                DataIndex (int, optional):
                    関数 self.ExtractAndFormatData() の引数 Data の一単位のデータに対するインデックス番号。CallNum を 2 で呼び出す際に指定。
                Data_ofListTags (dict, optional): 処理したリスト項目を格納する辞書の参照。CallNum を 2 で呼び出す際に指定。
                ProcessedValue (tuple of str, optional):
                    格納する処理済みの取得値。タプル形式。[listup] タグでマークアップされていたもの。CallNum を 2 で呼び出す際に指定。

            Returns:
                bool, bool, str, str if CallNum is 1:
                    CallNum が 1 の場合、NotListUpAndCorrect の bool 値と Indexing の bool 値、
                    ListUpKey（ない場合は None）、ProcessedDataPath。

            Raises:
                ValueError:（CallNum が 1 の場合に発生しうる）
                    ● パターン 1: ItemName（項目名）に [listup] タグが設定されている場合に発生。
                    ● パターン 2: DataPath（データパス）に [list] タグが設定されている場合に発生。
                    ● パターン 3: DataPath（データパス）に [listup] タグが複数設定されている場合に発生。
            """
            # CallNum が 1 の場合、[list] 及び [listup] タグのチェックと [listup] タグの状況に応じた値の返還
            if CallNum == self.App.主 and DataPath:
                # タグが存在し、値が全て正常なパターンの場合
                if "[listup]" not in ItemName and "[list]" not in DataPath and "[listup]" in DataPath:
                    # [listup] タグの直後から最初のドットまでの文字列を取得値として取り出し、両端の空白文字を除去
                    ListUpKey = DataPath.split("[listup]", 1)[1].split(".", 1)[0].strip()
                    DataPath = DataPath.replace("[listup]", "", 1)  # DataPath から [listup] タグを一つ除去
                    if "[listup]" in DataPath:  # DataPath にまだ [listup] タグが存在する場合、ValueError を発生させる
                        raise ValueError("データパスに [listup] タグを複数使用することはできません。エンドポイント名：{0}、項目名：{1}".format(
                            str(EndpointName), str(ItemName)))
                    self.LogManager.RecordBackLOG("データ処理：[listup] タグを処理", self.ThreadID)

                    if "[index]" not in DataPath:  # DataPath が [index] タグを含まない場合の返り値
                        return False, False, ListUpKey, DataPath  # NotListUpAndCorrect、Indexing、ListUpKey、ProcessedDataPath の値
                    else:  # DataPath が [index] タグを含む場合の返り値
                        return False, True, ListUpKey, DataPath  # NotListUpAndCorrect、Indexing、ListUpKey、ProcessedDataPath の値
                elif "[listup]" in ItemName:  # タグが存在するが、ItemName に [listup] タグが存在する場合、ValueError を発生させる
                    raise ValueError(("項目名に [listup] タグを使用することはできません。エンドポイント名：{0}、項目名：{1}").format(
                        str(EndpointName), str(ItemName)))
                elif "[list]" in DataPath:  # タグが存在するが、DataPath に [list] タグが存在する場合、ValueError を発生させる
                    raise ValueError(("データパスに [list] タグを使用することはできません。エンドポイント名：{0}、項目名：{1}").format(
                        str(EndpointName), str(ItemName)))

                # タグが存在せず、値が全て正常なパターンの場合の返り値（Indexing のチェックは改めて外部で行う）
                return True, False, None, DataPath  # NotListUpAndCorrect、Indexing、ListUpKey、ProcessedDataPath の値
            elif CallNum == self.App.副 and ItemName:  # CallNum が 2 の場合、リスト項目を処理
                # ItemName でリストが作成されていない場合は作成
                ItemName = ItemName.replace("[list]", "").strip()  # ItemName から [list] タグを除去し、両端の空白文字を除去
                """
この箇所での ItemName の変更が他の箇所に伝播すると処理の不整合が起きますが、Python において文字列はイミュータブル（不変）なため、この関数から ItemName を
返さない限り、他の箇所での処理の不整合は起きません。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """
                # 項目名のデータパスが [index] タグを含まず、Data_ofListTags 辞書に ItemName キーが存在しない場合
                if not bool_ofIndexedListTags and ItemName not in Data_ofListTags["FlatData"]:
                    Data_ofListTags["FlatData"][ItemName] = []  # Data_ofListTags 辞書に ItemName をキーとしてリストを作成
                    self.LogManager.RecordBackLOG("データ処理：リスト項目（FlatData）初期化完了", self.ThreadID)
                # 項目名のデータパスが [index] タグを含み、DataIndex が Data_ofListTags["IndexedData"] のインデックス範囲外の場合
                elif bool_ofIndexedListTags and len(Data_ofListTags["IndexedData"]) <= DataIndex:
                    # DataIndex が指すインデックス番号までリストを None で拡張するループ
                    while len(Data_ofListTags["IndexedData"]) <= DataIndex:
                        Data_ofListTags["IndexedData"].append(None)  # Data_ofListTags["IndexedData"] リストに None を追加

                    # 拡張したリストの DataIndex に ItemName をキーとしてリストを作成
                    Data_ofListTags["IndexedData"][DataIndex] = {ItemName: [],}
                    """ 以上は元々インデックス範囲外だった場所なため、ItemName が存在しないことを改めて確認する必要はありません。 """
                    self.LogManager.RecordLOG("データ処理：リスト項目（IndexedData）初期化完了", self.ThreadID, backlog = True)

                if not bool_ofIndexedListTags:  # データパスが [index] タグを含まない場合の取得値の格納処理
                    Data_ofListTags["FlatData"][ItemName].append(ProcessedValue)
                    self.LogManager.RecordBackLOG("データ処理：リスト項目の取得値、リストアップ完了", self.ThreadID)
                elif bool_ofIndexedListTags:  # データパスが [index] タグを含む場合の取得値の格納処理
                    Data_ofListTags["IndexedData"][DataIndex][ItemName].append(ProcessedValue)
                    self.LogManager.RecordLOG("データ処理：リスト項目の取得値、リストアップ完了", self.ThreadID, backlog = True)
                """
Data_ofListTags 辞書はミュータブル（可変）オブジェクトとして「参照渡し」で受け取っているので（値渡しではない）、この箇所での更新はこの関数の呼び出し元に直接作用
します。従って、更新した Data_ofListTags 辞書を返り値として返す必要はありません。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """

        # 補助関数：アプリケーションで対応するネストの深さに応じたインデックスの解析のためのイテレーション
        def IterationAnalyzeIndexWithAllowedDepth(EndpointName, ItemName, Data, ProcessedDataPath, MaxNestLevel, FirstLevelIsIndex,
            IndexPositions_ofDataPath, CallNum):
            """ この部分を「関数の docstring」と言います。
            アプリケーションで対応するネストの深さに応じたインデックスの解析のためのイテレーションを行う関数。

            この関数は、アプリケーションが許容するリストのネストの深さとインデックス指定指示を含むデータパスが整合しているかを確認し、整合している場合、
            「データパスの要インデックス指定セグメントの位置」と「対応するインデックス範囲」のタプルの保存を行うイテレーションを実行します。このタプルは
            IndexPositions_ofDataPath 辞書に、リストのネストレベル、0 から始まる整数値（int）をキーとして保存します。インデックス指定指示とは、データパス
            でのリストのインデックスを指定するセグメントに設定される [index] タグのことを指します。この関数の責務は、データパスにインデックス指定指示が含まれる
            場合に、アプリケーションの仕様に対するデータパスの整合性を確認すること、及びそのデータパスに対応するレスポンスデータの存在と整合性を確認すること、
            及びインデックス範囲を取得するためのイテレーションを管理することです。このプロセスによって、レスポンスデータの特定のインデックスや範囲からデータの
            取得を行う際に、各データの整合性を保証します。この関数は引数 CallNum が 1 の場合、通常の処理を行わず、データパスが [index] タグを含む場合の処理
            をスキップするフラグを返します。通常の処理を行う場合の CallNum は 2 です。
            処理の各過程に対応するログが LogManagerClass によって BackLog 属性に記録されます。

            このアプリケーションで、API のレスポンスデータに対してリストのネストレベルに上限を設けている点について解説します。このアプリケーションでは、
            レスポンスデータを取得後にまずデータの正規化を行います。これは、このアプリケーションが多様な暗号資産取引所の API に対応するために必要な処理で、
            それぞれ異なるデータ構造を持つ API のレスポンスデータを一つのデータ構造に統一し、正規化することで、このアプリケーションの汎用性を高めることが目的
            です。このとき、レスポンスデータから必要な各種データを一度取り出すために、必要な全ての各種データに対応するデータパスを用意する必要があります。
            レスポンスデータのリストのネストレベルに上限を設けているのは、このデータパス作成処理のオーバーヘッドリスクを管理するためです。このアプリケーションが
            サポート対象としているのは Apple Silicon 搭載 Mac、またはこれと同等の処理能力を有するデバイスですが、ここでは平均的なラップトップを基準に解説
            します。これは、暗号資産取引所が API を設計する際には、平均的な処理能力を持つコンピュータが対象とされていると考えられるためです。平均的な
            ラップトップの処理能力を基準に考えた場合、ネストされたリストの構造が深いほど、データアクセスの処理時間に大きな影響を与えます。具体的に、最上位の
            リストが 30 個の要素を持つ、ネストレベル 0 の場合のデータへの直接アクセスの総処理時間は、一要素あたり約 0.1 ミリ秒未満 ✕30 個 = 約 3 ミリ秒未満
            と非常に短いです。そして次のレベルのリストがそれぞれ 10 個程度の要素を含む場合、データパス作成処理にかかる時間は一要素あたり約 0.2 ミリ秒程度
            ✕30 個 ✕10 個 = 約 60 ミリ秒程度に増加します。さらに同様の要素数を持つ次のネストレベル 2 の場合、同処理には一要素あたり約 0.5 ミリ秒程度
            ✕30 個 ✕10 個 ✕10 個 = 約 1,500 ミリ秒程度 = 約 1.5 秒程度かかります。ネストレベルが 3 になると、各パスの探索が複雑になり、例えそのレベルの
            要素数がわずか 3 個であったとしても、総処理時間は一要素あたり約 1 ミリ秒程度 ✕30 個 ✕10 個 ✕10 個 ✕3 個 = 約 9,000 ミリ秒程度 = 約 9 秒程度
            と指数関数的に増加します。さらに、非現実的なネストレベル 4 では、例え最終深度の要素数が同じく 3 個であっても、処理時間は約数十秒程度に跳ね上がり
            ます。これらの推定値はあくまで平均的なラップトップという曖昧な前提の下でのもの、かつインタープリタ型であるという点で他の開発言語よりも実行速度が遅い
            傾向にある Python におけるものですが、このアプリケーションでは Python で複雑なリストを取り扱う際に推奨される、関数の再帰呼び出し処理を伴わない
            イテレーションでの高速処理を採用しています。それでもこのような数値が想定され、特定の開発言語を排除すべきでない、暗号資産取引所のような汎用性と即応性
            を求められる API のレスポンスデータ設計において、このような深いネスト構造を想定するのは現実的ではありません。データパスの作成処理はあくまで全体の
            処理の前処理であるため、ここで数秒もの時間を要していては全体のレスポンス性に悪影響を及ぼします。このように、深いネストレベルにおいて必要になる
            データパスを作成するプロセスは計算効率が非常に悪く、暗号資産取引所のような API でこのようなデータ構造が採用されることは想定外であり、
            アプリケーション側はこれを前提としなくてよいと言えます。

            Parameters:
                EndpointName (str): レスポンスデータ取得元のエンドポイント名。
                ItemName (str): 関数 self.ExtractAndFormatData() の引数 DataPaths における、処理中の項目名。
                Data (list or dict): 関数 self.ExtractAndFormatData() の引数 Data を Python オブジェクトに変換したレスポンスデータ。
                ProcessedDataPath (str): [listup] タグを除去した処理済みのデータパス。
                MaxNestLevel (int): アプリケーションが許容するリストのネストの深さ。
                FirstLevelIsIndex (bool): 引数 Data 自体がインデックス参照可能なデータ型の場合、そのインデックス範囲の取得を一回に制限するフラグ。
                IndexPositions_ofDataPath (dict): データパスにおけるインデックス指定指示のセグメント位置とインデックス範囲を記録するための辞書の参照。
                CallNum (int): 関数に求められている処理を識別する整数値。1 または 2。

            Returns:
                bool, bool, list:
                    関数呼び出し元で扱われる Skip_ListDataPath、FirstLevelIsIndex の値と PathList_ofIndex。
                    PathList_ofIndex を作成しない場合､「bool, bool, None」。

            Raises:
                ValueError:
                    ● パターン 1: 取得を試みたデータのネストレベルがアプリケーションの許容範囲を超えている場合に発生。
                    ● パターン 2: 関数呼び出し時に期待されるデータが取得されていない場合に発生。
            """
            # 補助関数：インデックス指定指示を含むデータパスに対するデータの整合性を確認及び必要に応じて
            # IndexPositions_ofDataPath の保存を行うイテレーション
            def CheckAndGetIndexRangeWithDataPath(EndpointName, ItemName, Data, Data_ForCheckLen, IndexPositions_ofDataPath, NestLevel,
                PathList_ofIndex, Checking_SegmentIndex, Checked_Paths):
                """ この部分を「関数の docstring」と言います。
                インデックス指定指示を含むデータパスに対するデータの整合性を確認及び必要に応じて
                IndexPositions_ofDataPath の保存を行うイテレーションを管理する関数。

                この関数は、アプリケーションで対応するネストレベルに応じたイテレーション内で呼び出されることを前提としています。データパスにインデックス指定
                指示 [index] タグが含まれる場合、そのデータパスに対応するレスポンスデータの存在と整合性を確認し､「データパスのインデックス指定指示セグメント
                の位置」と「対応するインデックス範囲」のタプルの保存を行います。タプルは引数 IndexPositions_ofDataPath にリストのネストレベル、0 から
                始まる整数値（int）をキーとして保存します。このプロセスはデータパスのリストのネストレベルに応じたイテレーションによってこの関数が呼び出される
                ことによって行い、各データパス毎に AppClass（self.App）属性の MaxNestLevel 属性で設定された、アプリケーションが許容するリストのネストの
                深さ分だけ呼び出されるため、スタックオーバーフローが発生するリスクはありません。この関数は、レスポンスデータ構造内で特定のインデックスや範囲から
                データの取得を行う際に、データの整合性を保証するための前提条件として機能します。
                処理の各過程に対応するログが LogManagerClass によって BackLog 属性に記録されます。

                Parameters:
                    EndpointName (str): レスポンスデータ取得元のエンドポイント名。
                    ItemName (str): 関数 self.ExtractAndFormatData() の引数 DataPaths における、処理中の項目名。
                    Data (list or dict): 関数 self.ExtractAndFormatData() の引数 Data を Python オブジェクトに変換したレスポンスデータ。
                    Data_ForCheckLen (NoneType): インデックス参照可能なレスポンスデータのインデックス範囲を取得するためのデータ保存先。
                    IndexPositions_ofDataPath (dict):
                        データパスにおけるインデックス指定指示のセグメント位置とインデックス範囲を記録するための辞書の参照。
                    NestLevel (int): 現在のネストの深さを示す整数値。最初の呼び出し時は 0。
                    PathList_ofIndex (list): split(".") 済みのデータパスのリストの参照。[index] タグはインデックス指定指示。
                    Checking_SegmentIndex (int): 引数 PathList_ofIndex を使用したイテレーション開始位置を示す整数値。
                    Checked_Paths (list): データパスのチェック済みのセグメントを格納するリスト。

                Returns:
                    int or False:
                        次のイテレーション開始位置を示す整数値（Checking_SegmentIndex）。または呼び出し元のイテレーションを終了させるための False。
                """
                # 補助関数：インデックス指定指示を含むデータパスとレスポンスデータが整合しない旨の TypeError を発生させる
                def RaiseIndexTypeError(EndpointName, ItemName):
                    """ この部分を「関数の docstring」と言います。
                    インデックス指定指示を含むデータパスとレスポンスデータが整合しない旨の TypeError を発生させる関数。

                    この関数は、レスポンスデータがデータパスのインデックス指定指示に整合しないことが確認されたコンテキストで呼び出され、その場合のエラーを発生
                    させる役割のみを担います。

                    Parameters:
                        EndpointName (str): レスポンスデータ取得元のエンドポイント名。
                        ItemName (str): 関数 self.ExtractAndFormatData() の引数 DataPaths における、処理中の項目名。

                    Returns:
                        Raises:
                            TypeError: レスポンスデータがインデックス指定指示に整合しないことを知らせる文言。
                    """
                    # この関数はエラーを発生させるために呼び出される
                    raise TypeError(("データパスとデータが整合しません。エンドポイント名：{0}、項目名：{1}").format(
                        str(EndpointName), str(ItemName)))
                    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

                # 補助関数：データパスの [index] セグメントの直前までのパスを使用して、レスポンスデータからインデックス参照可能な部分を取り出して返す
                def GetDataForGetRange(EndpointName, ItemName, Data, Checked_Paths):
                    """ この部分を「関数の docstring」と言います。
                    データパスの [index] セグメントの直前までのパスを使用して、レスポンスデータからインデックス参照可能な部分を取り出して返す関数。

                    この関数は、データパスの [index] セグメントの直前までのパスを使用して、レスポンスデータから対応する部分を取得し、そのデータがインデックス
                    参照可能なデータ型かを確認します。インデックス参照可能なデータ型の場合はそのデータを返し、この関数の呼び出し元である「データパスの検証」
                    コンテキストを続行させます。インデックス参照可能なデータ型（文字列は考慮しません）ではない、または有効なデータではない場合、この関数の呼び
                    出し元のコンテキストを終了させるために False を返します。

                    Parameters:
                        Data (list or dict): 関数 self.ExtractAndFormatData() の引数 Data を Python オブジェクトに変換したレスポンスデータ。
                        Checked_Paths (list): データパスのチェック済みのセグメントを格納するリスト。

                    Returns:
                        list or tuple or False: インデックス参照可能なデータの取得に成功した場合はそのデータ。そうでなければ False。
                    """
                    Path_ForCheck = ".".join(Checked_Paths)  # データ型チェック用のデータパスの作成
                    Data_ForCheckLen = GetDataVal(Data, Path_ForCheck)  # データ型チェック用のデータパスを使用してレスポンスデータからデータを取得

                    # 関数 GetDataVal() がデータを返し、データがリストまたはタプルの場合、そのデータを返す
                    if Data_ForCheckLen is not None and isinstance(Data_ForCheckLen, (list, tuple)):
                        return Data_ForCheckLen  # リストまたはタプルを返す
                    else:  # データパスに対応するデータが見つからない、またはインデックス参照可能なデータ型でない場合、TypeError を発生させる
                        RaiseIndexTypeError(EndpointName, ItemName)  # このコンテキストの TypeError を発生させる補助関数を呼び出す
                    """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

                # 補助関数：補助関数 CheckAndGetIndexRangeWithDataPath() のコア処理部分
                def Core_ofCheckAndGetIndexRangeWithDataPath(IndexPositions_ofDataPath, NestLevel, i, Data_ForCheckLen,
                    Checking_SegmentIndex, Checked_Paths):
                    """ この部分を「関数の docstring」と言います。
                    補助関数 CheckAndGetIndexRangeWithDataPath() のコア処理部分を担う関数。

                    この関数は、補助関数 CheckAndGetIndexRangeWithDataPath() の担うべき処理のコア部分をカプセル化したものです。

                    Parameters:
                        IndexPositions_ofDataPath (dict):
                            データパスにおけるインデックス指定指示のセグメント位置とインデックス範囲を記録するための辞書の参照。
                        NestLevel (int): 現在のネストの深さを示す整数値。最初の呼び出し時は 0。
                        i (int): イテレート回数を表す整数値。
                        Data_ForCheckLen (NoneType): インデックス参照可能なレスポンスデータのインデックス範囲を取得するためのデータ保存先。
                        Checking_SegmentIndex (int): 引数 PathList_ofIndex を使用したイテレーション開始位置を示す整数値。
                        Checked_Paths (list): データパスのチェック済みのセグメントを格納するリスト。

                    Returns:
                        int: 次のイテレーション開始位置を示す整数値（Checking_SegmentIndex）。
                    """
                    # データパスにおけるインデックス指定指示の位置 = インデックスと、対応するインデックス範囲 = メソッド range() 用をタプルとして記録
                    # インデックス範囲はそのままイテレートに使用するため調整不要
                    IndexPositions_ofDataPath[NestLevel] = (i, len(Data_ForCheckLen),)
                    Checking_SegmentIndex = i + 1  # 次のイテレーション開始位置を設定
                    Checked_Paths.append("0")  # 次のセグメントのチェックのためにレスポンスデータに対して使用するチェック用のインデックスを指定
                    self.LogManager.RecordBackLOG("データ処理：インデックス {0} 取得完了".format(str(NestLevel + 1)), self.ThreadID)
                    return Checking_SegmentIndex  # 次のイテレーション開始位置を返す
                    """
IndexPositions_ofDataPath 辞書と Checked_Paths リストはミュータブル（可変）オブジェクトとして「参照渡し」で受け取っているので（値渡しではない）、この箇所
での更新はこの関数の呼び出し元に直接作用します。従って、更新した IndexPositions_ofDataPath 辞書と Checked_Paths リストを返り値として返す必要はありません。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                    """

                """ CheckAndGetIndexRangeWithDataPath() の記述 """
                # インデックス参照可能なデータ型かの確認とデータのインデックス範囲の取得
                for i, Segment in enumerate(PathList_ofIndex[Checking_SegmentIndex:], start = Checking_SegmentIndex):
                    # データパスの最初のセグメントがインデックス指定指示の場合、レスポンスデータ全体のデータ型を検査
                    if "[index]" in Segment and not IndexPositions_ofDataPath[NestLevel] and i == 0:
                        if isinstance(Data, (list, tuple)):  # リストまたはタプルの場合（インデックス参照可能）
                            # 一つ目のインデックス指定指示を含むセグメントの位置とインデックス範囲を記録
                            return Core_ofCheckAndGetIndexRangeWithDataPath(  # 次のイテレーション開始位置を返す
                                IndexPositions_ofDataPath, NestLevel, i, Data, Checking_SegmentIndex, Checked_Paths)
                        else:  # データパスとレスポンスデータのデータ型が整合しない場合、TypeError を発生させる
                            RaiseIndexTypeError(EndpointName, ItemName)  # このコンテキストの TypeError を発生させる補助関数を呼び出す
                    # データパスの二つ目のセグメント以降にインデックス指定指示がある場合、直前までのデータパスを使用して対応するデータを取得
                    elif "[index]" in Segment and not IndexPositions_ofDataPath[NestLevel]:  # [NestLevel] に対応する位置が初期値かも確認
                        # インデックス範囲取得のためのデータを取得
                        Data_ForCheckLen = GetDataForGetRange(EndpointName, ItemName, Data, Checked_Paths)
                        # NestLevel 個目のインデックス指定指示を含むセグメントの位置とインデックス範囲を記録
                        return Core_ofCheckAndGetIndexRangeWithDataPath(  # 次のイテレーション開始位置を返す
                            IndexPositions_ofDataPath, NestLevel, i, Data_ForCheckLen, Checking_SegmentIndex, Checked_Paths)
                    # 前の条件式でセグメントが [index] タグでないと確認したが、次以降のセグメントが該当する場合
                    elif "[index]" in PathList_ofIndex[i + 1:]:
                        Checked_Paths.append(Segment)  # チェック済みのセグメントを Checked_Paths リストに追加し、次のイテレートに移行
                    else:  # 次以降のセグメントに [index] タグがない場合、イテレーションを終了
                        return False  # 関数呼び出し元のイテレーションを終了させるフラグを返す

                return False  # 全てのセグメントをチェックした場合、関数呼び出し元のイテレーションを終了させるフラグを返す
                """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

            """ IterationAnalyzeIndexWithAllowedDepth() の記述 """
            # CallNum が 1 の場合、デバッグモードとしてデータパスが [index] タグを含む場合の処理をスキップするフラグを返す
            if CallNum == self.App.デバッグ and "[index]" in ProcessedDataPath:
                return True, FirstLevelIsIndex, None  # Skip_ListDataPath、FirstLevelIsIndex、PathList_ofIndex の値
            # CallNum が 2 の場合、通常通り、データパスにインデックス指定指示があり、その個数が MaxNestLevel 以内の場合、インデックスの解析を行う
            # またはデータパスのチェック済みの最初のセグメント以外に二つ目以降のインデックス指定指示がある場合、インデックスの解析を行う
            # （後者の条件が満たされる前提処理は、前者の条件が満たされたときに行われる）
            elif CallNum == self.App.通常 and (("[index]" in ProcessedDataPath and \
            "[index]" not in ProcessedDataPath.replace("[index]", "", MaxNestLevel) and len(Data) > 0) or \
            (FirstLevelIsIndex and "[index]" in ProcessedDataPath.replace("[index]", "", 1) and len(Data) > 0)):
                # 変数を初期化
                Data_ForCheckLen = None  # インデックス参照可能なレスポンスデータのインデックス範囲を取得するためのデータ保存先
                PathList_ofIndex = list(filter(None, ProcessedDataPath.split(".")))  # データパスを解析のためにドットで分割してリストを取得
                Checking_SegmentIndex = 0  # PathList_ofIndex の次のチェック対象のセグメントのインデックスを保存する変数
                Checked_Paths = []  # PathList_ofIndex のチェック済みのセグメントを保存するリスト

                for NestLevel in range(MaxNestLevel):  # アプリケーションが許容するリストのネストの深さに応じたインデックスの解析のためのイテレーション
                    # この条件が満たされる場合、IndexPositions_ofDataPath[0] に保持している情報を再利用し、初期化しない
                    if FirstLevelIsIndex and Checking_SegmentIndex == 0:
                        Checking_SegmentIndex = 1  # データパスの最初のセグメントのチェックをスキップするため、インデックスの二番目を設定
                        Checked_Paths.append("0")  # データパスの最初のセグメントを Checked_Paths リストに追加（チェック用のインデックスを指定）
                        self.LogManager.RecordBackLOG("データ処理：インデックス {0} 取得完了".format(str(NestLevel + 1)), self.ThreadID)
                    # 解析を開始または続行する指示であるインデックスの有効数値（int）が存在する場合、リストのネスト情報の解析を実行
                    elif (Checking_SegmentIndex == 0 and not FirstLevelIsIndex) or Checking_SegmentIndex >= 1:
                        # リストのネスト情報を初期化（これが変更されることは次の NestLevel のイテレートに移行することと同義）
                        IndexPositions_ofDataPath[NestLevel] = None  # NestLevel は 0 から始まる整数値（int）

                        # インデックス指定指示を含むデータパスに対するデータの整合性を確認及び必要に応じて
                        # IndexPositions_ofDataPath の保存を行うイテレーション
                        Checking_SegmentIndex = CheckAndGetIndexRangeWithDataPath(EndpointName, ItemName, Data, Data_ForCheckLen,
                            IndexPositions_ofDataPath, NestLevel, PathList_ofIndex, Checking_SegmentIndex, Checked_Paths)

                        # データパスの最初のセグメントが [index] タグで Data と整合する場合、同じエンドポイントの他の項目で同じチェックを行わないようにする
                        """ この処置は「約定履歴取得」などのエンドポイントからの大量のデータを効率的に処理するためのものです。 """
                        if Checking_SegmentIndex == 1:
                            FirstLevelIsIndex = True  # 同じエンドポイントの他の項目で同じチェックを行わないようにするフラグを有効化
                        elif not Checking_SegmentIndex:  # False を返された場合、解析完了
                            break  # イテレーションを終了

                # 各種フラグと PathList_ofIndex を返す
                return False, FirstLevelIsIndex, PathList_ofIndex  # Skip_ListDataPath、FirstLevelIsIndex、PathList_ofIndex の値
            # データパスにインデックス指定指示があり、その個数が MaxNestLevel 以上である場合、ValueError を発生させる
            elif CallNum == self.App.通常 and "[index]" in ProcessedDataPath and len(Data) > 0:
                raise ValueError(("取得しようとしているデータのネストレベルがアプリケーションの許容範囲を超えています。"
                    "エンドポイント名：{0}、項目名：{1}").format(str(EndpointName), str(ItemName)))
            # データパスにインデックス指定指示があり、有効な Data でない場合、ValueError を発生させる
            elif CallNum == self.App.通常 and "[index]" in ProcessedDataPath and not Data:
                raise ValueError(("期待されるデータが取得されていません。取引所の稼働状態を確認してください。エンドポイント名：{0}、項目名：{1}").format(
                    str(EndpointName), str(ItemName)))
            elif "[index]" not in ProcessedDataPath:  # データパスにインデックス指定指示がない場合、適切な値を返す（デバッグモードと通常通りで共通）
                return False, FirstLevelIsIndex, None  # Skip_ListDataPath、FirstLevelIsIndex、PathList_ofIndex の値
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：データパスの全てのインデックス指定指示セグメントを実際のインデックスに置換及び全てのインデックス範囲のデータパスの作成
        def ReplaceIndexSegmentsAndGenerateDataPathsOfRange(ProcessedDataPath, PathList_ofIndex, IndexPositions_ofDataPath, CallNum):
            """ この部分を「関数の docstring」と言います。
            データパスの全てのインデックス指定指示セグメントを実際のインデックスに置換及び全てのインデックス範囲のデータパスの作成を行う関数。

            この関数は、インデックス情報を持つ引数 IndexPositions_ofDataPath（辞書）を使用して、全てのインデックス指定指示セグメントの全てのインデックス
            範囲の組み合わせを網羅するデータパスのリストを返します。引数 CallNum が 1 の場合はデバッグモードとして、作成したデータパスのリストを確認するための
            フラグを有効化して返します。CallNum が 2 の場合は通常通りの処理を行います。この関数は、データパス作成時にスタックオーバーフローが発生しない
            ロジックを採用しています。
            処理の各過程に対応するログが LogManagerClass によって BackLog 属性に記録されます。

            Parameters:
                ProcessedDataPath (str): [listup] タグを除去した処理済みのデータパス。
                PathList_ofIndex (list): split(".") 済みのデータパスのリストの参照。[index] タグはインデックス指定指示。
                IndexPositions_ofDataPath (dict): データパスにおけるインデックス指定指示のセグメント位置とインデックス範囲を記録するための辞書の参照。
                    キーは [index] セグメントの登場回数、値はタプル（セグメントの位置、データの範囲）。
                CallNum (int): 関数に求められている処理を識別する整数値。1 または 2。

            Returns:
                bool, list:
                    関数呼び出し元で扱われる Check_GeneratedIndexedDataPaths の値と
                    「全てのインデックスの組み合わせのデータパスのリスト、またはインデックス指定指示がない場合、None」。
            """
            # 補助関数：スタックを使用してデータパスのセグメントリストのインデックス指定指示部分に具体的なインデックス指定を施したデータパスリストを作成
            def GeneratePaths(IndexPositions_ofDataPath, PathList_ofIndex, AllPaths):
                """ この部分を「関数の docstring」と言います。
                スタックを使用してデータパスのセグメントリストのインデックス指定指示部分に具体的なインデックス指定を施したデータパスリストを作成する関数。

                この関数は、インデックス情報を持つ引数 IndexPositions_ofDataPath（辞書）を使用して、可能な全てのデータパスを作成し、それらを直接引数
                AllPaths（リスト）に追加します。この処理の際、この関数は再帰呼び出し処理ではなく、パフォーマンス向上のためにスタックを活用した効率的な
                データパス構築処理を採用しています。これはスタックオーバーフローと呼ばれるエラーや、再帰呼び出しの上限に達することによるエラーのリスクを排除
                します。スタックオーバーフローとは、プログラムの実行スタックがその最大容量を超えた場合に発生するエラーで、通常、非常に深い関数の再帰呼び出しや
                非常に大きなデータ構造を処理する際に見られます。この問題は、関数呼び出しに伴うリターンアドレスやローカル変数などの情報がスタックに積み重ねられる
                ために発生します。一方で、再帰呼び出しの上限エラーは、プログラミング言語の実装における再帰深度の最大値を超えた場合に発生し、多くの言語では
                RecursionError や StackOverflowError などとして表現されます。これは再帰呼び出しを行う関数が自身を何度も呼び出し続けることにより、呼び出し
                スタックが限界を超えた状態を指します。この関数では、これらのリスクを回避するためにスタックを直接活用し、再帰呼び出しではなく明示的な
                イテレーションを採用しています。スタックを直接活用することで、関数の呼び出し状態を明示的に制御し、プログラムのコールスタックに依存しない状況
                管理が可能となります。具体的には、関数は Stack というリストを使用して、処理中のデータパスと対応するネストレベルのタプルを保持し、このスタック
                から項目を取り出してはデータパスを更新し、必要に応じて新しいデータパスをスタックに追加します。このアプローチにより、データのネストレベルが深く
                なってもスタックオーバーフローの危険性を排除することができ、また、再帰呼び出しの上限によるエラーからも解放されます。さらに、このアプローチは前述
                の通りパフォーマンスの面でも優れています。スタックを直接活用したイテレーションは再帰呼び出し処理と比べてオーバーヘッドが少なく、大規模なデータ
                構造や複雑なネスト構造を効率的に扱うことができるため、アプリケーションの応答性と処理速度が向上します。また、引数 PathList_ofIndex の
                インデックス指定指示部分の更新や AllPaths へのデータパスの追加など、具体的なデータ処理も明確に制御し、デバッグやメンテナンスを容易にして
                います。このように、この関数はスタックベースのアルゴリズムを駆使してデータパスの作成を最適化し、リソースの効率的な利用とエラー発生のリスク排除を
                実現しています。

                Parameters:
                    IndexPositions_ofDataPath (dict):
                        データパスにおけるインデックス指定指示のセグメント位置とインデックス範囲を記録するための辞書の参照。
                        キーは [index] セグメントの登場回数、値はタプル（セグメントの位置、データの範囲）。
                    PathList_ofIndex (list): split(".") 済みのデータパスのリストの参照。[index] タグはインデックス指定指示。
                    AllPaths (list): 作成したデータパスを格納するリストの参照。

                Returns:
                    なし。
                """
                if not isinstance(IndexPositions_ofDataPath, dict):  # 渡された IndexPositions_ofDataPath が辞書型であるか確認
                    raise ValueError("パス更新：第一引数は辞書型である必要があります")

                Stack = [(PathList_ofIndex, 0,),]  # スタックに初期状態のパスとネストレベル 0 をプッシュ
                while Stack:  # スタックが空になるまでのループ
                    PathList_ofIndex, NestLevel = Stack.pop()  # メソッド pop() を使用してスタックからパスとネストレベルの組み合わせを取得しつつ削除
                    """
ここでは、取り出す値の数が分かっているため、取り出す値を代入する先をあらかじめその値の数だけ用意しておきます。このようにすることで、取り出す値を自動的にアンパック
することができ、値はそれぞれ元の変数内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                    """
                    # 現在のネストレベルが辞書のキーに含まれていて NestLevel キーに対する値が初期値でない場合
                    if NestLevel in IndexPositions_ofDataPath and IndexPositions_ofDataPath[NestLevel]:
                        # 現在のネストレベルに対応するエントリ（[index] セグメントの位置、データの範囲）を取得
                        Entry = IndexPositions_ofDataPath[NestLevel]
                        if not isinstance(Entry, tuple) or not len(Entry) == 2:  # 取得した Entry がタプル、かつ要素数が 2 であることを確認
                            raise ValueError(("パス更新：ネストレベル {0} のデータは「位置」「範囲」の二つの整数値を含むタプルである必要が"
                                "あります").format(str(NestLevel)))

                        IndexPosition, RangeLength = Entry  # タプルから [index] セグメントの位置とデータの範囲を取得
                        if not isinstance(IndexPosition, int) or IndexPosition < 0:  # [index] セグメントの位置が負の整数でないことを確認
                            raise ValueError("パス更新：インデックス位置は 0 以上の整数値である必要があります")
                        if not isinstance(RangeLength, int) or RangeLength < 0:  # データの範囲が負の整数でないことを確認
                            raise ValueError("パス更新：インデックス範囲は 0 以上の整数値である必要があります")

                        for i in range(RangeLength):  # データの範囲を網羅するためのイテレーション
                            NewPath = PathList_ofIndex[:]  # 現在のパスのコピーを作成
                            # コピーしたパスのインデックス指定指示セグメントを指示する IndexPosition をイテレート数で置換
                            NewPath[IndexPosition] = str(i)
                            Stack.append((NewPath, NestLevel + 1))  # 置換した新しいパスと次のネストレベルをスタックに追加
                    else:  # 現在のネストレベルが辞書のキーに含まれていて NestLevel キーに対する値が初期値でない場合という条件に合致しない場合
                        AllPaths.append(".".join(PathList_ofIndex))  # パスの作成完了により AllPaths（リスト）に追加
                """
AllPaths リストはミュータブル（可変）オブジェクトとして「参照渡し」で受け取っているので（値渡しではない）、この箇所での更新はこの関数の呼び出し元に直接作用
します。従って、更新した AllPaths リストを返り値として返す必要はありません。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                """

            """ ReplaceIndexSegmentsAndGenerateDataPathsOfRange() の記述 """
            if "[index]" in ProcessedDataPath:  # データパスにインデックス指定指示がある場合、処理を実行
                AllPaths = []  # 作成する全てのデータパスを格納するリスト

                # データパスのテンプレートパスとして PathList_ofIndex を使用し、データパス作成処理を開始
                self.LogManager.RecordBackLOG("データ処理：データパス更新開始", self.ThreadID)
                GeneratePaths(IndexPositions_ofDataPath, PathList_ofIndex, AllPaths)

                if CallNum == self.App.デバッグ:  # 作成した全てのデータパスのリストを返す（デバッグモード）
                    return True, AllPaths  # Check_GeneratedIndexedDataPaths、AllIndexedPaths の値
                elif CallNum == self.App.通常:  # 作成した全てのデータパスのリストを返す（通常モード）
                    return False, AllPaths  # Check_GeneratedIndexedDataPaths、AllIndexedPaths の値
            elif "[index]" not in ProcessedDataPath:  # データパスにインデックス指定指示がない場合、適切な値を返す
                return False, None  # Check_GeneratedIndexedDataPaths、AllIndexedPaths の値
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：期待値を必要に応じて型変換
        def ConvertExpectedValues(ExpectedValues):
            """ この部分を「関数の docstring」と言います。
            期待値を必要に応じて型変換する関数。

            この関数は、文字列型（str）として取り出される期待値をその内容に応じて適切なデータ型に変換します。この型変換は項目名に対応するデータパスが全て用意
            された時点で行われることを想定しており、この時点で型変換を行っておくことで、項目名のデータパスがインデックス指定指示を含むものである場合に開始される、
            全てのインデックス範囲からのデータの取得のためのイテレーション内での取得値と期待値の照合処理時に、都度型変換を行うオーバーヘッドを回避します。型変換
            は二重のタプル形式である期待値の全期待値を表す外側のタプル内の単一の期待値を表す内側のタプルの単一の期待値を構成する各要素が全て同一のデータ型として
            解釈可能な場合に行います。これにより、単一の期待値の各要素間で異なるデータ型になる不整合を防ぎます。この関数での型変換は整数値（int）、浮動小数点数
            （float）、bool 値、NoneType に対応しており、それぞれ文字列（str）からこれらのデータ型を意図していると解釈可能な場合に型変換を行います。

            Parameters:
                ExpectedValues (tuple of tuples): 期待値。二重のタプル形式。内側のタプル一つにつき一つの期待値を表す。

            Returns:
                tuple of tuples: 型変換した期待値のタプル（二重のタプル形式）。
            """
            ConvertedValues = []  # 型変換した全期待値を保持するリストを初期化

            for ExpectedTuple in ExpectedValues:  # 全期待値を表すタプルから単一の期待値を表すタプルを取り出すためのイテレーション
                TempConvertedSubTuple = []  # 単一の期待値を構成する要素の変換結果を一時的に保持するリストを初期化
                TypeSet = set()  # 単一の期待値を表すタプル内のデータ型を追跡するためのセットを初期化

                for ExpectedValue in ExpectedTuple:  # 単一の期待値を表すタプルから単一の期待値を構成する要素を取り出すためのイテレーション
                    LowerValue = ExpectedValue.lower()  # 内容の確認用に半角英字を小文字に変換
                    if LowerValue.isdigit():  # 整数値（int）として解釈可能な場合、整数値に型変換
                        # 型変換し、単一の期待値を構成する要素の変換結果を一時的に保持するリストに追加
                        TempConvertedSubTuple.append(int(ExpectedValue))
                        TypeSet.add(int)  # 単一の期待値を表すタプル内のデータ型を追跡するためのセットに整数値型（int）を追加
                    # 浮動小数点数（float）として解釈可能な場合、浮動小数点数に型変換
                    elif LowerValue.replace(".", "", 1).isdigit() and LowerValue.count(".") == 1:
                        # 型変換し、単一の期待値を構成する要素の変換結果を一時的に保持するリストに追加
                        TempConvertedSubTuple.append(float(ExpectedValue))
                        TypeSet.add(float)  # 単一の期待値を表すタプル内のデータ型を追跡するためのセットに浮動小数点数型（float）を追加
                    # bool 値、NoneType のいずれかの値として解釈可能な場合、対応するデータ型に型変換
                    elif LowerValue in {"true", "false", "null", "none", "nonetype"}:
                        if LowerValue == "true":  # True の場合
                            TempConvertedSubTuple.append(True)  # 型変換し、単一の期待値を構成する要素の変換結果を一時的に保持するリストに追加
                            TypeSet.add(bool)  # 単一の期待値を表すタプル内のデータ型を追跡するためのセットに bool 型を追加
                        elif LowerValue == "false":  # False の場合
                            TempConvertedSubTuple.append(False)  # 型変換し、単一の期待値を構成する要素の変換結果を一時的に保持するリストに追加
                            TypeSet.add(bool)  # 単一の期待値を表すタプル内のデータ型を追跡するためのセットに bool 型を追加
                        else:  # NoneType の場合
                            TempConvertedSubTuple.append(None)  # 型変換し、単一の期待値を構成する要素の変換結果を一時的に保持するリストに追加
                            TypeSet.add(type(None))  # 単一の期待値を表すタプル内のデータ型を追跡するためのセットに NoneType を追加
                    else:  # 数値（int or float）、bool 値、NoneType に該当しない文字列の場合、文字列型（str）を維持
                        TempConvertedSubTuple.append(ExpectedValue)  # 単一の期待値を構成する要素の変換結果を一時的に保持するリストに追加
                        TypeSet.add(str)  # 単一の期待値を表すタプル内のデータ型を追跡するためのセットに文字列型（str）を追加

                if len(TypeSet) == 1:  # 単一の期待値を表すタプル内のデータ型を追跡するためのセットに単一のデータ型が格納されている場合のみ変換結果を適用
                    # 単一の期待値を構成する要素の変換結果を一時的に保持するリストを単一の期待値を構成する要素の変換結果を保持する変数に代入
                    ConvertedSubTuple = TempConvertedSubTuple
                # 単一の期待値を表すタプル内のデータ型を追跡するためのセットに複数のデータ型が混在する場合、単一の期待値として整合しないため元の値を維持
                else:
                    # 単一の期待値を構成する元の値を持つ単一の期待値を表すタプルを一時的にリストに変換して
                    # 単一の期待値を構成する要素の変換結果を保持する変数に代入
                    ConvertedSubTuple = list(ExpectedTuple)

                # 単一の期待値を構成する要素の変換結果を保持する変数をタプルに変換して型変換した全期待値を保持するリストに追加
                ConvertedValues.append(tuple(ConvertedSubTuple))

            return tuple(ConvertedValues)  # 型変換した全期待値を保持するリストをタプルに変換して返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：取得値を必要に応じて正規化
        def ConvertExtractedValueWithExpected(EndpointName, ItemName, RawValue, ExpectedValues):
            """ この部分を「関数の docstring」と言います。
            取得値を必要に応じて正規化する関数。

            この関数は、
            ● 数字とドットのみで構成される文字列（str）を数値（int or float）に変換
            ● bool 値として解釈可能な文字列（str）を bool 値に変換
            ● NoneType として解釈可能な文字列（str）を NoneType に変換
            ● 日時データの正規化
            を行います。日時データの正規化では、取得値を「世界標準時間（UTC）の Unix タイムスタンプ、東京時間または地域時間の Unix タイムスタンプ、東京時間
            または地域時間の日時文字列」の三つの要素を含むタプルに変換します。このアプリケーションでは Unix タイムスタンプは常に世界標準時間（UTC）として取り
            扱うため、東京時間または地域時間の日時文字列を表示する必要がある場合は、東京時間または地域時間の Unix タイムスタンプに世界標準時間（UTC）の
            タイムゾーンを適用して datetime オブジェクトを作成します。Unix タイムスタンプは通常世界標準時間（UTC）のタイムゾーンの時刻を表すため、Unix
            タイムスタンプから datetime オブジェクトを作成する際に世界標準時間（UTC）のタイムゾーンを明示的に指定すると、プログラムは Unix タイムスタンプは
            世界標準時間（UTC）であると解釈するため、作成される datetime オブジェクトは世界標準時間（UTC）を世界標準時間（UTC）として解釈したものになり、
            結果的にタイムゾーンの変更は起きません。従って東京時間または地域時間の Unix タイムスタンプはタイムゾーンを変更されることなく、そのまま東京時間また
            は地域時間を表す datetime オブジェクトとなります。このように、この関数ではこの関数内でのみタイムゾーンの調整を行い、アプリケーションの他の部分は
            必要に応じて必要な種類の Unix タイムスタンプを使用して常に世界標準時間（UTC）として datetime オブジェクトへの変換を行うことで、やや難解な
            タイムゾーンの取り扱い処理を行う手間を省くことを実現しています。これは、datetime オブジェクトを作成する際にプログラムが自動的にローカルシステムの
            ローカルタイムゾーンを使用することによる混乱を避けるためのソリューションです。取得値はこの関数を通して全てタプル化します。

            Parameters:
                EndpointName (str): レスポンスデータ取得元のエンドポイント名。
                ItemName (str): 関数 self.ExtractAndFormatData() の引数 DataPaths における、処理中の項目名。
                RawValue (any): 取得値。
                ExpectedValues (tuple of tuples): 期待値。二重のタプル形式。内側のタプル一つにつき一つの期待値を表す。

            Returns:
                tuple of int or float or bool or str or None: 処理した取得値のタプル。

            Raises:
                ValueError:
                    ● パターン 1: 取得値が None の場合に発生。
                    ● パターン 2: 日時データの期待値が UnixTime で、取得値が整数でない場合に発生。
                    ● パターン 3: 日時データの期待値にタイムゾーン名が設定されている場合に、それが無効または認識できないものである場合に発生。
            """
            # 補助関数：任意の日時文字列を Unix タイムスタンプに変換
            def ConvertToUnixTime(DateTime_str, TimeZone = None, ReCall = False):
                """ この部分を「関数の docstring」と言います。
                任意の日時文字列を Unix タイムスタンプに変換する関数。

                この関数は、任意のフォーマットで表現された日時文字列を関数 parser.parse() を使用して解析し、Unix タイムスタンプに変換します。ここで言う
                「任意のフォーマット」とは、関数 parser.parse() が解析可能な、特定の規格に則ったもののことを指します。タイムゾーン情報が渡された場合、その
                情報を使用して世界標準時間（UTC）に変換し、Unix タイムスタンプに変換します。タイムゾーン情報が渡されない場合、日時文字列を世界標準時間（UTC）
                と仮定し、Unix タイムスタンプに変換します。これによって得る Unix タイムスタンプは、元の日時文字列が表現する日時と同じ日時を指す、世界標準時間
                （UTC）でない Unix タイムスタンプです。ただし、日時文字列がタイムゾーン情報を持つ場合、その情報を優先して使用し、世界標準時間（UTC）の Unix
                タイムスタンプに変換します。これはタイムゾーン情報が渡されない場合も同様です。日時文字列のフォーマットが不正であるなどの理由により変換が失敗した
                場合、日時文字列をクリーニングして変換を再試行します。再試行も失敗した場合、その旨の文言を返します。

                ● タイムゾーン情報が渡された場合で日時文字列がタイムゾーン情報を持たない場合
                    渡されたタイムゾーン情報に基づいて世界標準時間（UTC）の Unix タイムスタンプに変換します。
                ● タイムゾーン情報が渡された場合で日時文字列がタイムゾーン情報を持つ場合
                    日時文字列のタイムゾーン情報に基づいて世界標準時間（UTC）の Unix タイムスタンプに変換します。
                ● タイムゾーン情報が渡されない場合で日時文字列がタイムゾーン情報を持たない場合
                    日時文字列を世界標準時間（UTC）と仮定し、Unix タイムスタンプに変換します。
                    （出力する Unix タイムスタンプは世界標準時間（UTC）を表すものではないことに注意してください）
                ● タイムゾーン情報が渡されない場合で日時文字列がタイムゾーン情報を持つ場合
                    日時文字列のタイムゾーン情報に基づいて世界標準時間（UTC）の Unix タイムスタンプに変換します。

                この関数は、これらの仕様に基づいて適切に呼び出される必要があります。

                Parameters:
                    DateTime_str (str): 日時を表す任意のフォーマットの文字列。
                    TimeZone (str, optional):
                        タイムゾーン情報（例: "Asia/Tokyo"）。指定されない場合で日時文字列がタイムゾーン情報を持たない場合、日時文字列を UTC と仮定。
                    ReCall (bool, optional):
                        関数の再帰呼び出しを制御するブール値。このパラメータは内部処理で用い、ユーザーが直接設定することは想定していない。

                Returns:
                    int or str:
                        解析に成功した場合は Unix タイムスタンプ（int）、解析に失敗した場合は解析不能であることを示す文言（str）。
                """
                Cleaning = False  # 日時文字列の解析に失敗した場合にクリーニングを行うことを示すフラグを定義

                try:  # エラーを検出するブロック
                    # 日時文字列を解析し、datetime オブジェクトを作成（日時文字列がタイムゾーン情報を持つ場合、ここで特定）
                    dt = parser.parse(DateTime_str)

                    if TimeZone:  # タイムゾーン情報が渡された場合
                        tz = pytz.timezone(TimeZone)  # 渡されたタイムゾーン情報を使用してタイムゾーンオブジェクトを作成
                    else:  # タイムゾーン情報が渡されていない場合
                        tz = pytz.utc  # 世界標準時間（UTC）のタイムゾーンオブジェクトを作成

                    if dt.tzinfo is None:  # datetime オブジェクトがタイムゾーン情報を持たない場合、前の条件式で用意したタイムゾーン情報を適用する
                        dt = tz.localize(dt)  # 渡されたタイムゾーン情報または世界標準時間（UTC）を適用し、datetime オブジェクトをローカライズ

                    dt = dt.astimezone(pytz.utc)  # ローカライズした datetime オブジェクトのタイムゾーン情報を使用して世界標準時間（UTC）に変換
                    """
                    ● タイムゾーン情報が渡された場合で日時文字列がタイムゾーン情報を持たない場合
                        渡されたタイムゾーン情報に基づいて世界標準時間（UTC）に変換。
                    ● タイムゾーン情報が渡された場合で日時文字列がタイムゾーン情報を持つ場合
                        日時文字列のタイムゾーン情報に基づいて世界標準時間（UTC）に変換。
                    ● タイムゾーン情報が渡されていない場合で日時文字列がタイムゾーン情報を持たない場合
                        日時文字列を世界標準時間（UTC）と仮定済みなので変化なし。
                    ● タイムゾーン情報が渡されていない場合で日時文字列がタイムゾーン情報を持つ場合
                        日時文字列のタイムゾーン情報に基づいて世界標準時間（UTC）に変換。
                    """

                    # datetime オブジェクトの年月日と時刻の属性を検証し、解析が成功したかを判断
                    if dt.year and dt.month and dt.day and (dt.hour is not None and dt.minute is not None and dt.second is not None):
                        return int(dt.timestamp())  # 解析に成功した datetime オブジェクトを Unix タイムスタンプに変換し、結果として返す
                    else:  # 解析に失敗した場合、Cleaning フラグを有効化
                        Cleaning = True  # 日時文字列の解析に失敗した場合にクリーニングを行うことを示すフラグを有効化
                except Exception as e:  # 日時文字列の解析中に何らかのエラーが発生した場合、解析は失敗と判断し、Cleaning フラグを有効化
                    Cleaning = True  # 日時文字列の解析に失敗した場合にクリーニングを行うことを示すフラグを有効化

                if Cleaning and not ReCall:  # 解析に失敗した場合での文字列のクリーニング（再帰呼び出し状態でないことを確認）
                    Cleaned_str = re.sub(rf"[^\d\s{re.escape(string.punctuation)}]", " ", DateTime_str)  # 日時文字列をクリーニング
                    return ConvertToUnixTime(Cleaned_str, TimeZone, True)  # クリーニング後、解析と変換を再試行するため自身を再帰呼び出し
                elif ReCall:  # 再帰呼び出し状態でこのブロックに到達した場合、解析不能を示す文言を返す
                    return str("解析不能な日時文字列")  # 解析不能を示す文言を返す
                """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

            # 補助関数：Unix タイムスタンプを東京時間に変換し、
            # 世界標準時間（UTC）の Unix タイムスタンプと東京時間の Unix タイムスタンプと東京時間の日時文字列を返す
            def UnixTimeToTokyo(EndpointName, ItemName, ExpectedValue, UnixTime_int, TimeZone = None):
                """ この部分を「関数の docstring」と言います。
                Unix タイムスタンプを東京時間に変換し、
                世界標準時間（UTC）の Unix タイムスタンプと東京時間の Unix タイムスタンプと東京時間の日時文字列を返す関数。

                この関数は、世界標準時間（UTC）または地域時間の Unix タイムスタンプに対してアプリケーションが必要とする正規化を施した日時データのタプルを返し
                ます。一般的には Unix タイムスタンプは世界標準時間（UTC）として扱われ、datetime オブジェクトを作成する際も自動的にシステムのローカル
                タイムゾーンが適用されます。しかし、このアプリケーションでは暗号資産取引における日時データの重要性に鑑み、システムのローカルタイムゾーンの適用に
                よる日時データの混乱を避けるため、datetime オブジェクトを作成する際は常に世界標準時間（UTC）を適用します。この仕様はこの関数だけのものでは
                なく、アプリケーション全体に及ぶものです。従って、アプリケーションの他の関数が datetime オブジェクトを作成する際に常に世界標準時間（UTC）を
                適用することができるよう、この関数は Unix タイムスタンプを調整します。アプリケーションの他の関数は、必要に応じて世界標準時間（UTC）の Unix
                タイムスタンプと東京時間に変換された Unix タイムスタンプを使い分けることができます。

                Parameters:
                    EndpointName (str): レスポンスデータ取得元のエンドポイント名。
                    ItemName (str): 関数 self.ExtractAndFormatData() の引数 DataPaths における、処理中の項目名。
                    ExpectedValue (str): 呼び出し元のコンテキストで取り扱っている期待値。
                    UnixTime_int (int): 世界標準時間（UTC）の Unix タイムスタンプ。
                    TimeZone (str, optional): タイムゾーン情報（例: "Asia/Tokyo"）。

                Returns:
                    tuple of int, int, str: 世界標準時間（UTC）の Unix タイムスタンプと東京時間の Unix タイムスタンプと東京時間の日時文字列のタプル。

                Raises:
                    ValueError:
                        ● パターン 1: Unix タイムスタンプとしてビットコイン初取引以前の日時を表す整数値が渡された場合に発生。
                        ● パターン 2: Python の datetime モジュールで処理できない整数値が渡された場合に発生。
                    OverflowError:
                        ● パターン 1: Unix タイムスタンプとして極端に大きな整数値が渡された場合に発生。
                    Exception:
                        ● 予期せぬエラーは再発生。
                """
                if not TimeZone:  # タイムゾーン情報が渡されていない場合、世界標準時間（UTC）の Unix タイムスタンプを datetime オブジェクトに変換
                    UTC_dt = datetime.fromtimestamp(UnixTime_int, timezone.utc)  # 世界標準時間（UTC）の datetime オブジェクトを取得
                else:  # タイムゾーン情報が渡されている場合
                    try:  # エラーを検出するブロック
                        # ビットコイン初取引の 2009 年 1 月 12 日 00:00:00 UTC 未満の場合、ValueError を発生させる
                        if UnixTime_int < 1231718400:
                            raise ValueError("")  # ValueError を空文字列を内容として発生させる

                        # 地域時間の Unix タイムスタンプを datetime オブジェクトに変換（UnixTime_int は世界標準時間（UTC）でなく地域時間）
                        # TimeZone を使用して datetime オブジェクトを取得
                        Local_dt = datetime.fromtimestamp(UnixTime_int, pytz.timezone(TimeZone))
                        UTC_dt = Local_dt.astimezone(pytz.utc)  # 地域時間の datetime オブジェクトのタイムゾーンを世界標準時間（UTC）に変更
                        UnixTime_int = int(UTC_dt.timestamp())  # 地域時間の UnixTime_int を世界標準時間（UTC）の Unix タイムスタンプで上書き
                    except ValueError as e:  # ValueError が発生した場合
                        if str(e) == "":  # ビットコイン初取引の 2009 年 1 月 12 日 00:00:00 UTC 未満の場合、適切なメッセージを設定
                            raise ValueError(("Unix タイムスタンプとしてビットコイン初取引以前の日時を表す整数値が渡されています。"
                                "エンドポイント名：{0}、項目名：{1}、現在の期待値：{2}").format(
                                    str(EndpointName), str(ItemName), str(ExpectedValue)))
                        else:  # エラーメッセージが存在する場合
                            raise ValueError(("Python の datetime モジュールで処理できない整数値が渡されています。"
                                "エンドポイント名：{0}、項目名：{1}、現在の期待値：{2}").format(
                                    str(EndpointName), str(ItemName), str(ExpectedValue)))
                    except OverflowError as e:  # OverflowError が発生した場合
                        raise OverflowError(("Unix タイムスタンプとして極端に大きな整数値が渡されています。"
                            "エンドポイント名：{0}、項目名：{1}、現在の期待値：{2}").format(
                                str(EndpointName), str(ItemName), str(ExpectedValue)))
                    except Exception as e:  # 何らかのエラーが発生した場合
                        raise e  # エラーを再発生させる

                # 世界標準時間（UTC）の datetime オブジェクトのタイムゾーンを東京時間に変更
                Tokyo_dt = UTC_dt.astimezone(pytz.timezone("Asia/Tokyo"))

                # 東京時間（UTC+9）の datetime オブジェクトのタイムゾーンを UTC+9 の Unix タイムスタンプを得るために強制的に世界標準時間（UTC）に置換
                Tokyo_dt_tzInfoUTC = Tokyo_dt.replace(tzinfo = pytz.utc)

                # 東京時間（UTC+9、タイムゾーン：UTC）の datetime オブジェクトを UTC+9 の Unix タイムスタンプに変換
                Tokyo_UnixTime_int = int(Tokyo_dt_tzInfoUTC.timestamp())

                # 元の、または世界標準時間（UTC）に変換された Unix タイムスタンプと、東京時間（UTC+9）の Unix タイムスタンプと、東京時間の日時文字列を返す
                # （複数の値を返す場合、自動的にタプル化）
                return UnixTime_int, Tokyo_UnixTime_int, Tokyo_dt.strftime("Tokyo %Y/%m/%d %H:%M:%S")
                """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

            """ ConvertExtractedValueWithExpected() の記述 """
            if RawValue is not None:  # 取得値が None でない場合、正規化を行う
                ProcessedValue = None  # 変数を初期化

                # 取得値が数字の文字列（str）の場合、数値（int or float）に変換
                if isinstance(RawValue, str) and RawValue.replace(".", "", 1).isdigit():
                    # 処理済みの取得値として数値型（int or float）に変換して代入
                    ProcessedValue = float(RawValue) if "." in RawValue else int(RawValue)
                    if isinstance(ProcessedValue, float):  # 変換結果が浮動小数点数（float）の場合、処理を終了
                        return (ProcessedValue,)  # 処理を終了して ProcessedValue のタプルを返す

                # 取得値が bool 値として解釈可能な文字列（str）の場合、bool 値を返す
                if ProcessedValue is None and isinstance(RawValue, str) and RawValue.lower() == "true":  # True の場合
                    return (True,)  # 処理を終了して True のタプルを返す
                elif ProcessedValue is None and isinstance(RawValue, str) and RawValue.lower() == "false":  # False の場合
                    return (False,)  # 処理を終了して False のタプルを返す

                # 取得値が NoneType として解釈可能な文字列（str）の場合、None を返す
                if ProcessedValue is None and isinstance(RawValue, str) and RawValue.lower() in {"null", "none", "nonetype"}:
                    return (None,)  # 処理を終了して None のタプルを返す

                # 取得値が元々文字列型（str）以外のデータ型、またはここまでで確認したデータ型として解釈できない文字列（str）の場合
                if ProcessedValue is None:
                    if isinstance(RawValue, int):  # 取得値が整数値（int）の場合、その型を維持
                        ProcessedValue = RawValue  # 処理済みの取得値として代入
                    # 取得値が浮動小数点数（float）または bool 値または None の場合、その型を維持
                    elif isinstance(RawValue, (float, bool, type(None))):
                        return (RawValue,)  # 処理を終了して RawValue のタプルを返す
                    # 取得値が数値（int or float）、bool 値、None として解釈可能な文字列（str）でなく、元々それらの型でもない場合、文字列型（str）とする
                    else:
                        ProcessedValue = str(RawValue)  # 処理済みの取得値として文字列型（str）に変換して代入

                # return されず ProcessedValue が存在する = 整数値（int）または文字列（str）の場合、期待値が文字列（str）の場合の処理を行う
                if ProcessedValue and ExpectedValues and ExpectedValues[0] and isinstance(ExpectedValues[0][0], str):
                    if any("UnixTime" in ExpectedTuple for ExpectedTuple in ExpectedValues):  # 日時データの処理、期待値が UnixTime の場合
                        if not isinstance(ProcessedValue, int):  # 取得値が UnixTime として解釈可能な整数値（int）かを確認
                            raise ValueError(("日時データが Unix タイムスタンプではありません。正しい期待値を設定してください。"
                                "エンドポイント名：{0}、項目名：{1}、現在の期待値：{2}").format(
                                    str(EndpointName), str(ItemName), str(ExpectedValues[0][0])))

                        # Unix タイムスタンプを東京時間に変換し、
                        # 世界標準時間（UTC）の Unix タイムスタンプと東京時間の Unix タイムスタンプと東京時間の日時文字列のタプルを取得
                        return UnixTimeToTokyo(EndpointName, ItemName, "UnixTime", ProcessedValue)  # 取得値のタプルを返す
                    # 日時データの処理、期待値が MilliUnixTime の場合
                    elif any("MilliUnixTime" in ExpectedTuple for ExpectedTuple in ExpectedValues):
                        if not isinstance(ProcessedValue, int):  # 取得値が MilliUnixTime として解釈可能な整数値（int）かを確認
                            raise ValueError(("日時データが Unix タイムスタンプではありません。正しい期待値を設定してください。"
                                "エンドポイント名：{0}、項目名：{1}、現在の期待値：{2}").format(
                                    str(EndpointName), str(ItemName), str(ExpectedValues[0][0])))

                        ProcessedValue = ProcessedValue / 1000  # ミリ秒単位の Unix タイムスタンプを秒単位に変換して代入
                        # Unix タイムスタンプを東京時間に変換し、
                        # 世界標準時間（UTC）の Unix タイムスタンプと東京時間の Unix タイムスタンプと東京時間の日時文字列のタプルを取得
                        return UnixTimeToTokyo(EndpointName, ItemName, "MilliUnixTime", ProcessedValue)  # 取得値のタプルを返す
                    # 日時データの処理、期待値がタイムゾーン名の場合（"TimeZone" は単一の期待値を構成する要素の部分文字列なため要素毎に評価）
                    elif any("TimeZone" in ExpectedValue for ExpectedTuple in ExpectedValues for ExpectedValue in ExpectedTuple):
                        # ジェネレータ式を開始し、期待値からタイムゾーン情報を含む文字列（str）を取り出す
                        MatchedTuple_val = str(next((ExpectedValue
                            for ExpectedTuple in ExpectedValues  # 全期待値を表すタプルから単一の期待値を表すタプルを取り出す
                            for ExpectedValue in ExpectedTuple  # 単一の期待値を表すタプルから単一の期待値を構成する要素を取り出す
                            if ExpectedValue.startswith("TimeZone")),  # 単一の期待値を構成する要素が "TimeZone" で始まるか確認する条件式
                            None))  # 最後のイテレータを処理した後にジェネレータ式に渡す値として None を設定
                        # タイムゾーン名として利用可能な形にする
                        FormattedTimeZone = MatchedTuple_val.replace("TimeZone", "", 1).replace("-", "/", 1)
                        # タイムゾーン名として pytz ライブラリの all_timezones リストで有効でない場合
                        if FormattedTimeZone not in pytz.all_timezones:
                            raise ValueError(("無効なタイムゾーン名が設定されています。"
                                "エンドポイント名：{0}、項目名：{1}、現在のタイムゾーン名：{2}").format(
                                    str(EndpointName), str(ItemName), str(FormattedTimeZone)))

                        # ProcessedValue の日時文字列（str）を Unix タイムスタンプに変換、または整数値（int）の場合は直接 SetOfTime タプルに変換
                        UTC_UnixTime_int = ConvertToUnixTime(ProcessedValue, TimeZone = FormattedTimeZone) if \
                            isinstance(ProcessedValue, str) else UnixTimeToTokyo(
                                EndpointName, ItemName, FormattedTimeZone, ProcessedValue, TimeZone = FormattedTimeZone)
                        # 補助関数 ConvertToUnixTime() の結果が整数値の場合、補助関数 UnixTimeToTokyo() で処理
                        if isinstance(UTC_UnixTime_int, int):
                            # Unix タイムスタンプを東京時間に変換し、
                            # 世界標準時間（UTC）の Unix タイムスタンプと東京時間の Unix タイムスタンプと東京時間の日時文字列のタプルを取得
                            SetOfTime = UnixTimeToTokyo(EndpointName, ItemName, FormattedTimeZone, UTC_UnixTime_int)
                        # 補助関数 ConvertToUnixTime() の結果が整数値（int）でない場合、
                        # 日時文字列が解析不能なためタイムゾーン名と共にそのまま取得値として格納
                        elif isinstance(UTC_UnixTime_int, str) and UTC_UnixTime_int == "解析不能な日時文字列":
                            Tokyo_UnixTime_int = str("Unixタイムスタンプ利用不可")  # 東京時間の Unix タイムスタンプが利用できない旨の文言を設定
                            # タイムゾーン名と元の日時文字列を設定
                            DateTime_str = str("{0} {1}".format(str(FormattedTimeZone), str(ProcessedValue)))
                            SetOfTime = (UTC_UnixTime_int, Tokyo_UnixTime_int, DateTime_str,)  # 各種値を結果としてタプル化
                        elif isinstance(UTC_UnixTime_int, tuple):  # 補助関数 UnixTimeToTokyo() を実行した場合、タプルを SetOfTime に格納
                            SetOfTime = UTC_UnixTime_int  # タプルを SetOfTime に格納
                        return SetOfTime  # 取得値のタプルを返す
                    # 日時データの処理、期待値が LocalTime の場合
                    elif any("LocalTime" in ExpectedTuple for ExpectedTuple in ExpectedValues):
                        # LocalTime の場合、世界標準時間（UTC）への変換はできない前提のためその旨の文言を設定
                        UTC_UnixTime_int = str("UTC時間利用不可")
                        Local_UnixTime_int = ConvertToUnixTime(ProcessedValue)  # 日時文字列を Unix タイムスタンプに変換
                        # 補助関数 ConvertToUnixTime() の結果が整数値（int）の場合、適切な日時文字列を作成
                        if isinstance(Local_UnixTime_int, int):
                            # 補助関数 ConvertToUnixTime() の結果である Local_UnixTime_int は世界標準時間（UTC）でないがそのように取り扱い可能な仕様
                            DateTime_str = datetime.fromtimestamp(
                                Local_UnixTime_int, tz = timezone.utc).strftime("Local %Y/%m/%d %H:%M:%S")
                        # 補助関数 ConvertToUnixTime() の結果が整数値（int）でない場合、日時文字列が解析不能なためそのまま取得値として格納
                        elif isinstance(Local_UnixTime_int, str) and Local_UnixTime_int == "解析不能な日時文字列":
                            DateTime_str = ProcessedValue  # そのまま取得値として格納
                        return (UTC_UnixTime_int, Local_UnixTime_int, DateTime_str,)  # 取得値のタプルを返す
                    """
ここでは、正規化した日時データとして、元の日時文字列が解析不能な場合にその旨の文言を格納していますが、このアプリケーションは基本的に元の日時文字列が解析可能な場合
にのみ正しく動作します。ここでの適切な文言の格納は、アプリケーションのメインフレーム「接続先編集」タブの「データパスをテスト」ボタンでの処理時に、テスト結果として
日時文字列が解析不能であることをユーザーに知らせるためのものです。
                    """

                # 期待値別の処理に該当しない場合、ProcessedValue のタプルを返す
                return (ProcessedValue,) if not isinstance(ProcessedValue, tuple) else ProcessedValue
            elif RawValue is None:  # 取得値が None の場合、その型を維持
                return (RawValue,)  # 処理を終了して RawValue のタプルを返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：取得値を DataHandleForm の設計指示に従ってアプリケーションが取り扱うデータ構造に正規化
        def DataFormatProcessor(EndpointName, ItemName, DataHandleForm, ProcessedValue, StructuredData, DataIndex1 = None,
            DataIndex2 = None):
            """ この部分を「関数の docstring」と言います。
            取得値を DataHandleForm の設計指示に従ってアプリケーションが取り扱うデータ構造に正規化する関数。

            この関数は、引数 DataHandleForm の設計指示に基づいて、取得値を引数 StructuredData 辞書内でアプリケーションが取り扱うデータ構造に正規化して格納
            します。取得値は StructuredData 辞書の "Data" キーの適切な位置に格納し、この際取得値には何らの変更も加えません。取得値の項目名がデータとして重要
            な場合、その項目名をタプル形式で格納することがあります。StructuredData 辞書の "Data" キーには DataHandleForm の設計指示に従ったデータ構造を
            構築します。DataHandleForm は、関数 self.ExtractAndFormatData() で AppClass（self.App）属性の DataHandleForm 属性から取得される
            EndpointName に対応する初期化済みのデータ構造です。このデータ構造には "DataHandleNames" "KeyPath" の二つのキーが存在し、"DataHandleNames"
            は、アプリケーションが取り扱うデータ構造を示す初期化されたデータ構造、正規化の設計指示を値として持ちます。"KeyPath" はその初期化されたデータ構造の
            各項目にアクセスするためのデータパスの辞書です。この関数は、これらの値を使用して関数 self.SetDataVal() を呼び出し、アプリケーションが取り扱う
            データ構造に対する取得値の格納を行います。このプロセスは、複雑なデータ構造をデータの整合性を保ちながら効率的に正規化するために設計されています。

            Parameters:
                EndpointName (str): レスポンスデータ取得元のエンドポイント名。
                ItemName (str): 関数 self.ExtractAndFormatData() の引数 DataPaths における、処理中の項目名。またはデータそのもの。
                DataHandleForm (dict): 取得値をアプリケーションが取り扱うデータ構造に正規化するための設計指示を含む辞書の参照。
                ProcessedValue (tuple or list of any): 処理済みの取得値。タプルまたはリスト形式。
                StructuredData (dict): 取得値をアプリケーションが取り扱うデータ構造に正規化する先の辞書の参照。
                DataIndex1 (int, optional): 関数 self.ExtractAndFormatData() の引数 Data の一単位のデータに対するインデックス番号。
                DataIndex2 (int, optional):
                    関数 self.ExtractAndFormatData() の引数 Data の一単位のデータ内のセルデータに対して [list] タグによって割り振られたインデックス
                    番号。DataIndex1 を指定せず、DataIndex2 のみの指定は不可。そのような状況では DataIndex2 を DataIndex1 として渡す。

            Returns:
                dict: 元の StructuredData の正規化したデータ構造に取得値を格納した辞書。

            Raises:
                ValueError:
                    ● パターン 1: ItemName（取得値の項目名）がプログラムで認識できない名前（用意された項目名と一致しない）の場合に発生。
                        これは、ユーザーが「接続先編集」画面でエンドポイントに対するデータパスを編集した際に、誤って「プログラムで用意されたものでない項目名」
                        を保存した場合に起こります。
                    ● パターン 2: エンドポイントのレスポンスデータ内に複数の単位データが含まれることが予期せず示唆された場合に発生。
                        レスポンスデータ内に複数の単位データが含まれることがエンドポイントの役割と合理的に整合する場合、AppClass（self.App）属性の
                        DataHandleForm 属性の定義を見直す必要があります。
                    ● パターン 3: エンドポイントのレスポンスデータ内の一単位のデータ内にリストが含まれることが予期せず示唆された場合に発生。
                        レスポンスデータ内の一単位のデータ内にリストが含まれることがエンドポイントの役割と合理的に整合する場合、AppClass（self.App）属性の
                        DataHandleForm 属性の定義を見直す必要があります。
                    ● パターン 4: レスポンスデータからリストの値を取得し、取得した PathForStructure が一つのセグメントしか持たない場合に発生。
                        これは、プログラムの内部に問題があり、取得値がリストの要素なのに対して正規データ構造が一階層のみで定義されているか、正規データ構造に
                        対するデータパスが間違って定義されている場合に起こり得ます。正規データ構造の最上位階層は必ずリストと定められており、この中に任意の
                        データ構造を置きます。取得値がリストの要素の場合、正規データ構造では最上位のリストの中に唯一の要素としてリストを配置し、その中に取得値
                        を格納する必要があります。このエラーが発生する場合、AppClass（self.App）属性の DataHandleForm 属性の定義を確認してください。
            """
            # 正規データ構造のテンプレート構造体の ItemName に対応するデータパスを取得（不正な ItemName の場合、空文字列（str）を格納）
            Template_DataPath = DataHandleForm["KeyPath"].get(ItemName, "")

            if Template_DataPath == "":  # 不正な ItemName（項目名）が設定されている場合、正しい項目名を設定するよう促す旨の ValueError を発生させる
                raise ValueError(("データの項目名がプログラムで認識できないものになっています。正しい項目名を設定してください。"
                    "エンドポイント名：{0}、項目名：{1}").format(str(EndpointName), str(ItemName)))

            # ItemName と ProcessedValue を比較し、同じ内容の場合 ItemName を格納するべき値と判断（項目名：買い、売りなど）
            if not isinstance(ProcessedValue, tuple) and str(ItemName) == str(ProcessedValue):
                ProcessedValue = (str(ItemName),)  # 両者は同じ内容だが、タプルとして渡されないのでタプル化

            if EndpointName not in StructuredData:  # StructuredData に EndpointName がまだ存在しない場合、初期化
                # 関数 copy.deepcopy() を使用して、参照ではなく複製を取得
                Template_DataForm = copy.deepcopy(DataHandleForm["DataHandleNames"])
                # 関数 self.SetDataVal() に渡すためのデータ構造を用意
                # "Data" キーに関数 copy.deepcopy() を使用して、参照ではなく複製を追加（正規データ構造）
                StructuredData[EndpointName] = {
                    "TemplateForm": Template_DataForm, "TemplatePath": Template_DataPath, "Data": copy.deepcopy(Template_DataForm),}
            else:  # StructuredData に EndpointName が存在する場合、TemplatePath を現在の ItemName に対応するものに更新
                StructuredData[EndpointName]["TemplatePath"] = Template_DataPath  # 前回のものを今回のもので上書き

            PathForStructure = Template_DataPath  # ItemName に対応する格納先、正規データ構造のデータパスとして Template_DataPath を使用

            if DataIndex1 is None:  # DataIndex1 が指定されていない場合の取得値の正規データ構造への格納処理
                if "." not in PathForStructure:  # PathForStructure にドットが含まれない場合、唯一のキーとして扱い取得値を格納
                    StructuredData[EndpointName]["Data"][PathForStructure] = ProcessedValue  # この場合、直接取得値を格納可能
                else:  # PathForStructure にドットが含まれる場合、複数階層を表すキーとして扱い取得値を格納
                    # レスポンスデータがリストでなくとも内部的にはリストとして扱っている場合、リストの唯一の要素となるためインデックス "0" を指定
                    # データパスの index セグメントを 0 に置換（なければ何も行わない）
                    PathForStructure = PathForStructure.replace("index", "0", 1)
                    # 最適化した PathForStructure を使用して取得値を関数 self.SetDataVal() で格納
                    StructuredData[EndpointName] = self.SetDataVal(
                        EndpointName, ProcessedValue, StructuredData[EndpointName], PathForStructure)
            elif isinstance(DataIndex1, int):  # DataIndex1 が指定されている場合の取得値の正規データ構造への格納処理
                if "index" in PathForStructure:  # PathForStructure に index セグメントが存在することを確認
                    # PathForStructure の index セグメントを DataIndex1 の整数値（int）で置換
                    PathForStructure = PathForStructure.replace("index", str(DataIndex1), 1)
                else:  # PathForStructure に index セグメントが存在しない場合、ValueError を発生させる
                    raise ValueError(("このエンドポイントのレスポンスデータ内に複数の単位データが含まれることは想定されていません。"
                        "エンドポイント名：{0}、項目名：{1}").format(str(EndpointName), str(ItemName)))

                # DataIndex2 が指定されていて、まだ index セグメントが存在する場合
                if isinstance(DataIndex2, int) and "index" in PathForStructure:
                    # PathForStructure の index セグメントを DataIndex2 の整数値（int）で置換
                    PathForStructure = PathForStructure.replace("index", str(DataIndex2), 1)
                # DataIndex2 が指定されていて、index セグメントが存在しない場合
                elif isinstance(DataIndex2, int) and "index" not in PathForStructure:
                    raise ValueError(("このエンドポイントのレスポンスデータ内の一単位のデータ内にリストが含まれることは想定されていません。"
                        "エンドポイント名：{0}、項目名：{1}").format(str(EndpointName), str(ItemName)))

                if "." in PathForStructure:  # PathForStructure にドットが含まれることを確認
                    """ DataIndex1 が指定されている場合、PathForStructure は必ずドットを含み、複数の階層を示します。 """
                    # 最適化した PathForStructure を使用して取得値を関数 self.SetDataVal() で格納
                    StructuredData[EndpointName] = self.SetDataVal(
                        EndpointName, ProcessedValue, StructuredData[EndpointName], PathForStructure)
                else:  # PathForStructure にドットが含まれない場合、ValueError を発生させる
                    raise ValueError(("リストからの取得値に対する格納先のデータパスが正しく設定されていません。内部エラーのため、"
                        "開発者に連絡してください。エンドポイント名：{0}、項目名：{1}").format(str(EndpointName), str(ItemName)))

            return StructuredData  # 元の StructuredData に取得値を格納した StructuredData を返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：取得値と期待値を照合
        def ComparisonWithExpected(ProcessedValue, ExpectedValues, NegatedValues):
            """ この部分を「関数の docstring」と言います。
            取得値と期待値を照合する関数。

            この関数は、処理済みの取得値として渡されるレスポンスデータから取り出した値のタプル ProcessedValue の要素 [0] を期待値と照合し、一致または不一致
            の結果を表す bool 値を返します。期待値は二重のタプル形式で、内側の各タプルは各々単一の期待値を表します。照合は数値型（int or float）の場合は数値
            型として、文字列型（str）の場合は文字列型として行います。また、bool 値や NoneType の照合も行います。これは、取得値がこれらのデータ型である場合
            でも、期待値が複数存在する可能性や期待値が二重のタプル形式であることを考慮すると、この関数で包括的に評価する方がハンドリングを行いやすいためです。
            なお、一致とは完全一致することを指し、部分一致は不一致とみなします。内側のタプルが複数存在する、即ち期待値が複数存在する場合、そのいずれかに一致する
            場合に一致とみなします。取得値が数値型（int or float）の場合の照合を行う場合、全期待値を表すタプル内の単一の期待値を表すタプルから取得値と同じ
            データ型（int or float）の要素を取り出し、取得値と比較誤差 0.005 の範囲で一致する場合に一致判定を返します。この比較誤差は、浮動小数点数の小数点
            以下第二位までの照合精度を確保するためのものです。数値を比較する際、特に浮動小数点数を扱う場合、微小な誤差が生じることがあります。これはコンピュータ
            が 10 進数を 2 進数で表現する過程で必然的に生じる現象です。例えば、10.005 という数値が、内部的には 10.004999999999999 として保存されることが
            あります。このような微小な差を無視して、実質的に等しい数値を「等しい」と認識するためには､「許容誤差」または「比較誤差」という概念を導入します。許容
            誤差は、予め設定された小さな数値、この関数では 0.005 で、二つの数値の差がこの値以下であれば、それらの数値を等しいとみなします。この方法により、微小
            な計算誤差による不整合を防ぐことができます。この比較方法は、特に金融や科学技術計算で非常に重要です。適切な許容誤差を設定することで、意図しないエラー
            や不整合を避け、より信頼性の高いプログラムを作成することが可能になります。取得値が文字列型（str）の場合の照合を行う場合、全期待値を表すタプル内の
            単一の期待値を表すタプル内の全ての単語（str）を、正規表現の単語境界表現と非単語文字の表現を用いて正規表現パターンとして組み立て、取得値がこの
            正規表現パターンに完全一致する場合に一致判定を返します。また、期待値が引数 ExpectedValues ではなく引数 NegatedValues に存在する場合は、取得値
            と期待値が一致しない場合に一致判定を返します。これは、例えば API のレスポンスサンプルに "success" キーがあるとき、成功時の値は示されているが
            失敗時の値は示されていない場合などに、成功時とは異なる値で失敗とみなしたい場合に有用です。

            Parameters:
                ProcessedValue (tuple of any): 処理済みの取得値。タプル形式。
                ExpectedValues (tuple of tuples): 期待値。二重のタプル形式。内側のタプル一つにつき一つの期待値を表す。
                NegatedValues (tuple of tuples): 否定的期待値。二重のタプル形式。内側のタプル一つにつき一つの期待値を表す。

            Returns:
                bool: 取得値と期待値が一致する場合、True。そうでなければ False。
            """
            # 補助関数：補助関数 ComparisonWithExpected() の実際の照合処理を行う
            def Core_ofComparisonWithExpected(ProcessedValue, ExpectedValues):
                """ この部分を「関数の docstring」と言います。
                補助関数 ComparisonWithExpected() の実際の照合処理を行う関数。

                この関数は、補助関数 ComparisonWithExpected() の担うべき処理のコア部分をカプセル化したものです。

                Args:
                    ProcessedValue (tuple of any): 比較対象の取得値を含むタプル。最初の要素のみを使用。
                    ExpectedValues (tuple of tuples): 比較対象の期待値。二重のタプル形式。内側のタプル一つにつき一つの期待値を表す。

                Returns:
                    bool: 取得値と期待値が一致する場合、True。そうでなければ False。
                """
                if isinstance(ProcessedValue[0], (int, float)):  # 取得値が数値（int or float）の場合は数値として期待値と照合
                    Epsilon = 0.005  # 小数点以下第二位までの比較誤差を許容するための設定値
                    # 数値（int or float）としての比較を実行、メソッド abs() は負の値を正の値に変換する
                    Result = any(abs(float(ProcessedValue[0]) - ExpectedValue) <= Epsilon
                        for ExpectedTuple in ExpectedValues  # 全期待値を表すタプルから単一の期待値を表すタプルを取り出す
                        for ExpectedValue in ExpectedTuple  # 単一の期待値を表すタプルから期待値を取り出す
                        if isinstance(ExpectedValue, (int, float)))  # 数値（int or float）として比較可能な期待値を取り出すための条件式
                    return Result  # 照合結果を返す
                    """
ここでは、期待値に数値比較に使用できない値が設定されている場合のエラーハンドリングを明示的に行っていませんが、これは意図的なものです。この関数は、値が適切かを判断
する責務を持たず、単に照合処理のみを行います。これは取得値が数値（int or float）なのに対して期待値が数値比較可能なものではない場合、この関数は False を返す責務
を持つということを意味します。この挙動により、この関数の呼び出し元、補助関数 ComparisonWithExpected() のさらにその呼び出し元で、取得値をどのように取り扱うべき
かが判断され、全体の処理結果に反映されます。この関数が False を返し、呼び出し元である補助関数 ComparisonWithExpected() も False を返す場合、照合に使用した
取得値は全体の処理結果に含められません。これは即ち、場合によっては全体の処理結果の対応する項目が初期値の None のままになるということを意味します。この状態は、
メインフレーム「接続先編集」タブの「データパスをテスト」ボタンによる一連の処理の結果であれば、None が適切にダイアログに表示され、ユーザーはデータパスの指定方法が
間違っていることを認識できます。また、エンジン稼働中にこの状態になった場合は、エンジンはデータパスのテストを実行します。これは GUI の「データパスをテスト」ボタン
でのテストと同じ処理をエンジンが行うために最適化された状態で行うもので、ここでエラーが発生しなければ、エンジンは API 側で通常とは異なる問題が発生していると認識し、
自動処理を続行する判断を行います。即ち、全体の処理結果の対応する項目が初期値の None のままになる状態は、GUI の「データパスをテスト」ボタンでのテストを通じて適切
に対応されることが前提であり、この前提の下でエンジンも適切な判断を行います。従って、この関数は入力値に関わらず、単に照合処理のみを行います。
                    """
                elif isinstance(ProcessedValue[0], bool):  # 取得値が bool 値の場合は bool 値として期待値と照合
                    if ProcessedValue[0]:  # 取得値が True の場合、期待値に True が存在するか確認し、存在する場合 True、しない場合 False を返す
                        return any(True in ExpectedTuple for ExpectedTuple in ExpectedValues if isinstance(ExpectedTuple[0], bool))
                    else:  # 取得値が False の場合、期待値に False が存在するか確認し、存在する場合 True、しない場合 False を返す
                        return any(False in ExpectedTuple for ExpectedTuple in ExpectedValues if isinstance(ExpectedTuple[0], bool))
                elif isinstance(ProcessedValue[0], str):  # 取得値が文字列（str）の場合は文字列として期待値と照合
                    for ExpectedTuple in ExpectedValues:  # 全期待値を表すタプルから単一の期待値を表すタプルを取り出すためのイテレーション
                        # 単一の期待値を表すタプルの期待値を構成する要素が一つの場合、単語境界が不要なため直接取得値と照合
                        if len(ExpectedTuple) == 1 and isinstance(ExpectedTuple[0], str):
                            if ProcessedValue[0] == ExpectedTuple[0]:  # 取得値と期待値が一致する場合、True を返す
                                return True  # 処理を終了して True を返す
                        # 単一の期待値を表すタプルの期待値を構成する要素が二つ以上の場合、単語境界を考慮した正規表現での照合処理を行う
                        # 単一の期待値を表すタプルの期待値を構成する要素は単一のデータ型で統一されているため、最初の要素が str であれば全ての要素が str
                        elif isinstance(ExpectedTuple[0], str):
                            # 期待値を構成する要素をエスケープした上で
                            # 単語境界 \b と非単語文字（空白、ピリオド、ハイフンなど）でマッピングし、正規表現パターンを作成
                            # 単語境界 \b は単語が他の単語から独立していることを保証し、非単語文字は多様な区切り記号をサポートし、
                            # どのような形式の取得値にも対応
                            Pattern = r"^\W*" + r"\b" + r"[\s\W]*".join(map(re.escape, ExpectedTuple)) + r"\b" + r"\W*$"
                            if re.search(Pattern, ProcessedValue[0]):  # 取得値と正規表現パターンを照合し、完全一致する場合、True を返す
                                return True  # 処理を終了して True を返す
                            r"""
ここでは、単一の期待値を表すタプルの、期待値を構成する要素、つまり単語が二つ以上の場合、正規表現を使用して取得値との照合を行っています。正規表現は、単語境界 \b を
活用して文字列中の部分一致を排除し、期待値を構成する要素が完全な単語として独立して存在するかどうかを明確に判断するために非常に効果的です。この手法は、複雑な
データセットを扱う際に信頼性と効率を大幅に向上させることができます。また、正規表現は非単語文字 \W を用いることで、期待値を構成する要素の前後に存在する任意の非単語
文字を適切に処理することができます。このように、正規表現を用いた照合処理は正確性において優れていますが、処理速度の面では「==」演算子を用いた単純照合に比してやや
劣ります。具体的には、平均的なラップトップを基準とすると「==」演算子を用いた照合はミリ秒の 1000 分の 1 単位である数マイクロ秒程度で完了するのに対し、正規表現を
用いた照合では数十マイクロ秒から数百マイクロ秒程度を要します。数百マイクロ秒という数値は、期待値を構成する要素が 5 個の場合です。ただし、実際には複数の要素から
成る文字列の照合を必要とするのは API の稼働状態を確認する場合など、限定的です。エンジンが通常運転状態の場合、行われる文字列照合は「==」演算子を用いたものになると
考えられます。また、仮に正規表現を用いた照合が頻繁に行われるとしても、実際にこのアプリケーションがサポート対象としているのは Apple Silicon 搭載 Mac、またはこれ
と同等の処理能力を有するデバイスであるため、それらの照合処理は一回あたり 20 マイクロ秒 = 0.02 ミリ秒程度で完了するものと考えられます。この数値はこの
アプリケーションのエンジンの設計上充分に許容できる処理時間であるため、照合の正確性を確保するために正規表現を使用することは、実用上問題になりません。この技術的な
判断は、複雑なデータの検証と操作を必要とする現代のアプリケーション開発において、非常に有効な手法であることが確認されています。
                            """
                    else:  # 全期待値を表すタプルのいずれの期待値とも一致しない場合、False を返す
                        return False  # 処理を終了して False を返す
                elif ProcessedValue[0] is None:  # 取得値が None の場合は None として期待値と照合し、一致する場合、True、しない場合、False を返す
                    return any(None in ExpectedTuple for ExpectedTuple in ExpectedValues)

                return False  # ここまでのいずれの条件にも該当しない場合、処理を終了して False を返す
                """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

            """ ComparisonWithExpected() の記述 """
            if len(ProcessedValue) >= 2:  # 取得値が二つ以上の要素を内包する場合は既に期待値によって処理済みのため True を返す
                """
実際にこの条件式が True となることは想定していません。ここで True となる場合、この関数の呼び出し前のロジックに問題があることを意味します。
                """
                return True  # 処理を終了して True を返す
            else:  # 正常な呼び出し状態の処理
                if (ExpectedValues and ExpectedValues[0]) or (NegatedValues and NegatedValues[0]):  # 期待値が設定されていることを確認
                    if ExpectedValues:  # 通常の期待値との照合処理
                        return Core_ofComparisonWithExpected(ProcessedValue, ExpectedValues)  # 照合結果をそのまま返す
                    elif NegatedValues:  # 否定的期待値との照合処理
                        return not Core_ofComparisonWithExpected(ProcessedValue, NegatedValues)  # 否定的期待値なので照合結果を反転して返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # 補助関数：補助関数 SecondProcess_DataRetrievalAndFormat() 内の、データの取得、取得値の処理、取得値の StructuredData への格納処理をハンドル
        def FinalProcess_ofSecondProcess(EndpointName, ItemName, NotListUpAndCorrect, ListUpKey, Data, Final_DataPath,
            bool_ofIndexedListTags, ExpectedValues, NegatedValues, DataHandleForm, StructuredData, ProcessedValue_ofListTags,
            DataIndex = None):
            """ この部分を「関数の docstring」と言います。
            補助関数 SecondProcess_DataRetrievalAndFormat() 内の、データの取得、取得値の処理、取得値の StructuredData への格納処理をハンドルする関数。

            この関数は、補助関数 SecondProcess_DataRetrievalAndFormat() の一部として機能し、API のエンドポイントから返されたレスポンスデータの最終処理を
            担当します。この処理には、最適化されたデータパス、引数 Final_DataPath に基づくデータの取得、取得したデータの正規化、及び正規化したデータを
            StructuredData に格納するプロセスが含まれます。引数 NotListUpAndCorrect フラグが False の場合、Final_DataPath に基づくデータの取得は
            行わず、引数 ListUpKey を取得値として取り扱い、その後の処理を行います。ListUpKey は補助関数 ProcessListTags() によって抽出された、レスポンス
            データのデータパスの一部です。このようなリスト項目を処理するために、[list] タグが項目名に含まれているかや、NotListUpAndCorrect フラグの状態を
            確認した上で、補助関数 ProcessListTags() を適切に呼び出し、ListUpKey を取得値として一時的に管理及びリストとして構造化するための引数
            ProcessedValue_ofListTags に格納します。期待値が特定の条件を満たす場合（例：UnixTime、TimeZone、LocalTime が期待値に含まれる場合）、取得値
            は他の条件を経ることなく、補助関数 DataFormatProcessor() を通じて正規データ構造を含む StructuredData に格納します。期待値が設定されていない
            場合、または補助関数 ComparisonWithExpected() によって取得値が期待値と一致することが確認された場合、同様に StructuredData への格納処理を行い
            ます。この関数の最終的な責務は、取得値を適切に正規化し、用意されたデータ構造に従って StructuredData に格納することです。これにより、API からの
            レスポンスデータをアプリケーションが取り扱うデータ構造に正規化することを実現し、アプリケーションの後続の処理でのデータの取り扱いを容易にします。最終
            的に、更新した StructuredData を関数の返り値として返します。この関数の設計により、様々な API からの異なるデータ構造のレスポンスデータを効率的に
            処理し、アプリケーションのデータ構造に統合することが可能になります。

            Parameters:
                EndpointName (str): レスポンスデータ取得元のエンドポイント名。
                ItemName (str): 関数 self.ExtractAndFormatData() の引数 DataPaths における、処理中の項目名。
                NotListUpAndCorrect (bool): [listup] タグが処理されたかどうかを示すフラグ。
                ListUpKey (str): [listup] タグによって取り出されたデータパス内のキー。
                Data (list or dict): 関数 self.ExtractAndFormatData() の引数 Data を Python オブジェクトに変換したレスポンスデータ。
                Final_DataPath (str):
                    Data から値を取り出すために全てのタグを取り除き、インデックス指定指示セグメントを実際のインデックスに最適化したデータパス。
                bool_ofIndexedListTags (bool):
                    [list] タグを含む引数 ItemName（リスト項目）のデータパスがインデックス処理されたものかどうかを示すフラグ。
                ExpectedValues (tuple of tuples): 期待値。二重のタプル形式。内側のタプル一つにつき一つの期待値を表す。
                NegatedValues (tuple of tuples): 否定的期待値。二重のタプル形式。内側のタプル一つにつき一つの期待値を表す。
                DataHandleForm (dict): 取得値をアプリケーションが取り扱うデータ構造に正規化するための設計指示を含む辞書の参照。
                StructuredData (dict): 取得値をアプリケーションが取り扱うデータ構造に正規化する先の辞書の参照。
                ProcessedValue_ofListTags (dict): [list] [listup] タグによって取得値を構造化する先の辞書の参照。
                DataIndex (int, optional): 関数 self.ExtractAndFormatData() の引数 Data の一単位のデータに対するインデックス番号。

            Returns:
                dict: 元の StructuredData の正規化したデータ構造に取得値を格納した辞書。
            """
            # データパスが [listup] タグを含まない場合のデータ取得処理
            if NotListUpAndCorrect and Final_DataPath in ("StatusCode"):  # データパスが "StatusCode" の場合、これを取得値とする
                RawValue = "StatusCode"  # "StatusCode" を代入
            elif NotListUpAndCorrect:  # 通常のデータ取得処理
                RawValue = GetDataVal(Data, Final_DataPath)  # Data から Final_DataPath を使用して RawValue を取得

            if NotListUpAndCorrect:  # データパスが [listup] タグを含まない場合、取得値と期待値を必要に応じて正規化（ProcessedValue）
                ProcessedValue = ConvertExtractedValueWithExpected(EndpointName, ItemName, RawValue, ExpectedValues)
            # データパスが [listup] タグを含む場合、データパスから取り出した ListUpKey を取得値とする（ProcessedValue）
            elif not NotListUpAndCorrect:
                ProcessedValue = ListUpKey  # ListUpKey を代入

            if (ExpectedValues and ExpectedValues[0]) or (NegatedValues and NegatedValues[0]):  # 期待値が設定されている場合の取得値の取り扱い
                if any(any(Check  # 期待値が特定の値の場合、取得値を StructuredData に格納する if ブロックを実行
                for Check in {"UnixTime", "TimeZone", "LocalTime",}  # 期待値を構成する要素が特定の値と完全一致するか確認
                if Check in ExpectedValue)  # 期待値の中に Check のいずれかが含まれている場合
                for ExpectedTuple in ExpectedValues  # 全期待値を表すタプルから単一の期待値を表すタプルを取り出す
                for ExpectedValue in ExpectedTuple  # 全期待値を表すタプルから取り出した単一の期待値を表すタプルから期待値を構成する要素を取り出す
                if isinstance(ExpectedValue, str)):  # 期待値を構成する要素が文字列型（str）の場合、特定の値と完全一致するか確認
                    # 取得値を StructuredData に格納
                    StructuredData = DataFormatProcessor(
                        EndpointName, ItemName, DataHandleForm, ProcessedValue, StructuredData, DataIndex)
                # 期待値が特定の値でない場合、取得値と期待値が一致するかの照合を行う
                elif ComparisonWithExpected(ProcessedValue, ExpectedValues, NegatedValues):
                    if "[list]" not in ItemName and NotListUpAndCorrect:  # 取得値がリスト項目でない場合、項目名を StructuredData に格納する
                        # 項目名を StructuredData に格納
                        StructuredData = DataFormatProcessor(
                            EndpointName, ItemName, DataHandleForm, ItemName, StructuredData, DataIndex)
                        """
ここでは、補助関数 DataFormatProcessor() の引数に ItemName を二つ設定していますが、これは誤りではなく、ItemName を取得値として保存するためのプロセスを示す
ものです。ItemName = 項目名には、例えば「買い」や「売り」などがあり、これらは API のレスポンスデータ内では「Buy」「buy」などの形式で表され、各項目名の期待値
としてこれらの値を設定し、照合処理を行うことで、レスポンスデータの任意の表現を「買い」や「売り」として識別します。このブロックでは、照合処理によって識別された
「買い」や「売り」といった項目名を取得値として取り扱うための処理を行っています。このアプローチは、API が半角英字以外の文字で同じ内容を表現する場合、即ち、メソッド
lower() で小文字化できない文字での表現にも、アプリケーションが内部的に対応可能となる環境を提供します。
                        """
                    elif NotListUpAndCorrect:  # 取得値がリスト項目である場合、タグに基づきリストを作成または編集する
                        # 取得値を一時的に管理及びリストとして構造化するための ProcessedValue_ofListTags に格納
                        ProcessListTags(CallNum = self.App.副, ItemName = ItemName, bool_ofIndexedListTags = bool_ofIndexedListTags,
                            DataIndex = DataIndex, Data_ofListTags = ProcessedValue_ofListTags, ProcessedValue = ProcessedValue)
            # 期待値が設定されてなく、リスト項目でない場合、取得値を StructuredData に格納する
            elif ExpectedValues is None and NegatedValues is None and "[list]" not in ItemName and NotListUpAndCorrect:
                # 取得値を StructuredData に格納
                StructuredData = DataFormatProcessor(EndpointName, ItemName, DataHandleForm, ProcessedValue, StructuredData, DataIndex)
            # 期待値が設定されてなく、リスト項目である場合、タグに基づきリストを作成または編集する
            elif ExpectedValues is None and NegatedValues is None:
                # 取得値または ListUpKey を一時的に管理及びリストとして構造化するための ProcessedValue_ofListTags に格納
                ProcessListTags(CallNum = self.App.副, ItemName = ItemName, bool_ofIndexedListTags = bool_ofIndexedListTags,
                    DataIndex = DataIndex, Data_ofListTags = ProcessedValue_ofListTags, ProcessedValue = ProcessedValue)

            return StructuredData  # 元の StructuredData に取得値を格納した StructuredData を返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # プロセッサー 1：複数のデータパスを含む文字列（str）を解析し、それぞれの項目名とデータパス、期待値を分離
        def FirstProcess_SeparateDataPaths(EndpointName, DataPaths):
            """ この部分を「関数の docstring」と言います。
            複数のデータパスを含む文字列（str）を解析し、それぞれの項目名とデータパス、期待値を分離する関数。

            この関数は、渡された「複数のデータパスを含む文字列」を解析し、後続の処理で対応可能なデータに変換します。取得値と期待値が一致しないことを期待する
            否定的期待値のパターン "!:" が存在する場合、期待値を否定的期待値として保存します。データパスが "null" の場合、対応する項目は後続の処理から除外
            します。
            処理の各過程に対応するログが LogManagerClass によって BackLog 属性に記録されます。

            DataPaths の例："項目名1/data.path1 項目名2/data.path2:val1,val2word1_val2word2 項目名3/data.path3!:val"

            Parameters:
                EndpointName (str): レスポンスデータ取得元のエンドポイント名。
                DataPaths (str): 項目名、データパス、期待値を記号で連結した文字列を空白区切りで複数含む文字列。

            Returns:
                dict: データパスと期待値のタプルのリストを項目名をキーとして持つ辞書。

            Raises:
                ValueError:
                    ● パターン 1: 項目名とデータパスを区切る "/" が存在しない場合に発生。
                    ● パターン 2: 項目名、データパス、期待値を構成する文字列に "/" が複数存在する場合に発生。
                    ● パターン 3: 一単位のデータパスと通常の期待値を表す文字列に区切り文字 ":" が複数存在する場合に発生。
                    ● パターン 4: 一単位のデータパスと否定的期待値を表す文字列に区切り文字 "!:" が複数存在する場合に発生。
                    ● パターン 5: データパスの項目名に [list] タグのない同名の項目名が設定されている場合に発生。
            """
            # 補助関数：期待値の最終整形
            def FinalizeExpectedValues(ExpectedValues):
                """ この部分を「関数の docstring」と言います。
                期待値の最終整形を行う関数。

                この関数は、渡された期待値を表す文字列（str）を後続の処理で利用可能なデータ、二重のタプル形式に変換します。単一の期待値が複数の単語から成る
                場合、単語間を区切る "_" を識別して分割し、各単語を単一の期待値を表すタプルの期待値を構成する要素として保存します。保存先のタプルは二重の
                タプル形式の内側のタプルです。期待値が複数存在する場合、各期待値を区切る "," を識別して分割し、それぞれを単一の期待値を表すタプルとして保存
                します。これらのタプルの保存先は二重のタプル形式の外側のタプルで、この外側のタプルは全期待値を表します。

                Parameters:
                    ExpectedValues (str): 期待値を表す文字列。

                Returns:
                    tuple of tuples: 期待値のタプル（二重のタプル形式）。
                """
                return tuple(  # ジェネレータ式を開始し、期待値を二重のタプル形式に変換
                    # 期待値に "_" が含まれる場合、分割してリストを取得し、単一の期待値を表すタプルに変換、含まれない場合、直接単一の期待値を表すタプルとする
                    # 三項演算子によって分割記号が含まれていない場合、不要な split() と filter() の実行を回避
                    tuple(filter(None, ExpectedValue.split("_"))) if "_" in ExpectedValue else (ExpectedValue,)
                    # 期待値に "," が含まれる場合、分割してリストを取得し、イテレータを作成、含まれない場合、直接全期待値を表すタプル、二重のタプル形式とする
                    for ExpectedValue in filter(None, ExpectedValues.split(","))) if "," in ExpectedValues else ((ExpectedValues,),)
                """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

            """ FirstProcess_SeparateDataPaths() の記述 """
            DataPaths_Dict = {}  # データパスと期待値のタプルを項目名をキーとして格納する辞書を初期化

            try:  # エラーを検出するブロック
                self.LogManager.RecordBackLOG("データ処理：データパス解析開始", self.ThreadID)
                # 項目名、データパス、期待値を記号で連結した文字列を空白区切りで複数含む文字列を空白で分割してリストを取得し、
                # 単一の文字列を処理するためのイテレーション
                for Path in filter(None, DataPaths.split()):
                    if "/" not in Path:  # 項目名とデータパスが "/" で区切られていない場合、ValueError を発生させる
                        raise ValueError("項目名とデータパスを区切る「/」が存在しません。エンドポイント名：{0}、設定状況：{1}".format(
                            str(EndpointName), str(Path)))
                    elif Path.count("/") > 1:  # Path に "/" が複数存在する場合、ValueError を発生させる
                        raise ValueError(("項目名、データパス、期待値を構成する文字列に「/」を複数使用することはできません。"
                            "エンドポイント名：{0}、設定状況：{1}").format(str(EndpointName), str(Path)))

                    ItemName, Path_WithExpectedValues = Path.split("/", 1)  # Path を "/" で分割してリストを取得し、項目名とデータパスに分離
                    """
ここでは、メソッド split() が二つの要素を含むリストを返すと分かっているため、結果を代入する先をあらかじめリストが含む要素の数だけ用意しておきます。このようにする
ことで、メソッドが返す複数の要素を含むリストを自動的にアンパックすることができ、リストの要素はそれぞれリスト内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                    """

                    if Path_WithExpectedValues in ("null"):  # データパスが "null" の場合、その項目を処理から除外
                        continue  # 次のイテレーションを行う指示

                    if Path_WithExpectedValues.count(":") > 1:  # 通常の期待値を表す ":" が複数存在する場合、ValueError を発生させる
                        raise ValueError(("一単位のデータパスと期待値を表す文字列に区切り文字「:」を複数使用することはできません。"
                            "エンドポイント名：{0}、設定状況：{1}").format(str(EndpointName), str(Path_WithExpectedValues)))
                    elif Path_WithExpectedValues.count("!:") > 1:  # 否定的期待値を表す "!:" が複数存在する場合、ValueError を発生させる
                        raise ValueError(("一単位のデータパスと否定的期待値を表す文字列に区切り文字「!:」を複数使用することはできません。"
                            "エンドポイント名：{0}、設定状況：{1}").format(str(EndpointName), str(Path_WithExpectedValues)))

                    ExpectedValues = None  # 通常の期待値を保存する変数を初期化
                    NegatedValues = None  # 否定的期待値を保存する変数を初期化

                    if "!:" in Path_WithExpectedValues:  # 否定的期待値を表す "!:" が存在する場合、データパスと否定的期待値を分離
                        # "!:" で分割してリストを取得し、データパスと否定的期待値に分離
                        DataPath, NegatedValues = Path_WithExpectedValues.split("!:", 1)
                    elif ":" in Path_WithExpectedValues:  # 通常の期待値を表す ":" が存在する場合、データパスと通常の期待値を分離
                        # ":" で分割してリストを取得し、データパスと通常の期待値に分離
                        DataPath, ExpectedValues = Path_WithExpectedValues.split(":", 1)
                    else:  # どちらの期待値も存在しない場合、Path_WithExpectedValues をデータパスとして取り扱う
                        DataPath = Path_WithExpectedValues

                    if ExpectedValues:  # 通常の期待値が存在する場合、期待値の最終整形を行う
                        ExpectedValues = FinalizeExpectedValues(ExpectedValues)  # 補助関数で処理し、元の変数に再代入
                    if NegatedValues:  # 否定的期待値が存在する場合、期待値の最終整形を行う
                        NegatedValues = FinalizeExpectedValues(NegatedValues)  # 補助関数で処理し、元の変数に再代入

                    PathTuple = (DataPath, ExpectedValues, NegatedValues)  # データパス、通常の期待値、否定的期待値を後続の処理に渡すためタプル化
                    # （各期待値が存在しない場合、None のままタプル化）

                    # データパスと期待値のタプルを項目名をキーとして辞書に格納
                    if ItemName not in DataPaths_Dict:  # 項目名が辞書のキーとして存在しない場合、新たなキーとし、データパスと期待値のタプルを格納
                        DataPaths_Dict[ItemName] = [PathTuple,]  # データパスと期待値のタプルはリストの要素とする
                    else:  # 項目名が辞書のキーとして存在する場合、[list] タグに基づいて処理
                        # 項目名に [list] タグが存在する場合、リスト項目として既存の項目名のリストにデータパスと期待値のタプルを追加
                        if "[list]" in ItemName:
                            DataPaths_Dict[ItemName].append(PathTuple)  # 既存の項目名のリストにデータパスと期待値のタプルを追加
                        else:  # 項目名に [list] タグが存在しない場合、ValueError を発生させる
                            raise ValueError(("データパスの項目名に [list] タグのない同名の項目名を設定することはできません。"
                                "エンドポイント名：{0}、項目名：{1}").format(str(EndpointName), str(ItemName)))

                self.LogManager.RecordBackLOG("データ処理：データパス解析完了", self.ThreadID)
            except Exception as e:  # 何らかのエラーが発生した場合
                # エラー内容の一文字目が全角文字の場合、カスタマイズされたエラーと判断
                if not unicodedata.east_asian_width(str(e)[0]) in ("Na", "H"):
                    raise e
                else:  # カスタマイズされたエラーでない場合、エラー内容に情報を補足して再発生させる
                    EndpointName = "不明" if not EndpointName else EndpointName  # エラー内容に補足するエンドポイント名を設定
                    ItemName = "不明" if not ItemName else ItemName  # エラー内容に補足する項目名を設定

                    # エラー内容に情報を補足して再発生させる
                    raise Exception("エンドポイント名：{0}、項目名：{1}、エラータイプ：{2}、エラー内容：{3}".format(
                        str(EndpointName), str(ItemName), str(type(e).__name__), str(e)))

            return DataPaths_Dict  # データパスと期待値のタプルを項目名をキーとして格納した辞書を返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        # プロセッサー 2：渡された JSON データから値を取り出し、期待値に応じて処理し、アプリケーションが取り扱うデータ構造へ正規化
        def SecondProcess_DataRetrievalAndFormat(EndpointName, StructuredData, Data, DataHandleForm):
            """ この部分を「関数の docstring」と言います。
            渡された JSON データから値を取り出し、期待値に応じて処理し、アプリケーションが取り扱うデータ構造へ正規化する関数。

            この関数は、指定のエンドポイントからの JSON 形式のレスポンスデータを解析し、必要なデータを取り出し、アプリケーションが取り扱うデータ構造へ正規化
            する処理を包括的にハンドルします。そのためのデータ処理指示は引数 StructuredData から取り出すもの、引数 DataHandleForm として直接渡されるものの
            二種類があり、これらに基づいてレスポンスデータから必要なデータを取り出し、期待値に基づいて正規化します。処理はデータパスの解析、リストタグの処理、
            期待値との照合、及び正規化したデータの StructuredData["Data"] に対する正規構造化を含みます。データパスがインデックス指定指示を含む項目や
            リスト項目に対しても、適切な形式のデータになるように正規化を施します。何らかのエラーが発生した場合は、カスタマイズされたエラーメッセージをもって例外
            を再発生させるか、カスタマイズされたエラーでない場合はエラーメッセージにデバッグに必要な情報を補足して例外を再発生させます。この一連の処理により、
            様々な API からの異なるデータ構造のレスポンスデータをアプリケーションが取り扱うデータ構造へ正規化し、後続の処理が単一のデータ構造に対する処理のみを
            行えるようにします。
            処理の各過程に対応するログが LogManagerClass によって BackLog 属性に記録されます。

            Parameters:
                EndpointName (str): レスポンスデータ取得元のエンドポイント名。
                StructuredData (dict):
                    データパスと期待値のタプルのリストを項目名をキーとして持つ辞書を含む、
                    取得値をアプリケーションが取り扱うデータ構造に正規化する先の辞書の参照。
                Data (list or dict): 関数 self.ExtractAndFormatData() の引数 Data を Python オブジェクトに変換したレスポンスデータ。
                DataHandleForm (dict): 取得値をアプリケーションが取り扱うデータ構造に正規化するための設計指示を含む辞書の参照。

            Returns:
                dict: 元の StructuredData の正規化したデータ構造に取得値を格納した辞書。
            """
            MaxNestLevel = self.App.MaxNestLevel  # アプリケーションで対応するネストの深さを取得（整数値、int）
            FirstLevelIsIndex = False  # Data 自体がインデックス参照可能なデータ型の場合、そのインデックス範囲の取得を一回に制限するフラグを定義
            IndexPositions_ofDataPath = {}  # 「データパスの要インデックス指定セグメントの位置」と「対応するインデックス範囲」のタプルを保存する辞書を定義
            ProcessedValue_ofListTags = {"FlatData": {}, "IndexedData": []}  # [list] [listup] タグによって取得値を構造化する先の辞書を定義

            try:  # エラーを検出するブロック
                # 各項目名に対応するデータパスを処理するためのイテレーション
                for ItemName, List_ofPathTuples in StructuredData["DataPaths"].items():
                    for PathTuple in List_ofPathTuples:  # [list] タグを含む ItemName（リスト項目）のためのイテレーション
                        Raw_DataPath = PathTuple[0]  # データパスを取得

                        # [list] 及び [listup] タグのチェックとタグに応じた処理、Indexing フラグは [listup] タグの状態に依存
                        NotListUpAndCorrect, Indexing, ListUpKey, ProcessedDataPath = ProcessListTags(
                            CallNum = self.App.主, EndpointName = EndpointName, ItemName = ItemName, DataPath = Raw_DataPath)
                        """
ここでは、関数が複数の要素を含むタプルを返すと分かっているため、関数の返り値を代入する先をあらかじめタプルが含む要素の数だけ用意しておきます。このようにすること
で、関数が返す複数の要素を含むタプルを自動的にアンパックすることができ、タプルの要素はそれぞれタプル内での順序に従って、用意した代入先に代入されます。
ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。
                        """

                        # データパスに [listup] タグが存在しないか、存在するがデータパスが [index] タグを含む場合
                        if NotListUpAndCorrect or (ListUpKey and Indexing):
                            # データパスが [index] タグを含む場合、データとの整合性を確認し、[index] セグメントの位置とインデックス範囲を取得
                            Skip_ListDataPath, FirstLevelIsIndex, PathList_ofIndex = IterationAnalyzeIndexWithAllowedDepth(
                                EndpointName, ItemName, Data, ProcessedDataPath, MaxNestLevel, FirstLevelIsIndex,
                                IndexPositions_ofDataPath, CallNum = self.App.通常)
                                # CallNum を 1 にすると、データパスが [index] タグを含む場合の処理をスキップするフラグを返す

                            # Skip_ListDataPath フラグが True の場合、データパスが [index] タグを含む場合の処理をスキップする
                            if Skip_ListDataPath:
                                self.LogManager.RecordBackLOG("データ処理：リストデータスキップ", self.ThreadID)
                                continue  # 次のイテレーションを行う指示

                            # データパスが [index] タグを含む場合、そのセグメントをインデックス番号に置換
                            Check_GeneratedIndexedDataPaths, AllIndexedPaths = ReplaceIndexSegmentsAndGenerateDataPathsOfRange(
                                ProcessedDataPath, PathList_ofIndex, IndexPositions_ofDataPath, CallNum = self.App.通常)
                                # CallNum を 1 にすると、[index] タグをインデックス番号に置換したデータパスのリストを確認するためのフラグを返す

                            # Check_GeneratedIndexedDataPaths フラグが True の場合
                            if Check_GeneratedIndexedDataPaths:
                                # [index] タグをインデックス番号に置換したデータパスのリストを確認のため結果に格納する
                                StructuredData["GeneratedIndexedDataPaths"][ItemName] = AllIndexedPaths
                                continue  # 次のイテレーションを行う指示

                        ExpectedValues = PathTuple[1]  # 通常の期待値を取得、存在しなければ None が取り出される
                        NegatedValues = PathTuple[2]  # 否定的期待値を取得、存在しなければ None が取り出される
                        if ExpectedValues:  # 通常の期待値が存在する場合、期待値を必要に応じて型変換
                            ExpectedValues = ConvertExpectedValues(ExpectedValues)
                        elif NegatedValues:  # 否定的期待値が存在する場合、期待値を必要に応じて型変換
                            NegatedValues = ConvertExpectedValues(NegatedValues)
                        if ExpectedValues or NegatedValues:  # 通常の期待値または否定的期待値が存在する場合のログ記録
                            self.LogManager.RecordBackLOG("データ処理：期待値取得完了", self.ThreadID)

                        self.LogManager.RecordBackLOG("データ処理：データ抽出準備完了", self.ThreadID)
                        self.LogManager.RecordBackLOG("データ処理：データ抽出及び構造化開始", self.ThreadID)
                        if "[index]" not in ProcessedDataPath:  # データパスが [index] タグを含まない場合の最終プロセス
                            bool_ofIndexedListTags = False  # リスト項目のデータパスがインデックス処理されたものかどうかを示すフラグを無効化
                            StructuredData = FinalProcess_ofSecondProcess(EndpointName, ItemName, NotListUpAndCorrect, ListUpKey, Data,
                                ProcessedDataPath, bool_ofIndexedListTags, ExpectedValues, NegatedValues, DataHandleForm,
                                StructuredData, ProcessedValue_ofListTags)  # 最終プロセスを実行
                        elif "[index]" in ProcessedDataPath:  # データパスが [index] タグを含む場合の最終プロセス
                            bool_ofIndexedListTags = True  # リスト項目のデータパスがインデックス処理されたものかどうかを示すフラグを有効化
                            # 全てのインデックス範囲に対して最終プロセスを実行するためのイテレーション
                            # （イテレータ番号を正規化のためのインデックス番号に転用）
                            for DataIndex, Indexed_DataPath in enumerate(AllIndexedPaths):
                                # システムログにプログレスバーの表示を開始、インデックスは 0 から始まるので総数を減じる
                                self.ReportProgress(DataIndex, (len(AllIndexedPaths) - 1))
                                StructuredData = FinalProcess_ofSecondProcess(EndpointName, ItemName, NotListUpAndCorrect, ListUpKey,
                                    Data, Indexed_DataPath, bool_ofIndexedListTags, ExpectedValues, NegatedValues, DataHandleForm,
                                    StructuredData, ProcessedValue_ofListTags, DataIndex)  # 最終プロセスを実行
                            if "[list]" in ItemName or "[listup]" in Raw_DataPath:  # リスト項目を処理した場合、重複ログの省略処理を実行
                                self.LogManager.ToProcessedBackLOG(self.ThreadID)

                    # リスト項目を処理した場合、取得値を別途 StructuredData に格納する
                    if ProcessedValue_ofListTags["FlatData"] or ProcessedValue_ofListTags["IndexedData"]:
                        self.LogManager.RecordBackLOG("データ処理：リストタグ項目を抽出", self.ThreadID)
                        if not bool_ofIndexedListTags:  # データパスが [index] タグを含まない場合
                            # リスト化したリスト項目と対応するリストを取り出すためのイテレーション
                            for ItemName, ProcessedValue_ofList in ProcessedValue_ofListTags["FlatData"].items():
                                # リスト項目に対応するリストから取得値を取り出すためのイテレーション、イテレータ番号を正規化のためのインデックス番号に転用
                                for DataIndex1, ProcessedValue in enumerate(ProcessedValue_ofList):
                                    StructuredData = DataFormatProcessor(EndpointName, ItemName, DataHandleForm, ProcessedValue,
                                        StructuredData, DataIndex1)  # 取得値の格納処理を実行
                            ProcessedValue_ofListTags["FlatData"] = {}  # 取得値取り出し後、内容を空の辞書として初期化
                        elif bool_ofIndexedListTags:  # データパスが [index] タグを含む場合
                            # 全てのインデックス範囲から単位データを取り出すためのイテレーション、イテレータ番号を正規化のためのインデックス番号に転用
                            for DataIndex1, DataElement in enumerate(ProcessedValue_ofListTags["IndexedData"]):
                                # システムログにプログレスバーの表示を開始、インデックスは 0 から始まるので総数を減じる
                                self.ReportProgress(DataIndex1, (len(ProcessedValue_ofListTags["IndexedData"]) - 1))
                                # リスト化したリスト項目と対応するリストを取り出すためのイテレーション
                                for ItemName, ProcessedValue_ofList in DataElement.items():
                                    # リスト項目に対応するリストから取得値を取り出すためのイテレーション
                                    # （イテレータ番号を正規化のためのインデックス番号に転用）
                                    for DataIndex2, ProcessedValue in enumerate(ProcessedValue_ofList):
                                        StructuredData = DataFormatProcessor(EndpointName, ItemName, DataHandleForm, ProcessedValue,
                                            StructuredData, DataIndex1, DataIndex2)  # 取得値の格納処理を実行
                            ProcessedValue_ofListTags["IndexedData"] = []  # 取得値取り出し後、内容を空のリストとして初期化
            except Exception as e:  # 何らかのエラーが発生した場合
                # エラー内容の一文字目が全角文字の場合、カスタマイズされたエラーと判断
                if not unicodedata.east_asian_width(str(e)[0]) in ("Na", "H"):
                    raise e
                else:  # カスタマイズされたエラーでない場合、エラー内容に情報を補足して再発生させる
                    EndpointName = "不明" if not EndpointName else EndpointName  # エラー内容に補足するエンドポイント名を設定
                    ItemName = "不明" if not ItemName else ItemName  # エラー内容に補足する項目名を設定

                    # エラー内容に情報を補足して再発生させる
                    raise Exception("エンドポイント名：{0}、項目名：{1}、エラータイプ：{2}、エラー内容：{3}".format(
                        str(EndpointName), str(ItemName), str(type(e).__name__), str(e)))

            return StructuredData  # 元の StructuredData に取得値を格納した StructuredData を返す
            """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

        """ self.ExtractAndFormatData() の記述 """
        if not PathTest:  # パステストのための呼び出しでない場合、TaskMonitoringThreadClass に処理の開始を通知
            self.TaskStartedSignal.emit(self.ThreadID, self.App.TaskNames["ExtractAndFormatData"])

        Except = False  # エラーが発生した場合の条件分岐用フラグを初期化
        try:  # エラーを検出するブロック
            self.LogManager.RecordBackLOG("データ処理：処理開始", self.ThreadID)
            StructuredData = {}  # 取得値をアプリケーションが取り扱うデータ構造に正規化する先の辞書を定義
            DataHandleForm = self.App.DataHandleForm[EndpointName]  # アプリケーションが取り扱うデータ構造に正規化するための設計指示を取得
            self.LogManager.RecordBackLOG("データ処理：初期化完了", self.ThreadID)

            if isinstance(Data, str):  # Data が文字列型（str）の場合、その JSON 文字列を Python オブジェクトに変換
                Data = json.loads(Data)  # JSON 文字列を Python オブジェクトに変換
                self.LogManager.RecordBackLOG("データ処理：JSON オブジェクト変換完了", self.ThreadID)
                """
関数 json.loads() の loads の末尾の "s" は、string（文字列）のイニシャルです。
これを付けない関数 json.load() は、データをファイルから読み込む際に使用します。
                """

            self.LogManager.RecordBackLOG("データ処理：データパス取得開始", self.ThreadID)
            # 複数のデータパスを含む文字列（str）を解析し、それぞれの項目名とデータパス、期待値を分離
            StructuredData["DataPaths"] = FirstProcess_SeparateDataPaths(EndpointName, DataPaths)
            self.LogManager.RecordBackLOG("データ処理：データパス取得完了", self.ThreadID)

            self.LogManager.RecordBackLOG("データ処理：データ抽出開始", self.ThreadID)
            # 渡された JSON データから値を取り出し、期待値に応じて処理し、アプリケーションが取り扱うデータ構造へ正規化
            StructuredData = SecondProcess_DataRetrievalAndFormat(EndpointName, StructuredData, Data, DataHandleForm)
            StructuredData[EndpointName]["TemplatePath"] = "全項目処理完了"
            self.LogManager.RecordBackLOG("データ処理：データ抽出及び構造化完了", self.ThreadID)
        except json.JSONDecodeError as e:  # JSONDecodeError が発生した場合
            self.LogManager.RecordBackLOG("データ処理：JSON 形式エラー「{0}」".format(str(e)), self.ThreadID)
            self.LogManager.RecordBackLOG("データ処理：レスポンスデータ処理失敗", self.ThreadID)
            self.LogManager.RecordBackLOG("データ解析中にエラーが発生しました。不正な形式の JSON データの読み込み試行が行われました。", self.ThreadID)
            Except = True  # エラーが発生した場合の条件分岐用フラグを有効化
        except (ValueError, TypeError) as e:  # ValueError または TypeError が発生した場合
            self.LogManager.RecordBackLOG("データ処理：データ解析エラー：「{0}」".format(str(e)), self.ThreadID)
            self.LogManager.RecordBackLOG("データ処理：レスポンスデータ処理失敗", self.ThreadID)
            self.LogManager.RecordBackLOG("データ解析中にエラーが発生しました。データパスが正しく設定されていない可能性があります。", self.ThreadID)
            Except = True  # エラーが発生した場合の条件分岐用フラグを有効化
        except Exception as e:  # 何らかのエラーが発生した場合
            self.LogManager.RecordBackLOG("データ処理：予期しないエラー「{0}」".format(str(e)), self.ThreadID)
            self.LogManager.RecordBackLOG("データ処理：レスポンスデータ処理失敗", self.ThreadID)
            Except = True  # エラーが発生した場合の条件分岐用フラグを有効化

        # 正常に処理が完了した場合
        if not Except and PathTest:  # パステストのための呼び出しの場合、結果を AppClass（self.App）属性に保存
            setattr(self.App, "StructuredData_ofPathTest", StructuredData)
            # MainThreadFunctionsClass に処理の完了を通知
            self.TaskCompletedSignal_1.emit(self.ThreadID, self.App.TaskNames["PathTest"])
        elif not Except and not PathTest:  # パステストのための呼び出しでない場合、正規化した StructuredData を返す
            # TaskMonitoringThreadClass に処理の完了を通知
            self.TaskCompletedSignal_2.emit(self.ThreadID, self.App.TaskNames["ExtractAndFormatData"], True)
            return StructuredData  # 正規化した StructuredData を返す
        # 処理中に何らかの例外が発生した場合
        elif Except and PathTest:  # パステストのための呼び出しの場合、処理を中断したことを通知
            self.TaskCompletedSignal_1.emit(self.ThreadID, self.App.TaskNames["PathTest"])
        elif Except and not PathTest:  # パステストのための呼び出しでない場合、処理を中断したことを示すフラグを返す
            self.TaskCompletedSignal_2.emit(self.ThreadID, self.App.TaskNames["ExtractAndFormatData"], True)
            return False  # 処理を中断したことを示すフラグを返す
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

# バックグラウンドスレッドで行われる処理が要する時間に応じてバックログ、バックグラウンドスレッドのログを取り出すシグナルを発行するクラス
class TaskMonitoringThreadClass(QObject):  # QObject を継承（PyQt フレームワークのシグナルとスロットのメカニズムを使用するため）
    """ この部分を「クラスの docstring」と言います。
    このクラスは、バックグラウンドスレッドで開始されたデータ処理タスクのモニタリングを行う役割を持ちます。このクラスの全ての関数はバックグラウンドスレッド
    （QThread）で動作することを前提に設計されています。このため、このクラスのインスタンスはバックグラウンドスレッド（QThread）に移動されている必要があります。
    これが行われることで、アプリケーションはメインスレッドで行うべきではないデータ処理タスクのモニタリングをバックグラウンドスレッドで行うことが可能となります。
    データ処理タスクのモニタリングとは、具体的にはメインスレッドがバックグラウンドスレッドでのデータ処理タスクをトリガーした際に、このクラスの関数 AddTask() に
    そのことを伝え、一定時間が経過してもデータ処理タスクの完了が通知されない場合に GUI にバックグラウンドスレッドで蓄積されたシステムログを反映させることを言い
    ます。これにより、ユーザーはバックグラウンドスレッドでのデータ処理タスクの進行状況を把握することができるようになります。このクラスでは各データ処理タスク毎に
    時間経過を計測するタイマーを設定するのではなく、このクラスのコンストラクタであらかじめタイマーを設定及び開始し、500 ミリ秒 = 0.5 秒毎に実行中のデータ処理
    タスクが存在するかを確認します。これにより、各データ処理タスク毎にタイマーを設定するオーバーヘッドを回避することを実現しています。また、アプリケーションの
    エンジンはユーザーから別途指示がない限り、バックグラウンドスレッドでのデータ処理タスクを実行し続けます。即ち、データ処理タスクの開始はバックグラウンドスレッド
    から通知されることもあります。このクラスの関数はその場合でも適切に機能し、エンジンが稼働し続ける限り一定時間毎にシステムログを GUI に反映します。
    """
    # シグナルを定義（シグナルを発行する際はトリガーする関数の引数がオプショナルな場合でも値の指定が必要）
    # クラス内で発生するイベントを通知するシグナル
    # バックログ（バックグラウンドスレッドのログ）の挿入ポイントを ThreadID で通知するシグナル
    # （int は関数 InsertBackLOG() の引数 ThreadID に対応。一つ目の bool は LongProcess に対応。二つ目の bool は Completed に対応）
    InsertBackLogSignal = pyqtSignal(int, bool, bool)  # int は ThreadID

    # TaskMonitoringThreadClass を初期化する関数（コンストラクタ）
    def __init__(self):
        """ この部分を「関数の docstring」と言います。
        TaskMonitoringThreadClass を初期化する関数。

        この初期化関数は、TaskMonitoringThreadClass の新しいインスタンスを作成します。初期化時に引数を求めることはなく、一つのタイマーを初期化し、
        500 ミリ秒 = 0.5 秒毎にタイマーが発行するタイムアウトシグナルを、バックグラウンドスレッドのデータ処理タスクのモニタリングを行う関数
        self.CheckTasks() に接続します。タイマーはこのクラスが初期化された瞬間から 500 ミリ秒 = 0.5 秒の時間経過の計測を開始し、時間経過毎に都度、関数
        self.CheckTasks() を呼び出します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        # QObject の初期化（バックグラウンドスレッドのデータ処理タスクのモニタリング専用スレッドなため、parent は省略（デフォルト値：None））
        super(TaskMonitoringThreadClass, self).__init__()

        # クラス（self）属性を定義
        self.Tasks = {}  # バックグラウンドスレッドで行われるデータ処理タスクの状況を記録する辞書の定義
        self.ProgressTimer = QTimer()  # 一定時間毎のモニタリングのためのタイマーのインスタンスを作成
        self.ProgressTimer.timeout.connect(self.CheckTasks)  # 一定時間経過時に発行されるタイムアウトシグナルを関数 self.CheckTasks() に接続
        self.ProgressTimer.start(500)  # タイマーに 500 ミリ秒 = 0.5 秒を設定してスタート
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 新しいタスクをモニタリング辞書に追加する関数
    @pyqtSlot(int, str)  # シグナルに対するスロットであることを示すデコレータ
    def AddTask(self, ThreadID, TaskName):
        """ この部分を「関数の docstring」と言います。
        新しいタスクをモニタリング辞書に追加する関数。

        この関数は、バックグラウンドスレッドでのデータ処理タスクの開始を通知するメインスレッドのシグナル AddTaskSignal とバックグラウンドスレッドのシグナル
        TaskStartedSignal にスロットとして接続され、各シグナルの情報に基づいてバックグラウンドスレッドで開始されたデータ処理タスクをモニタリング辞書に追加
        します。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            ThreadID (int): SubThreadFunctionsClass のインスタンスが属しているバックグラウンドスレッドの一意な番号。整数値。
            TaskName (str): バックグラウンドスレッドでのデータ処理を開始したタスクの名前。

        Returns:
            なし。
        """
        # クラス（self）属性のバックグラウンドスレッドで行われるデータ処理タスクの状況を記録する属性に新しいタスクを追加
        self.Tasks[ThreadID] = {"TaskName": TaskName, "Completed": False}  # 追加する辞書は関数 self.CheckTasks() で TaskInfo として扱われる
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # 各データ処理タスクの状況をチェックし、未完了であればシステムログを GUI に反映するシグナルを発行する関数
    def CheckTasks(self):
        """ この部分を「関数の docstring」と言います。
        各データ処理タスクの状況をチェックし、未完了であればシステムログを GUI に反映するシグナルを発行する関数。

        この関数は、このクラスのコンストラクタ（関数 self.__init__()）で設定された時間が経過してもバックグラウンドスレッドのデータ処理タスクが完了していない
        場合に「一つのデータ処理タスクが長時間に渡り行われている」と判断し、そのデータ処理タスクが記録しているバックログ（バックグラウンドスレッドのログ）を GUI
        に反映させるシグナルを発行します。これにより、ユーザーはバックグラウンドスレッドで長時間に渡り行われているデータ処理タスクが存在することを把握することが
        できるようになり、アプリケーションが「応答なし」状態になっているわけではないことを知ることができます。このユーザーエクスペリエンスを実現するためには、
        バックグラウンドスレッドで長時間に渡り行われる可能性のあるデータ処理タスクには適切にシステムログを記録するロジックや進捗率表示を行うロジック
        （関数 ReportProgress()）を組み込むことが重要です。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            なし。

        Returns:
            なし。
        """
        for ThreadID, TaskInfo in list(self.Tasks.items()):  # モニタリング辞書の各データ処理タスクをチェックするためのイテレーション
            if not TaskInfo["Completed"]:  # データ処理タスクが未完了の場合、システムログを GUI に反映するシグナルを発行
                # バックグラウンドスレッドのシステムログをログテキストエリア（QTextEdit）に挿入
                self.InsertBackLogSignal.emit(ThreadID, True, False)
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

    # データ処理タスクの完了シグナルを受け、モニタリング辞書から当該タスクを削除する関数
    @pyqtSlot(int, str, bool)  # シグナルに対するスロットであることを示すデコレータ
    def TaskCompleted(self, ThreadID, TaskName, CallerIsSubThread = False):
        """ この部分を「関数の docstring」と言います。
        データ処理タスクの完了シグナルを受け、モニタリング辞書から当該タスクを削除する関数。

        この関数は、バックグラウンドスレッドでのデータ処理タスクの完了を通知するメインスレッドのシグナル TaskCompletedSignal とバックグラウンドスレッドの
        シグナル TaskCompletedSignal_2 にスロットとして接続され、各シグナルの情報に基づいてバックグラウンドスレッドでの処理が完了したデータ処理タスクを
        モニタリング辞書から削除します。引数 CallerIsSubThread が True の場合、データ処理タスクの完了通知がバックグラウンドスレッドのエンジンからのもので
        あると判断し、システムログを GUI に反映するシグナルを発行し、バックログ（バックグラウンドスレッドのログ）をログテキストエリアに反映させる処理も行います。

        Parameters:
            "self" はインスタンス関数（？）を定義する際の第一引数ですが、呼び出し時に明示的に渡す必要はありません。
            ThreadID (int): SubThreadFunctionsClass のインスタンスが属しているバックグラウンドスレッドの一意な番号。整数値。
            TaskName (str): バックグラウンドスレッドでのデータ処理が完了したタスクの名前。
            CallerIsSubThread (bool, optional): バックグラウンドスレッドからシグナルを送る場合は True、そうでない場合は False（デフォルト）。

        Returns:
            なし。
        """
        if ThreadID in self.Tasks and self.Tasks[ThreadID]["TaskName"] == TaskName:  # データ処理タスクがモニタリング辞書に存在することを確認
            del self.Tasks[ThreadID]  # 完了したデータ処理タスクをモニタリング辞書から削除
            # （1 スレッド 1 タスクの原則に基づき、一つのスレッドで同時に二つ以上のタスクが実行されることはないため、ThreadID に基づいてタスクを削除可能）

        # シグナルがバックグラウンドスレッドのエンジンからのものであることを示すフラグが有効な場合、システムログを GUI に反映するシグナルを発行
        if CallerIsSubThread:
            self.InsertBackLogSignal.emit(ThreadID, False, True)  # バックグラウンドスレッドのシステムログをログテキストエリア（QTextEdit）に挿入
        """ ここまでで技術的に不明な箇所がある場合、ChatGPT 4 にお尋ねください。 """

# アプリケーションを開始する関数
def AppStart():
    """ この部分を「関数の docstring」と言います。
    アプリケーションを開始する関数。

    この関数は、Python コードが実行された場合にアプリケーションを開始・起動させます。

    Parameters:
        なし。

    Returns:
        なし。
    """
    App = QApplication(sys.argv)  # QApplication のインスタンスを作成
    """ QApplication は、アプリケーションの全体的な機能を管理します。 """

    Window = AppClass()  # AppClass のインスタンスを作成
    """ AppClass は、アプリケーションのウィンドウとその機能を管理します。 """

    Window.show()  # ウィンドウを表示

    sys.exit(App.exec_())  # QApplication のイベントループを開始
    """ このループにより、ウィンドウが表示され、ユーザーの操作を待機します。ウィンドウが閉じられるまで、このループはアプリケーションを稼働させ続けます。 """

if __name__ == "__main__":  # プログラムの実行が要求されている場合
    AppStart()  # プログラムを実行
"""
Python がプログラムとして直接実行された場合のみ、このブロックが実行されます。
これはこの Python コードがモジュールとしてインポートされた場合には実行されないようにするための慣習です。
"""
